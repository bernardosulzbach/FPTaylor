// Generated by js_of_ocaml 3.7.0
(function(joo_global_object)
   {"use strict";
    function incr_nat(nat,ofs,len,carry_in)
     {var carry=carry_in;
      for(var i=0;i < len;i++)
       {var x=(nat.data[ofs + i] >>> 0) + carry;
        nat.data[ofs + i] = x | 0;
        if(x == x >>> 0){carry = 0;break}else carry = 1}
      return carry}
    function add_nat(nat1,ofs1,len1,nat2,ofs2,len2,carry_in)
     {var carry=carry_in;
      for(var i=0;i < len2;i++)
       {var
         x=
          (nat1.data[ofs1 + i] >>> 0) + (nat2.data[ofs2 + i] >>> 0) + carry;
        nat1.data[ofs1 + i] = x;
        if(x == x >>> 0)carry = 0;else carry = 1}
      return incr_nat(nat1,ofs1 + len2,len1 - len2,carry)}
    function blit_nat(nat1,ofs1,nat2,ofs2,len)
     {for(var i=0;i < len;i++)nat1.data[ofs1 + i] = nat2.data[ofs2 + i];
      return 0}
    function caml_array_blit(a1,i1,a2,i2,len)
     {if(i2 <= i1)
       for(var j=1;j <= len;j++)a2[i2 + j] = a1[i1 + j];
      else
       for(var j=len;j >= 1;j--)a2[i2 + j] = a1[i1 + j];
      return 0}
    function caml_array_concat(l)
     {var a=[0];
      while(l !== 0)
       {var b=l[1];for(var i=1;i < b.length;i++)a.push(b[i]);l = l[2]}
      return a}
    function caml_raise_with_arg(tag,arg){throw [0,tag,arg]}
    function caml_str_repeat(n,s)
     {if(n == 0)return "";
      if(s.repeat)return s.repeat(n);
      var r="",l=0;
      for(;;)
       {if(n & 1)r += s;
        n >>= 1;
        if(n == 0)return r;
        s += s;
        l++;
        if(l == 9)s.slice(0,1)}}
    function caml_subarray_to_jsbytes(a,i,len)
     {var f=String.fromCharCode;
      if(i == 0 && len <= 4096 && len == a.length)return f.apply(null,a);
      var s="";
      for(;0 < len;i += 1024,len -= 1024)
       s += f.apply(null,a.slice(i,i + Math.min(len,1024)));
      return s}
    function caml_convert_string_to_bytes(s)
     {if(s.t == 2)
       s.c += caml_str_repeat(s.l - s.c.length,"\0");
      else
       s.c = caml_subarray_to_jsbytes(s.c,0,s.c.length);
      s.t = 0}
    function jsoo_is_ascii(s)
     {if(s.length < 24)
       {for(var i=0;i < s.length;i++)if(s.charCodeAt(i) > 127)return false;
        return true}
      else
       return ! /[^\x00-\x7f]/.test(s)}
    function caml_utf16_of_utf8(s)
     {for(var b="",t="",c,c1,c2,v,i=0,l=s.length;i < l;i++)
       {c1 = s.charCodeAt(i);
        if(c1 < 0x80)
         {for(var j=i + 1;j < l && (c1 = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        v = 1;
        if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
         {c = c2 + (c1 << 6);
          if(c1 < 0xe0)
           {v = c - 0x3080;if(v < 0x80)v = 1}
          else
           {v = 2;
            if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
             {c = c2 + (c << 6);
              if(c1 < 0xf0)
               {v = c - 0xe2080;
                if(v < 0x800 || v >= 0xd7ff && v < 0xe000)v = 2}
              else
               {v = 3;
                if
                 (++i
                  <
                  l
                  &&
                  ((c2 = s.charCodeAt(i)) & - 64)
                  ==
                  128
                  &&
                  c1
                  <
                  0xf5)
                 {v = c2 - 0x3c82080 + (c << 6);
                  if(v < 0x10000 || v > 0x10ffff)v = 3}}}}}
        if(v < 4)
         {i -= v;t += "\ufffd"}
        else
         if(v > 0xffff)
          t += String.fromCharCode(0xd7c0 + (v >> 10),0xdc00 + (v & 0x3FF));
         else
          t += String.fromCharCode(v);
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function MlBytes(tag,contents,length)
     {this.t = tag;this.c = contents;this.l = length}
    MlBytes.prototype.toString
    =
    function()
     {switch(this.t)
       {case 9:return this.c;
        default:caml_convert_string_to_bytes(this);case 0:
         if(jsoo_is_ascii(this.c)){this.t = 9;return this.c}this.t = 8;
        case 8:return this.c
        }};
    MlBytes.prototype.toUtf16
    =
    function()
     {var r=this.toString();
      if(this.t == 9)return r;
      return caml_utf16_of_utf8(r)};
    MlBytes.prototype.slice
    =
    function()
     {var content=this.t == 4?this.c.slice():this.c;
      return new MlBytes(this.t,content,this.l)};
    function caml_bytes_of_jsbytes(s){return new MlBytes(0,s,s.length)}
    function caml_string_of_jsbytes(s){return caml_bytes_of_jsbytes(s)}
    function caml_raise_with_string(tag,msg)
     {caml_raise_with_arg(tag,caml_string_of_jsbytes(msg))}
    var caml_global_data=[0];
    function caml_invalid_argument(msg)
     {caml_raise_with_string(caml_global_data.Invalid_argument,msg)}
    function caml_array_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_array_get(array,index)
     {if(index < 0 || index >= array.length - 1)caml_array_bound_error();
      return array[index + 1]}
    function caml_array_set(array,index,newval)
     {if(index < 0 || index >= array.length - 1)caml_array_bound_error();
      array[index + 1] = newval;
      return 0}
    function caml_array_sub(a,i,len)
     {var a2=new Array(len + 1);
      a2[0] = 0;
      for(var i2=1,i1=i + 1;i2 <= len;i2++,i1++)a2[i2] = a[i1];
      return a2}
    function caml_convert_bytes_to_array(s)
     {if(joo_global_object.Uint8Array)
       var a=new (joo_global_object.Uint8Array)(s.l);
      else
       var a=new Array(s.l);
      var b=s.c,l=b.length,i=0;
      for(;i < l;i++)a[i] = b.charCodeAt(i);
      for(l = s.l;i < l;i++)a[i] = 0;
      s.c = a;
      s.t = 4;
      return a}
    function caml_blit_bytes(s1,i1,s2,i2,len)
     {if(len == 0)return 0;
      if(i2 == 0 && (len >= s2.l || s2.t == 2 && len >= s2.c.length))
       {s2.c
        =
        s1.t == 4
         ?caml_subarray_to_jsbytes(s1.c,i1,len)
         :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
        s2.t = s2.c.length == s2.l?0:2}
      else
       if(s2.t == 2 && i2 == s2.c.length)
        {s2.c
         +=
         s1.t == 4
          ?caml_subarray_to_jsbytes(s1.c,i1,len)
          :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
         s2.t = s2.c.length == s2.l?0:2}
       else
        {if(s2.t != 4)caml_convert_bytes_to_array(s2);
         var c1=s1.c,c2=s2.c;
         if(s1.t == 4)
          if(i2 <= i1)
           for(var i=0;i < len;i++)c2[i2 + i] = c1[i1 + i];
          else
           for(var i=len - 1;i >= 0;i--)c2[i2 + i] = c1[i1 + i];
         else
          {var l=Math.min(len,c1.length - i1);
           for(var i=0;i < l;i++)c2[i2 + i] = c1.charCodeAt(i1 + i);
           for(;i < len;i++)c2[i2 + i] = 0}}
      return 0}
    function caml_bytes_of_string(s){return s}
    function caml_blit_string(a,b,c,d,e)
     {caml_blit_bytes(caml_bytes_of_string(a),b,c,d,e);return 0}
    function caml_bytes_equal(s1,s2)
     {if(s1 === s2)return 1;
      s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c == s2.c?1:0}
    function caml_bytes_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_bytes_unsafe_get(s,i)
     {switch(s.t & 6)
       {default:if(i >= s.c.length)return 0;case 0:return s.c.charCodeAt(i);
        case 4:return s.c[i]
        }}
    function caml_bytes_get(s,i)
     {if(i >>> 0 >= s.l)caml_bytes_bound_error();
      return caml_bytes_unsafe_get(s,i)}
    function caml_bytes_unsafe_set(s,i,c)
     {c &= 0xff;
      if(s.t != 4)
       {if(i == s.c.length)
         {s.c += String.fromCharCode(c);if(i + 1 == s.l)s.t = 0;return 0}
        caml_convert_bytes_to_array(s)}
      s.c[i] = c;
      return 0}
    function caml_bytes_set(s,i,c)
     {if(i >>> 0 >= s.l)caml_bytes_bound_error();
      return caml_bytes_unsafe_set(s,i,c)}
    function caml_call_gen(f,args)
     {if(f.fun)return caml_call_gen(f.fun,args);
      if(typeof f !== "function")return f;
      var n=f.length | 0;
      if(n === 0)return f.apply(null,args);
      var argsLen=args.length | 0,d=n - argsLen | 0;
      if(d == 0)
       return f.apply(null,args);
      else
       if(d < 0)
        return caml_call_gen(f.apply(null,args.slice(0,n)),args.slice(n));
       else
        return function()
         {var
           extra_args=arguments.length == 0?1:arguments.length,
           nargs=new Array(args.length + extra_args);
          for(var i=0;i < args.length;i++)nargs[i] = args[i];
          for(var i=0;i < arguments.length;i++)
           nargs[args.length + i] = arguments[i];
          return caml_call_gen(f,nargs)}}
    function caml_check_bound(array,index)
     {if(index >>> 0 >= array.length - 1)caml_array_bound_error();
      return array}
    function caml_classify_float(x)
     {if(isFinite(x))
       {if(Math.abs(x) >= 2.2250738585072014e-308)return 0;
        if(x != 0)return 1;
        return 2}
      return isNaN(x)?4:3}
    function caml_jsbytes_of_string(s)
     {if((s.t & 6) != 0)caml_convert_string_to_bytes(s);return s.c}
    var log2_ok=Math.log2 && Math.log2(1.1235582092889474E+307) == 1020;
    function jsoo_floor_log2(x)
     {if(log2_ok)return Math.floor(Math.log2(x));
      var i=0;
      if(x == 0)return - Infinity;
      if(x >= 1)while(x >= 2){x /= 2;i++}else while(x < 1){x *= 2;i--}
      return i}
    function caml_int32_bits_of_float(x)
     {var float32a=new (joo_global_object.Float32Array)(1);
      float32a[0] = x;
      var int32a=new (joo_global_object.Int32Array)(float32a.buffer);
      return int32a[0] | 0}
    var caml_int64_offset=Math.pow(2,- 24);
    function caml_raise_constant(tag){throw tag}
    function caml_raise_zero_divide()
     {caml_raise_constant(caml_global_data.Division_by_zero)}
    function MlInt64(lo,mi,hi)
     {this.lo = lo & 0xffffff;this.mi = mi & 0xffffff;this.hi = hi & 0xffff}
    MlInt64.prototype.caml_custom = "_j";
    MlInt64.prototype.copy
    =
    function(){return new MlInt64(this.lo,this.mi,this.hi)};
    MlInt64.prototype.ucompare
    =
    function(x)
     {if(this.hi > x.hi)return 1;
      if(this.hi < x.hi)return - 1;
      if(this.mi > x.mi)return 1;
      if(this.mi < x.mi)return - 1;
      if(this.lo > x.lo)return 1;
      if(this.lo < x.lo)return - 1;
      return 0};
    MlInt64.prototype.compare
    =
    function(x)
     {var hi=this.hi << 16,xhi=x.hi << 16;
      if(hi > xhi)return 1;
      if(hi < xhi)return - 1;
      if(this.mi > x.mi)return 1;
      if(this.mi < x.mi)return - 1;
      if(this.lo > x.lo)return 1;
      if(this.lo < x.lo)return - 1;
      return 0};
    MlInt64.prototype.neg
    =
    function()
     {var lo=- this.lo,mi=- this.mi + (lo >> 24),hi=- this.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.add
    =
    function(x)
     {var
       lo=this.lo + x.lo,
       mi=this.mi + x.mi + (lo >> 24),
       hi=this.hi + x.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.sub
    =
    function(x)
     {var
       lo=this.lo - x.lo,
       mi=this.mi - x.mi + (lo >> 24),
       hi=this.hi - x.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.mul
    =
    function(x)
     {var
       lo=this.lo * x.lo,
       mi=(lo * caml_int64_offset | 0) + this.mi * x.lo + this.lo * x.mi,
       hi=
        (mi * caml_int64_offset | 0)
        +
        this.hi
        *
        x.lo
        +
        this.mi
        *
        x.mi
        +
        this.lo
        *
        x.hi;
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.isZero
    =
    function(){return (this.lo | this.mi | this.hi) == 0};
    MlInt64.prototype.isNeg = function(){return this.hi << 16 < 0};
    MlInt64.prototype.and
    =
    function(x)
     {return new MlInt64(this.lo & x.lo,this.mi & x.mi,this.hi & x.hi)};
    MlInt64.prototype.or
    =
    function(x)
     {return new MlInt64(this.lo | x.lo,this.mi | x.mi,this.hi | x.hi)};
    MlInt64.prototype.xor
    =
    function(x)
     {return new MlInt64(this.lo ^ x.lo,this.mi ^ x.mi,this.hi ^ x.hi)};
    MlInt64.prototype.shift_left
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      if(s < 24)
       return new
               MlInt64
               (this.lo << s,
                this.mi << s | this.lo >> 24 - s,
                this.hi << s | this.mi >> 24 - s);
      if(s < 48)
       return new
               MlInt64
               (0,this.lo << s - 24,this.mi << s - 24 | this.lo >> 48 - s);
      return new MlInt64(0,0,this.lo << s - 48)};
    MlInt64.prototype.shift_right_unsigned
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      if(s < 24)
       return new
               MlInt64
               (this.lo >> s | this.mi << 24 - s,
                this.mi >> s | this.hi << 24 - s,
                this.hi >> s);
      if(s < 48)
       return new
               MlInt64
               (this.mi >> s - 24 | this.hi << 48 - s,this.hi >> s - 24,0);
      return new MlInt64(this.hi >> s - 48,0,0)};
    MlInt64.prototype.shift_right
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      var h=this.hi << 16 >> 16;
      if(s < 24)
       return new
               MlInt64
               (this.lo >> s | this.mi << 24 - s,
                this.mi >> s | h << 24 - s,
                this.hi << 16 >> s >>> 16);
      var sign=this.hi << 16 >> 31;
      if(s < 48)
       return new
               MlInt64
               (this.mi >> s - 24 | this.hi << 48 - s,
                this.hi << 16 >> s - 24 >> 16,
                sign & 0xffff);
      return new MlInt64(this.hi << 16 >> s - 32,sign,sign)};
    MlInt64.prototype.lsl1
    =
    function()
     {this.hi = this.hi << 1 | this.mi >> 23;
      this.mi = (this.mi << 1 | this.lo >> 23) & 0xffffff;
      this.lo = this.lo << 1 & 0xffffff};
    MlInt64.prototype.lsr1
    =
    function()
     {this.lo = (this.lo >>> 1 | this.mi << 23) & 0xffffff;
      this.mi = (this.mi >>> 1 | this.hi << 23) & 0xffffff;
      this.hi = this.hi >>> 1};
    MlInt64.prototype.udivmod
    =
    function(x)
     {var
       offset=0,
       modulus=this.copy(),
       divisor=x.copy(),
       quotient=new MlInt64(0,0,0);
      while(modulus.ucompare(divisor) > 0){offset++;divisor.lsl1()}
      while(offset >= 0)
       {offset--;
        quotient.lsl1();
        if(modulus.ucompare(divisor) >= 0)
         {quotient.lo++;modulus = modulus.sub(divisor)}
        divisor.lsr1()}
      return {quotient:quotient,modulus:modulus}};
    MlInt64.prototype.div
    =
    function(y)
     {var x=this;
      if(y.isZero())caml_raise_zero_divide();
      var sign=x.hi ^ y.hi;
      if(x.hi & 0x8000)x = x.neg();
      if(y.hi & 0x8000)y = y.neg();
      var q=x.udivmod(y).quotient;
      if(sign & 0x8000)q = q.neg();
      return q};
    MlInt64.prototype.mod
    =
    function(y)
     {var x=this;
      if(y.isZero())caml_raise_zero_divide();
      var sign=x.hi;
      if(x.hi & 0x8000)x = x.neg();
      if(y.hi & 0x8000)y = y.neg();
      var r=x.udivmod(y).modulus;
      if(sign & 0x8000)r = r.neg();
      return r};
    MlInt64.prototype.toInt = function(){return this.lo | this.mi << 24};
    MlInt64.prototype.toFloat
    =
    function()
     {return (this.hi << 16)
             *
             Math.pow(2,32)
             +
             this.mi
             *
             Math.pow(2,24)
             +
             this.lo};
    MlInt64.prototype.toArray
    =
    function()
     {return [this.hi >> 8,
              this.hi & 0xff,
              this.mi >> 16,
              this.mi >> 8 & 0xff,
              this.mi & 0xff,
              this.lo >> 16,
              this.lo >> 8 & 0xff,
              this.lo & 0xff]};
    MlInt64.prototype.lo32
    =
    function(){return this.lo | (this.mi & 0xff) << 24};
    MlInt64.prototype.hi32
    =
    function(){return this.mi >>> 8 & 0xffff | this.hi << 16};
    function caml_int64_create_lo_mi_hi(lo,mi,hi)
     {return new MlInt64(lo,mi,hi)}
    function caml_int64_bits_of_float(x)
     {if(! isFinite(x))
       {if(isNaN(x))return caml_int64_create_lo_mi_hi(1,0,0x7ff0);
        return x > 0
                ?caml_int64_create_lo_mi_hi(0,0,0x7ff0)
                :caml_int64_create_lo_mi_hi(0,0,0xfff0)}
      var sign=x == 0 && 1 / x == - Infinity?0x8000:x >= 0?0:0x8000;
      if(sign)x = - x;
      var exp=jsoo_floor_log2(x) + 1023;
      if(exp <= 0)
       {exp = 0;x /= Math.pow(2,- 1026)}
      else
       {x /= Math.pow(2,exp - 1027);
        if(x < 16){x *= 2;exp -= 1}
        if(exp == 0)x /= 2}
      var k=Math.pow(2,24),r3=x | 0;
      x = (x - r3) * k;
      var r2=x | 0;
      x = (x - r2) * k;
      var r1=x | 0;
      r3 = r3 & 0xf | sign | exp << 4;
      return caml_int64_create_lo_mi_hi(r1,r2,r3)}
    function caml_int64_to_bytes(x){return x.toArray()}
    function caml_ba_serialize(writer,ba,sz)
     {writer.write(32,ba.dims.length);
      writer.write(32,ba.kind | ba.layout << 8);
      if(ba.caml_custom == "_bigarr02")
       for(var i=0;i < ba.dims.length;i++)
        if(ba.dims[i] < 0xffff)
         writer.write(16,ba.dims[i]);
        else
         {writer.write(16,0xffff);
          writer.write(32,0);
          writer.write(32,ba.dims[i])}
      else
       for(var i=0;i < ba.dims.length;i++)writer.write(32,ba.dims[i]);
      switch(ba.kind)
       {case 2:
        case 3:
        case 12:
         for(var i=0;i < ba.data.length;i++)writer.write(8,ba.data[i]);break;
        case 4:
        case 5:
         for(var i=0;i < ba.data.length;i++)writer.write(16,ba.data[i]);break;
        case 6:
         for(var i=0;i < ba.data.length;i++)writer.write(32,ba.data[i]);break;
        case 8:
        case 9:
         writer.write(8,0);
         for(var i=0;i < ba.data.length;i++)writer.write(32,ba.data[i]);
         break;
        case 7:
         for(var i=0;i < ba.data.length / 2;i++)
          {var b=caml_int64_to_bytes(ba.get(i));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break;
        case 1:
         for(var i=0;i < ba.data.length;i++)
          {var b=caml_int64_to_bytes(caml_int64_bits_of_float(ba.get(i)));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break;
        case 0:
         for(var i=0;i < ba.data.length;i++)
          {var b=caml_int32_bits_of_float(ba.get(i));writer.write(32,b)}
         break;
        case 10:
         for(var i=0;i < ba.data.length / 2;i++)
          {var j=ba.get(i);
           writer.write(32,caml_int32_bits_of_float(j[1]));
           writer.write(32,caml_int32_bits_of_float(j[2]))}
         break;
        case 11:
         for(var i=0;i < ba.data.length / 2;i++)
          {var
            complex=ba.get(i),
            b=caml_int64_to_bytes(caml_int64_bits_of_float(complex[1]));
           for(var j=0;j < 8;j++)writer.write(8,b[j]);
           var b=caml_int64_to_bytes(caml_int64_bits_of_float(complex[2]));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break
        }
      sz[0] = (4 + ba.dims.length) * 4;
      sz[1] = (4 + ba.dims.length) * 8}
    function caml_ba_get_size_per_element(kind)
     {switch(kind){case 7:case 10:case 11:return 2;default:return 1}}
    function caml_ba_create_buffer(kind,size)
     {var g=joo_global_object,view;
      switch(kind)
       {case 0:view = g.Float32Array;break;
        case 1:view = g.Float64Array;break;
        case 2:view = g.Int8Array;break;
        case 3:view = g.Uint8Array;break;
        case 4:view = g.Int16Array;break;
        case 5:view = g.Uint16Array;break;
        case 6:view = g.Int32Array;break;
        case 7:view = g.Int32Array;break;
        case 8:view = g.Int32Array;break;
        case 9:view = g.Int32Array;break;
        case 10:view = g.Float32Array;break;
        case 11:view = g.Float64Array;break;
        case 12:view = g.Uint8Array;break
        }
      if(! view)caml_invalid_argument("Bigarray.create: unsupported kind");
      var data=new view(size * caml_ba_get_size_per_element(kind));
      return data}
    function caml_int32_float_of_bits(x)
     {var int32a=new (joo_global_object.Int32Array)(1);
      int32a[0] = x;
      var float32a=new (joo_global_object.Float32Array)(int32a.buffer);
      return float32a[0]}
    function caml_int64_of_bytes(a)
     {return new
              MlInt64
              (a[7] << 0 | a[6] << 8 | a[5] << 16,
               a[4] << 0 | a[3] << 8 | a[2] << 16,
               a[1] << 0 | a[0] << 8)}
    function caml_int64_float_of_bits(x)
     {var lo=x.lo,mi=x.mi,hi=x.hi,exp=(hi & 0x7fff) >> 4;
      if(exp == 2047)
       return (lo | mi | hi & 0xf) == 0?hi & 0x8000?- Infinity:Infinity:NaN;
      var k=Math.pow(2,- 24),res=(lo * k + mi) * k + (hi & 0xf);
      if(exp > 0)
       {res += 16;res *= Math.pow(2,exp - 1027)}
      else
       res *= Math.pow(2,- 1026);
      if(hi & 0x8000)res = - res;
      return res}
    function caml_ba_get_size(dims)
     {var n_dims=dims.length,size=1;
      for(var i=0;i < n_dims;i++)
       {if(dims[i] < 0)
         caml_invalid_argument("Bigarray.create: negative dimension");
        size = size * dims[i]}
      return size}
    function caml_int64_create_lo_hi(lo,hi)
     {return new
              MlInt64
              (lo & 0xffffff,
               lo >>> 24 & 0xff | (hi & 0xffff) << 8,
               hi >>> 16 & 0xffff)}
    function caml_int64_hi32(v){return v.hi32()}
    function caml_int64_lo32(v){return v.lo32()}
    var caml_ba_custom_name="_bigarray";
    function Ml_Bigarray(kind,layout,dims,buffer)
     {this.kind = kind;
      this.layout = layout;
      this.dims = dims;
      this.data = buffer}
    Ml_Bigarray.prototype.caml_custom = caml_ba_custom_name;
    Ml_Bigarray.prototype.offset
    =
    function(arg)
     {var ofs=0;
      if(typeof arg === "number")arg = [arg];
      if(! (arg instanceof Array))
       caml_invalid_argument("bigarray.js: invalid offset");
      if(this.dims.length != arg.length)
       caml_invalid_argument("Bigarray.get/set: bad number of dimensions");
      if(this.layout == 0)
       for(var i=0;i < this.dims.length;i++)
        {if(arg[i] < 0 || arg[i] >= this.dims[i])caml_array_bound_error();
         ofs = ofs * this.dims[i] + arg[i]}
      else
       for(var i=this.dims.length - 1;i >= 0;i--)
        {if(arg[i] < 1 || arg[i] > this.dims[i])caml_array_bound_error();
         ofs = ofs * this.dims[i] + (arg[i] - 1)}
      return ofs};
    Ml_Bigarray.prototype.get
    =
    function(ofs)
     {switch(this.kind)
       {case 7:
         var l=this.data[ofs * 2 + 0],h=this.data[ofs * 2 + 1];
         return caml_int64_create_lo_hi(l,h);
        case 10:
        case 11:
         var r=this.data[ofs * 2 + 0],i=this.data[ofs * 2 + 1];
         return [254,r,i];
        default:return this.data[ofs]}};
    Ml_Bigarray.prototype.set
    =
    function(ofs,v)
     {switch(this.kind)
       {case 7:
         this.data[ofs * 2 + 0] = caml_int64_lo32(v);
         this.data[ofs * 2 + 1] = caml_int64_hi32(v);
         break;
        case 10:
        case 11:
         this.data[ofs * 2 + 0] = v[1];this.data[ofs * 2 + 1] = v[2];break;
        default:this.data[ofs] = v;break}
      return 0};
    Ml_Bigarray.prototype.fill
    =
    function(v)
     {switch(this.kind)
       {case 7:
         var a=caml_int64_lo32(v),b=caml_int64_hi32(v);
         if(a == b)
          this.data.fill(a);
         else
          for(var i=0;i < this.data.length;i++)this.data[i] = i % 2 == 0?a:b;
         break;
        case 10:
        case 11:
         var im=v[1],re=v[2];
         if(im == re)
          this.data.fill(im);
         else
          for(var i=0;i < this.data.length;i++)
           this.data[i] = i % 2 == 0?im:re;
         break;
        default:this.data.fill(v);break}};
    Ml_Bigarray.prototype.compare
    =
    function(b,total)
     {if(this.layout != b.layout || this.kind != b.kind)
       {var k1=this.kind | this.layout << 8,k2=b.kind | b.layout << 8;
        return k2 - k1}
      if(this.dims.length != b.dims.length)
       return b.dims.length - this.dims.length;
      for(var i=0;i < this.dims.length;i++)
       if(this.dims[i] != b.dims[i])return this.dims[i] < b.dims[i]?- 1:1;
      switch(this.kind)
       {case 0:
        case 1:
        case 10:
        case 11:
         var x,y;
         for(var i=0;i < this.data.length;i++)
          {x = this.data[i];
           y = b.data[i];
           if(x < y)return - 1;
           if(x > y)return 1;
           if(x != y)
            {if(! total)return NaN;if(x == x)return 1;if(y == y)return - 1}}
         break;
        case 7:
         for(var i=0;i < this.data.length;i += 2)
          {if(this.data[i + 1] < b.data[i + 1])return - 1;
           if(this.data[i + 1] > b.data[i + 1])return 1;
           if(this.data[i] >>> 0 < b.data[i] >>> 0)return - 1;
           if(this.data[i] >>> 0 > b.data[i] >>> 0)return 1}
         break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 8:
        case 9:
        case 12:
         for(var i=0;i < this.data.length;i++)
          {if(this.data[i] < b.data[i])return - 1;
           if(this.data[i] > b.data[i])return 1}
         break
        }
      return 0};
    function Ml_Bigarray_c_1_1(kind,layout,dims,buffer)
     {this.kind = kind;
      this.layout = layout;
      this.dims = dims;
      this.data = buffer}
    Ml_Bigarray_c_1_1.prototype = new Ml_Bigarray();
    Ml_Bigarray_c_1_1.prototype.offset
    =
    function(arg)
     {if(typeof arg !== "number")
       if(arg instanceof Array && arg.length == 1)
        arg = arg[0];
       else
        caml_invalid_argument("Ml_Bigarray_c_1_1.offset");
      if(arg < 0 || arg >= this.dims[0])caml_array_bound_error();
      return arg};
    Ml_Bigarray_c_1_1.prototype.get = function(ofs){return this.data[ofs]};
    Ml_Bigarray_c_1_1.prototype.set
    =
    function(ofs,v){this.data[ofs] = v;return 0};
    Ml_Bigarray_c_1_1.prototype.fill
    =
    function(v){this.data.fill(v);return 0};
    function caml_ba_create_unsafe(kind,layout,dims,data)
     {var size_per_element=caml_ba_get_size_per_element(kind);
      if(caml_ba_get_size(dims) * size_per_element != data.length)
       caml_invalid_argument("length doesn't match dims");
      if(layout == 0 && dims.length == 1 && size_per_element == 1)
       return new Ml_Bigarray_c_1_1(kind,layout,dims,data);
      return new Ml_Bigarray(kind,layout,dims,data)}
    function caml_failwith(msg)
     {caml_raise_with_string(caml_global_data.Failure,msg)}
    function caml_ba_deserialize(reader,sz,name)
     {var num_dims=reader.read32s();
      if(num_dims < 0 || num_dims > 16)
       caml_failwith("input_value: wrong number of bigarray dimensions");
      var tag=reader.read32s(),kind=tag & 0xff,layout=tag >> 8 & 1,dims=[];
      if(name == "_bigarr02")
       for(var i=0;i < num_dims;i++)
        {var size_dim=reader.read16u();
         if(size_dim == 0xffff)
          {var size_dim_hi=reader.read32u(),size_dim_lo=reader.read32u();
           if(size_dim_hi != 0)
            caml_failwith("input_value: bigarray dimension overflow in 32bit");
           size_dim = size_dim_lo}
         dims.push(size_dim)}
      else
       for(var i=0;i < num_dims;i++)dims.push(reader.read32u());
      var
       size=caml_ba_get_size(dims),
       data=caml_ba_create_buffer(kind,size),
       ba=caml_ba_create_unsafe(kind,layout,dims,data);
      switch(kind)
       {case 2:for(var i=0;i < size;i++)data[i] = reader.read8s();break;
        case 3:
        case 12:for(var i=0;i < size;i++)data[i] = reader.read8u();break;
        case 4:for(var i=0;i < size;i++)data[i] = reader.read16s();break;
        case 5:for(var i=0;i < size;i++)data[i] = reader.read16u();break;
        case 6:for(var i=0;i < size;i++)data[i] = reader.read32s();break;
        case 8:
        case 9:
         var sixty=reader.read8u();
         if(sixty)
          caml_failwith
           ("input_value: cannot read bigarray with 64-bit OCaml ints");
         for(var i=0;i < size;i++)data[i] = reader.read32s();
         break;
        case 7:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var int64=caml_int64_of_bytes(t);
           ba.set(i,int64)}
         break;
        case 1:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var f=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           ba.set(i,f)}
         break;
        case 0:
         for(var i=0;i < size;i++)
          {var f=caml_int32_float_of_bits(reader.read32s());ba.set(i,f)}
         break;
        case 10:
         for(var i=0;i < size;i++)
          {var
            re=caml_int32_float_of_bits(reader.read32s()),
            im=caml_int32_float_of_bits(reader.read32s());
           ba.set(i,[254,re,im])}
         break;
        case 11:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var re=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var im=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           ba.set(i,[254,re,im])}
         break
        }
      sz[0] = (4 + num_dims) * 4;
      return caml_ba_create_unsafe(kind,layout,dims,data)}
    function caml_ba_compare(a,b,total){return a.compare(b,total)}
    function caml_mul(a,b){return Math.imul(a,b)}
    function caml_hash_mix_int(h,d)
     {d = caml_mul(d,0xcc9e2d51 | 0);
      d = d << 15 | d >>> 32 - 15;
      d = caml_mul(d,0x1b873593);
      h ^= d;
      h = h << 13 | h >>> 32 - 13;
      return (h + (h << 2) | 0) + (0xe6546b64 | 0) | 0}
    function caml_hash_mix_int64(h,v)
     {h = caml_hash_mix_int(h,caml_int64_lo32(v));
      h = caml_hash_mix_int(h,caml_int64_hi32(v));
      return h}
    function caml_hash_mix_float(h,v0)
     {return caml_hash_mix_int64(h,caml_int64_bits_of_float(v0))}
    function caml_ba_hash(ba)
     {var num_elts=caml_ba_get_size(ba.dims),h=0;
      switch(ba.kind)
       {case 2:
        case 3:
        case 12:
         if(num_elts > 256)num_elts = 256;
         var w=0,i=0;
         for(i = 0;i + 4 <= ba.data.length;i += 4)
          {w
           =
           ba.data[i + 0]
           |
           ba.data[i + 1]
           <<
           8
           |
           ba.data[i + 2]
           <<
           16
           |
           ba.data[i + 3]
           <<
           24;
           h = caml_hash_mix_int(h,w)}
         w = 0;
         switch(num_elts & 3)
          {case 3:w = ba.data[i + 2] << 16;
           case 2:w |= ba.data[i + 1] << 8;
           case 1:w |= ba.data[i + 0];h = caml_hash_mix_int(h,w)
           }
         break;
        case 4:
        case 5:
         if(num_elts > 128)num_elts = 128;
         var w=0,i=0;
         for(i = 0;i + 2 <= ba.data.length;i += 2)
          {w = ba.data[i + 0] | ba.data[i + 1] << 16;
           h = caml_hash_mix_int(h,w)}
         if((num_elts & 1) != 0)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 6:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 8:
        case 9:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 7:
         if(num_elts > 32)num_elts = 32;
         num_elts *= 2;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 10:num_elts *= 2;
        case 0:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_float(h,ba.data[i]);
         break;
        case 11:num_elts *= 2;
        case 1:
         if(num_elts > 32)num_elts = 32;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_float(h,ba.data[i]);
         break
        }
      return h}
    function caml_int32_unmarshal(reader,size)
     {size[0] = 4;return reader.read32s()}
    function caml_nativeint_unmarshal(reader,size)
     {switch(reader.read8u())
       {case 1:size[0] = 4;return reader.read32s();
        case 2:caml_failwith("input_value: native integer value too large");
        default:caml_failwith("input_value: ill-formed native integer")}}
    function caml_int64_unmarshal(reader,size)
     {var t=new Array(8);
      for(var j=0;j < 8;j++)t[j] = reader.read8u();
      size[0] = 8;
      return caml_int64_of_bytes(t)}
    function caml_int64_marshal(writer,v,sizes)
     {var b=caml_int64_to_bytes(v);
      for(var i=0;i < 8;i++)writer.write(8,b[i]);
      sizes[0] = 8;
      sizes[1] = 8}
    function caml_int64_compare(x,y,total){return x.compare(y)}
    function caml_int64_hash(v){return v.lo32() ^ v.hi32()}
    var
     caml_custom_ops=
      {"_j":
       {deserialize:caml_int64_unmarshal,
        serialize:caml_int64_marshal,
        fixed_length:8,
        compare:caml_int64_compare,
        hash:caml_int64_hash},
       "_i":{deserialize:caml_int32_unmarshal,fixed_length:4},
       "_n":{deserialize:caml_nativeint_unmarshal,fixed_length:4},
       "_bigarray":
       {deserialize:
        function(reader,sz){return caml_ba_deserialize(reader,sz,"_bigarray")},
        serialize:caml_ba_serialize,
        compare:caml_ba_compare,
        hash:caml_ba_hash},
       "_bigarr02":
       {deserialize:
        function(reader,sz){return caml_ba_deserialize(reader,sz,"_bigarr02")},
        serialize:caml_ba_serialize,
        compare:caml_ba_compare,
        hash:caml_ba_hash}};
    function caml_compare_val_get_custom(a)
     {return caml_custom_ops[a.caml_custom]
             &&
             caml_custom_ops[a.caml_custom].compare}
    function caml_compare_val_number_custom(num,custom,swap,total)
     {var comp=caml_compare_val_get_custom(custom);
      if(comp)
       {var x=swap > 0?comp(custom,num,total):comp(num,custom,total);
        if(total && x != x)return swap;
        if(+ x != + x)return + x;
        if((x | 0) != 0)return x | 0}
      return swap}
    function caml_is_ml_bytes(s){return s instanceof MlBytes}
    function caml_is_ml_string(s){return caml_is_ml_bytes(s)}
    function caml_compare_val_tag(a)
     {if(typeof a === "number")
       return 1000;
      else
       if(caml_is_ml_bytes(a))
        return 252;
       else
        if(caml_is_ml_string(a))
         return 1252;
        else
         if(a instanceof Array && a[0] === a[0] >>> 0 && a[0] <= 255)
          {var tag=a[0] | 0;return tag == 254?0:tag}
         else
          if(a instanceof String)
           return 12520;
          else
           if(typeof a == "string")
            return 12520;
           else
            if(a instanceof Number)
             return 1000;
            else
             if(a && a.caml_custom)
              return 1255;
             else
              if(a && a.compare)
               return 1256;
              else
               if(typeof a == "function")
                return 1247;
               else
                if(typeof a == "symbol")return 1251;
      return 1001}
    function caml_int_compare(a,b)
     {if(a < b)return - 1;if(a == b)return 0;return 1}
    function caml_bytes_compare(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?- 1:s1.c > s2.c?1:0}
    function caml_string_compare(s1,s2){return caml_bytes_compare(s1,s2)}
    function caml_compare_val(a,b,total)
     {var stack=[];
      for(;;)
       {if(! (total && a === b))
         {var tag_a=caml_compare_val_tag(a);
          if(tag_a == 250){a = a[1];continue}
          var tag_b=caml_compare_val_tag(b);
          if(tag_b == 250){b = b[1];continue}
          if(tag_a !== tag_b)
           {if(tag_a == 1000)
             {if(tag_b == 1255)
               return caml_compare_val_number_custom(a,b,- 1,total);
              return - 1}
            if(tag_b == 1000)
             {if(tag_a == 1255)
               return caml_compare_val_number_custom(b,a,1,total);
              return 1}
            return tag_a < tag_b?- 1:1}
          switch(tag_a)
           {case 247:caml_invalid_argument("compare: functional value");break;
            case 248:
             var x=caml_int_compare(a[2],b[2]);if(x != 0)return x | 0;break;
            case 249:caml_invalid_argument("compare: functional value");break;
            case 250:
             caml_invalid_argument
              ("equal: got Forward_tag, should not happen");
             break;
            case 251:caml_invalid_argument("equal: abstract value");break;
            case 252:
             if(a !== b){var x=caml_bytes_compare(a,b);if(x != 0)return x | 0}
             break;
            case 253:
             caml_invalid_argument("equal: got Double_tag, should not happen");
             break;
            case 254:
             caml_invalid_argument
              ("equal: got Double_array_tag, should not happen");
             break;
            case 255:
             caml_invalid_argument("equal: got Custom_tag, should not happen");
             break;
            case 1247:
             caml_invalid_argument("compare: functional value");break;
            case 1255:
             var comp=caml_compare_val_get_custom(a);
             if(comp != caml_compare_val_get_custom(b))
              return a.caml_custom < b.caml_custom?- 1:1;
             if(! comp)caml_invalid_argument("compare: abstract value");
             var x=comp(a,b,total);
             if(x != x)return total?- 1:x;
             if(x !== (x | 0))return - 1;
             if(x != 0)return x | 0;
             break;
            case 1256:
             var x=a.compare(b,total);
             if(x != x)return total?- 1:x;
             if(x !== (x | 0))return - 1;
             if(x != 0)return x | 0;
             break;
            case 1000:
             a = + a;
             b = + b;
             if(a < b)return - 1;
             if(a > b)return 1;
             if(a != b)
              {if(! total)return NaN;if(a == a)return 1;if(b == b)return - 1}
             break;
            case 1001:
             if(a < b)return - 1;
             if(a > b)return 1;
             if(a != b)
              {if(! total)return NaN;if(a == a)return 1;if(b == b)return - 1}
             break;
            case 1251:if(a !== b){if(! total)return NaN;return 1}break;
            case 1252:
             var a=caml_jsbytes_of_string(a),b=caml_jsbytes_of_string(b);
             if(a !== b){if(a < b)return - 1;if(a > b)return 1}
             break;
            case 12520:
             var a=a.toString(),b=b.toString();
             if(a !== b){if(a < b)return - 1;if(a > b)return 1}
             break;
            case 246:
            case 254:
            default:
             if(a.length != b.length)return a.length < b.length?- 1:1;
             if(a.length > 1)stack.push(a,b,1);
             break}}
        if(stack.length == 0)return 0;
        var i=stack.pop();
        b = stack.pop();
        a = stack.pop();
        if(i + 1 < a.length)stack.push(a,b,i + 1);
        a = a[i];
        b = b[i]}}
    function caml_compare(a,b){return caml_compare_val(a,b,true)}
    function caml_cosh_float(x){return (Math.exp(x) + Math.exp(- x)) / 2}
    function caml_create_bytes(len)
     {if(len < 0)caml_invalid_argument("Bytes.create");
      return new MlBytes(len?2:9,"",len)}
    function caml_jsstring_of_string(s){return s.toUtf16()}
    if(joo_global_object.process && joo_global_object.process.cwd)
     var caml_current_dir=joo_global_object.process.cwd().replace(/\\/g,"/");
    else
     var caml_current_dir="/static";
    if(caml_current_dir.slice(- 1) !== "/")caml_current_dir += "/";
    function caml_make_path(name)
     {name = caml_jsstring_of_string(name);
      if(name.charCodeAt(0) != 47)name = caml_current_dir + name;
      var comp=name.split("/"),ncomp=[];
      for(var i=0;i < comp.length;i++)
       switch(comp[i])
        {case "..":if(ncomp.length > 1)ncomp.pop();break;
         case ".":break;
         case "":if(ncomp.length == 0)ncomp.push("");break;
         default:ncomp.push(comp[i]);break}
      ncomp.orig = name;
      return ncomp}
    function caml_bytes_of_array(a){return new MlBytes(4,a,a.length)}
    function caml_utf8_of_utf16(s)
     {for(var b="",t=b,c,d,i=0,l=s.length;i < l;i++)
       {c = s.charCodeAt(i);
        if(c < 0x80)
         {for(var j=i + 1;j < l && (c = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        if(c < 0x800)
         {t += String.fromCharCode(0xc0 | c >> 6);
          t += String.fromCharCode(0x80 | c & 0x3f)}
        else
         if(c < 0xd800 || c >= 0xdfff)
          t
          +=
          String.fromCharCode
           (0xe0 | c >> 12,0x80 | c >> 6 & 0x3f,0x80 | c & 0x3f);
         else
          if
           (c
            >=
            0xdbff
            ||
            i
            +
            1
            ==
            l
            ||
            (d = s.charCodeAt(i + 1))
            <
            0xdc00
            ||
            d
            >
            0xdfff)
           t += "\xef\xbf\xbd";
          else
           {i++;
            c = (c << 10) + d - 0x35fdc00;
            t
            +=
            String.fromCharCode
             (0xf0 | c >> 18,
              0x80 | c >> 12 & 0x3f,
              0x80 | c >> 6 & 0x3f,
              0x80 | c & 0x3f)}
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function caml_bytes_of_utf16_jsstring(s)
     {var tag=9;
      if(! jsoo_is_ascii(s))tag = 8,s = caml_utf8_of_utf16(s);
      return new MlBytes(tag,s,s.length)}
    function caml_string_of_jsstring(s)
     {return caml_bytes_of_utf16_jsstring(s)}
    function caml_raise_sys_error(msg)
     {caml_raise_with_string(caml_global_data.Sys_error,msg)}
    function caml_raise_no_such_file(name)
     {name = caml_jsbytes_of_string(name);
      caml_raise_sys_error(name + ": No such file or directory")}
    function caml_ml_bytes_length(s){return s.l}
    function MlFile(){}
    function MlFakeFile(content){this.data = content}
    MlFakeFile.prototype = new MlFile();
    MlFakeFile.prototype.truncate
    =
    function(len)
     {var old=this.data;
      this.data = caml_create_bytes(len | 0);
      caml_blit_bytes(old,0,this.data,0,len)};
    MlFakeFile.prototype.length
    =
    function(){return caml_ml_bytes_length(this.data)};
    MlFakeFile.prototype.write
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      if(offset + len >= clen)
       {var new_str=caml_create_bytes(offset + len),old_data=this.data;
        this.data = new_str;
        caml_blit_bytes(old_data,0,this.data,0,clen)}
      caml_blit_string(buf,pos,this.data,offset,len);
      return 0};
    MlFakeFile.prototype.read
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      caml_blit_bytes(this.data,offset,buf,pos,len);
      return 0};
    MlFakeFile.prototype.read_one
    =
    function(offset){return caml_bytes_get(this.data,offset)};
    MlFakeFile.prototype.close = function(){};
    MlFakeFile.prototype.constructor = MlFakeFile;
    function MlFakeDevice(root,f)
     {this.content = {};this.root = root;this.lookupFun = f}
    MlFakeDevice.prototype.nm = function(name){return this.root + name};
    MlFakeDevice.prototype.lookup
    =
    function(name)
     {if(! this.content[name] && this.lookupFun)
       {var
         res=
          this.lookupFun
           (caml_string_of_jsbytes(this.root),caml_string_of_jsbytes(name));
        if(res !== 0)
         this.content[name] = new MlFakeFile(caml_bytes_of_string(res[1]))}};
    MlFakeDevice.prototype.exists
    =
    function(name)
     {if(name == "")return 1;
      var name_slash=name + "/",r=new RegExp("^" + name_slash);
      for(var n in this.content)if(n.match(r))return 1;
      this.lookup(name);
      return this.content[name]?1:0};
    MlFakeDevice.prototype.readdir
    =
    function(name)
     {var
       name_slash=name == ""?"":name + "/",
       r=new RegExp("^" + name_slash + "([^/]*)"),
       seen={},
       a=[];
      for(var n in this.content)
       {var m=n.match(r);
        if(m && ! seen[m[1]]){seen[m[1]] = true;a.push(m[1])}}
      return a};
    MlFakeDevice.prototype.is_dir
    =
    function(name)
     {var
       name_slash=name == ""?"":name + "/",
       r=new RegExp("^" + name_slash + "([^/]*)"),
       a=[];
      for(var n in this.content){var m=n.match(r);if(m)return 1}
      return 0};
    MlFakeDevice.prototype.unlink
    =
    function(name)
     {var ok=this.content[name]?true:false;
      delete this.content[name];
      return ok};
    MlFakeDevice.prototype.open
    =
    function(name,f)
     {if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_text and Open_binary are not compatible");
      this.lookup(name);
      if(this.content[name])
       {if(this.is_dir(name))
         caml_raise_sys_error(this.nm(name) + " : is a directory");
        if(f.create && f.excl)
         caml_raise_sys_error(this.nm(name) + " : file already exists");
        var file=this.content[name];
        if(f.truncate)file.truncate();
        return file}
      else
       if(f.create)
        {this.content[name] = new MlFakeFile(caml_create_bytes(0));
         return this.content[name]}
       else
        caml_raise_no_such_file(this.nm(name))};
    MlFakeDevice.prototype.register
    =
    function(name,content)
     {if(this.content[name])
       caml_raise_sys_error(this.nm(name) + " : file already exists");
      if(caml_is_ml_bytes(content))
       this.content[name] = new MlFakeFile(content);
      if(caml_is_ml_string(content))
       this.content[name] = new MlFakeFile(caml_bytes_of_string(content));
      else
       if(content instanceof Array)
        this.content[name] = new MlFakeFile(caml_bytes_of_array(content));
       else
        if(typeof content === "string")
         this.content[name] = new MlFakeFile(caml_bytes_of_jsbytes(content));
        else
         if(content.toString)
          {var
            bytes=
             caml_bytes_of_string(caml_string_of_jsstring(content.toString()));
           this.content[name] = new MlFakeFile(bytes)}
         else
          caml_raise_sys_error
           (this.nm(name) + " : registering file with invalid content type")};
    MlFakeDevice.prototype.constructor = MlFakeDevice;
    function caml_ml_string_length(s){return caml_ml_bytes_length(s)}
    function caml_string_unsafe_get(s,i){return caml_bytes_unsafe_get(s,i)}
    function caml_array_of_string(s)
     {var l=caml_ml_string_length(s),a=new Array(l),i=0;
      for(;i < l;i++)a[i] = caml_string_unsafe_get(s,i);
      return a}
    function caml_array_of_bytes(s)
     {if(s.t != 4)caml_convert_bytes_to_array(s);return s.c}
    function MlNodeFile(fd){this.fs = require("fs");this.fd = fd}
    MlNodeFile.prototype = new MlFile();
    MlNodeFile.prototype.truncate
    =
    function(len)
     {try
       {this.fs.ftruncateSync(this.fd,len | 0)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.length
    =
    function()
     {try
       {return this.fs.fstatSync(this.fd).size}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.write
    =
    function(offset,buf,buf_offset,len)
     {var a=caml_array_of_string(buf);
      if(! (a instanceof joo_global_object.Uint8Array))
       a = new (joo_global_object.Uint8Array)(a);
      var buffer=joo_global_object.Buffer.from(a);
      try
       {this.fs.writeSync(this.fd,buffer,buf_offset,len,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      return 0};
    MlNodeFile.prototype.read
    =
    function(offset,buf,buf_offset,len)
     {var a=caml_array_of_bytes(buf);
      if(! (a instanceof joo_global_object.Uint8Array))
       a = new (joo_global_object.Uint8Array)(a);
      var buffer=joo_global_object.Buffer.from(a);
      try
       {this.fs.readSync(this.fd,buffer,buf_offset,len,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      for(var i=0;i < len;i++)
       caml_bytes_set(buf,buf_offset + i,buffer[buf_offset + i]);
      return 0};
    MlNodeFile.prototype.read_one
    =
    function(offset)
     {var
       a=new (joo_global_object.Uint8Array)(1),
       buffer=joo_global_object.Buffer.from(a);
      try
       {this.fs.readSync(this.fd,buffer,0,1,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      return buffer[0]};
    MlNodeFile.prototype.close
    =
    function()
     {try
       {this.fs.closeSync(this.fd)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.constructor = MlNodeFile;
    function MlNodeDevice(root){this.fs = require("fs");this.root = root}
    MlNodeDevice.prototype.nm = function(name){return this.root + name};
    MlNodeDevice.prototype.exists
    =
    function(name)
     {try
       {return this.fs.existsSync(this.nm(name))?1:0}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.readdir
    =
    function(name)
     {try
       {return this.fs.readdirSync(this.nm(name))}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.is_dir
    =
    function(name)
     {try
       {return this.fs.statSync(this.nm(name)).isDirectory()?1:0}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.unlink
    =
    function(name)
     {try
       {var b=this.fs.existsSync(this.nm(name))?1:0;
        this.fs.unlinkSync(this.nm(name))}
      catch(err){caml_raise_sys_error(err.toString())}
      return b};
    MlNodeDevice.prototype.open
    =
    function(name,f)
     {var consts=require("constants"),res=0;
      for(var key in f)
       switch(key)
        {case "rdonly":res |= consts.O_RDONLY;break;
         case "wronly":res |= consts.O_WRONLY;break;
         case "append":res |= consts.O_WRONLY | consts.O_APPEND;break;
         case "create":res |= consts.O_CREAT;break;
         case "truncate":res |= consts.O_TRUNC;break;
         case "excl":res |= consts.O_EXCL;break;
         case "binary":res |= consts.O_BINARY;break;
         case "text":res |= consts.O_TEXT;break;
         case "nonblock":res |= consts.O_NONBLOCK;break
         }
      try
       {var fd=this.fs.openSync(this.nm(name),res);return new MlNodeFile(fd)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.rename
    =
    function(o,n)
     {try
       {this.fs.renameSync(this.nm(o),this.nm(n))}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.constructor = MlNodeDevice;
    var caml_root=caml_current_dir.match(/[^\/]*\//)[0];
    function fs_node_supported()
     {return typeof joo_global_object.process
             !==
             "undefined"
             &&
             typeof joo_global_object.process.versions
             !==
             "undefined"
             &&
             typeof joo_global_object.process.versions.node
             !==
             "undefined"
             &&
             joo_global_object.process.platform
             !==
             "browser"}
    var jsoo_mount_point=[];
    if(fs_node_supported())
     jsoo_mount_point.push
      ({path:caml_root,device:new MlNodeDevice(caml_root)});
    else
     jsoo_mount_point.push
      ({path:caml_root,device:new MlFakeDevice(caml_root)});
    jsoo_mount_point.push
     ({path:caml_root + "static/",
       device:new MlFakeDevice(caml_root + "static/")});
    function resolve_fs_device(name)
     {var
       path=caml_make_path(name),
       name=path.join("/"),
       name_slash=name + "/",
       res;
      for(var i=0;i < jsoo_mount_point.length;i++)
       {var m=jsoo_mount_point[i];
        if
         (name_slash.search(m.path)
          ==
          0
          &&
          (! res || res.path.length < m.path.length))
         res
         =
         {path:m.path,
          device:m.device,
          rest:name.substring(m.path.length,name.length)}}
      return res}
    function caml_create_file(name,content)
     {var
       name=typeof name == "string"?caml_string_of_jsbytes(name):name,
       content=
        typeof content == "string"?caml_string_of_jsbytes(content):content,
       root=resolve_fs_device(name);
      if(! root.device.register)caml_failwith("cannot register file");
      root.device.register(root.rest,content);
      return 0}
    function caml_div(x,y)
     {if(y == 0)caml_raise_zero_divide();return x / y | 0}
    function caml_equal(x,y){return + (caml_compare_val(x,y,false) == 0)}
    function caml_fill_bytes(s,i,l,c)
     {if(l > 0)
       if(i == 0 && (l >= s.l || s.t == 2 && l >= s.c.length))
        if(c == 0)
         {s.c = "";s.t = 2}
        else
         {s.c = caml_str_repeat(l,String.fromCharCode(c));s.t = l == s.l?0:2}
       else
        {if(s.t != 4)caml_convert_bytes_to_array(s);
         for(l += i;i < l;i++)s.c[i] = c}
      return 0}
    function caml_float_compare(x,y)
     {if(x === y)return 0;
      if(x < y)return - 1;
      if(x > y)return 1;
      if(x === x)return 1;
      if(y === y)return - 1;
      return 0}
    function caml_float_of_string(s)
     {var res;
      s = caml_jsbytes_of_string(s);
      res = + s;
      if(s.length > 0 && res === res)return res;
      s = s.replace(/_/g,"");
      res = + s;
      if(s.length > 0 && res === res || /^[+-]?nan$/i.test(s))return res;
      var m=/^ *([+-]?)0x([0-9a-f]+)\.?([0-9a-f]*)p([+-]?[0-9]+)/i.exec(s);
      if(m)
       {var
         m3=m[3].replace(/0+$/,""),
         mantissa=parseInt(m[1] + m[2] + m3,16),
         exponent=(m[4] | 0) - 4 * m3.length;
        res = mantissa * Math.pow(2,exponent);
        return res}
      if(/^\+?inf(inity)?$/i.test(s))return Infinity;
      if(/^-inf(inity)?$/i.test(s))return - Infinity;
      caml_failwith("float_of_string")}
    function caml_parse_format(fmt)
     {fmt = caml_jsbytes_of_string(fmt);
      var len=fmt.length;
      if(len > 31)caml_invalid_argument("format_int: format too long");
      var
       f=
        {justify:"+",
         signstyle:"-",
         filler:" ",
         alternate:false,
         base:0,
         signedconv:false,
         width:0,
         uppercase:false,
         sign:1,
         prec:- 1,
         conv:"f"};
      for(var i=0;i < len;i++)
       {var c=fmt.charAt(i);
        switch(c)
         {case "-":f.justify = "-";break;
          case "+":
          case " ":f.signstyle = c;break;
          case "0":f.filler = "0";break;
          case "#":f.alternate = true;break;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
           f.width = 0;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.width = f.width * 10 + c;i++}
           i--;
           break;
          case ".":
           f.prec = 0;
           i++;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.prec = f.prec * 10 + c;i++}
           i--;
          case "d":
          case "i":f.signedconv = true;
          case "u":f.base = 10;break;
          case "x":f.base = 16;break;
          case "X":f.base = 16;f.uppercase = true;break;
          case "o":f.base = 8;break;
          case "e":
          case "f":
          case "g":f.signedconv = true;f.conv = c;break;
          case "E":
          case "F":
          case "G":
           f.signedconv = true;
           f.uppercase = true;
           f.conv = c.toLowerCase();
           break
          }}
      return f}
    function caml_finish_formatting(f,rawbuffer)
     {if(f.uppercase)rawbuffer = rawbuffer.toUpperCase();
      var len=rawbuffer.length;
      if(f.signedconv && (f.sign < 0 || f.signstyle != "-"))len++;
      if(f.alternate){if(f.base == 8)len += 1;if(f.base == 16)len += 2}
      var buffer="";
      if(f.justify == "+" && f.filler == " ")
       for(var i=len;i < f.width;i++)buffer += " ";
      if(f.signedconv)
       if(f.sign < 0)
        buffer += "-";
       else
        if(f.signstyle != "-")buffer += f.signstyle;
      if(f.alternate && f.base == 8)buffer += "0";
      if(f.alternate && f.base == 16)buffer += "0x";
      if(f.justify == "+" && f.filler == "0")
       for(var i=len;i < f.width;i++)buffer += "0";
      buffer += rawbuffer;
      if(f.justify == "-")for(var i=len;i < f.width;i++)buffer += " ";
      return caml_string_of_jsbytes(buffer)}
    function caml_format_float(fmt,x)
     {function toFixed(x,dp)
       {if(Math.abs(x) < 1.0)
         return x.toFixed(dp);
        else
         {var e=parseInt(x.toString().split("+")[1]);
          if(e > 20)
           {e -= 20;
            x /= Math.pow(10,e);
            x += new Array(e + 1).join("0");
            if(dp > 0)x = x + "." + new Array(dp + 1).join("0");
            return x}
          else
           return x.toFixed(dp)}}
      var s,f=caml_parse_format(fmt),prec=f.prec < 0?6:f.prec;
      if(x < 0 || x == 0 && 1 / x == - Infinity){f.sign = - 1;x = - x}
      if(isNaN(x))
       {s = "nan";f.filler = " "}
      else
       if(! isFinite(x))
        {s = "inf";f.filler = " "}
       else
        switch(f.conv)
         {case "e":
           var s=x.toExponential(prec),i=s.length;
           if(s.charAt(i - 3) == "e")
            s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
           break;
          case "f":s = toFixed(x,prec);break;
          case "g":
           prec = prec?prec:1;
           s = x.toExponential(prec - 1);
           var j=s.indexOf("e"),exp=+ s.slice(j + 1);
           if(exp < - 4 || x >= 1e21 || x.toFixed(0).length > prec)
            {var i=j - 1;
             while(s.charAt(i) == "0")i--;
             if(s.charAt(i) == ".")i--;
             s = s.slice(0,i + 1) + s.slice(j);
             i = s.length;
             if(s.charAt(i - 3) == "e")
              s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
             break}
           else
            {var p=prec;
             if(exp < 0)
              {p -= exp + 1;s = x.toFixed(p)}
             else
              while(s = x.toFixed(p),s.length > prec + 1)p--;
             if(p)
              {var i=s.length - 1;
               while(s.charAt(i) == "0")i--;
               if(s.charAt(i) == ".")i--;
               s = s.slice(0,i + 1)}}
           break
          }
      return caml_finish_formatting(f,s)}
    function caml_format_int(fmt,i)
     {if(caml_jsbytes_of_string(fmt) == "%d")
       return caml_string_of_jsbytes("" + i);
      var f=caml_parse_format(fmt);
      if(i < 0)if(f.signedconv){f.sign = - 1;i = - i}else i >>>= 0;
      var s=i.toString(f.base);
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - s.length;
        if(n > 0)s = caml_str_repeat(n,"0") + s}
      return caml_finish_formatting(f,s)}
    var caml_oo_last_id=0;
    function caml_fresh_oo_id(){return caml_oo_last_id++}
    function caml_frexp_float(x)
     {if(x == 0 || ! isFinite(x))return [0,x,0];
      var neg=x < 0;
      if(neg)x = - x;
      var exp=Math.max(- 1023,jsoo_floor_log2(x) + 1);
      x *= Math.pow(2,- exp);
      while(x < 0.5){x *= 2;exp--}
      while(x >= 1){x *= 0.5;exp++}
      if(neg)x = - x;
      return [0,x,exp]}
    function caml_fs_init()
     {var tmp=joo_global_object.caml_fs_tmp;
      if(tmp)
       for(var i=0;i < tmp.length;i++)
        caml_create_file(tmp[i].name,tmp[i].content);
      joo_global_object.caml_create_file = caml_create_file;
      joo_global_object.caml_fs_tmp = [];
      return 0}
    function caml_greaterequal(x,y)
     {return + (caml_compare_val(x,y,false) >= 0)}
    function caml_greaterthan(x,y){return + (caml_compare_val(x,y,false) > 0)}
    function caml_hash_mix_jsbytes(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w
        =
        s.charCodeAt(i)
        |
        s.charCodeAt(i + 1)
        <<
        8
        |
        s.charCodeAt(i + 2)
        <<
        16
        |
        s.charCodeAt(i + 3)
        <<
        24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s.charCodeAt(i + 2) << 16;
        case 2:w |= s.charCodeAt(i + 1) << 8;
        case 1:w |= s.charCodeAt(i);h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    function caml_hash_mix_string(h,v)
     {return caml_hash_mix_jsbytes(h,caml_jsbytes_of_string(v))}
    function caml_hash_mix_bytes_arr(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w = s[i] | s[i + 1] << 8 | s[i + 2] << 16 | s[i + 3] << 24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s[i + 2] << 16;
        case 2:w |= s[i + 1] << 8;
        case 1:w |= s[i];h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    function caml_hash_mix_bytes(h,v)
     {switch(v.t & 6)
       {default:caml_convert_string_to_bytes(v);case 0:
         h = caml_hash_mix_jsbytes(h,v.c);break;
        case 2:h = caml_hash_mix_bytes_arr(h,v.c)
        }
      return h}
    function caml_hash_mix_final(h)
     {h ^= h >>> 16;
      h = caml_mul(h,0x85ebca6b | 0);
      h ^= h >>> 13;
      h = caml_mul(h,0xc2b2ae35 | 0);
      h ^= h >>> 16;
      return h}
    function caml_hash(count,limit,seed,obj)
     {var queue,rd,wr,sz,num,h,v,i,len;
      sz = limit;
      if(sz < 0 || sz > 256)sz = 256;
      num = count;
      h = seed;
      queue = [obj];
      rd = 0;
      wr = 1;
      while(rd < wr && num > 0)
       {v = queue[rd++];
        if(v && v.caml_custom)
         {if
           (caml_custom_ops[v.caml_custom]
            &&
            caml_custom_ops[v.caml_custom].hash)
           {var hh=caml_custom_ops[v.caml_custom].hash(v);
            h = caml_hash_mix_int(h,hh);
            num--}}
        else
         if(v instanceof Array && v[0] === (v[0] | 0))
          switch(v[0])
           {case 248:h = caml_hash_mix_int(h,v[2]);num--;break;
            case 250:queue[--rd] = v[1];break;
            default:
             var tag=v.length - 1 << 10 | v[0];
             h = caml_hash_mix_int(h,tag);
             for(i = 1,len = v.length;i < len;i++)
              {if(wr >= sz)break;queue[wr++] = v[i]}
             break}
         else
          if(caml_is_ml_bytes(v))
           {h = caml_hash_mix_bytes(h,v);num--}
          else
           if(caml_is_ml_string(v))
            {h = caml_hash_mix_string(h,v);num--}
           else
            if(typeof v === "string")
             {h = caml_hash_mix_jsbytes(h,v);num--}
            else
             if(v === (v | 0))
              {h = caml_hash_mix_int(h,v + v + 1);num--}
             else
              if(v === + v){h = caml_hash_mix_float(h,v);num--}}
      h = caml_hash_mix_final(h);
      return h & 0x3FFFFFFF}
    function caml_hash_univ_param(count,limit,obj)
     {var hash_accu=0;
      function hash_aux(obj)
       {limit--;
        if(count < 0 || limit < 0)return;
        if(obj instanceof Array && obj[0] === (obj[0] | 0))
         switch(obj[0])
          {case 248:count--;hash_accu = hash_accu * 65599 + obj[2] | 0;break;
           case 250:limit++;hash_aux(obj);break;
           default:
            count--;
            hash_accu = hash_accu * 19 + obj[0] | 0;
            for(var i=obj.length - 1;i > 0;i--)hash_aux(obj[i])}
        else
         if(caml_is_ml_bytes(obj))
          {count--;
           switch(obj.t & 6)
            {default:caml_convert_string_to_bytes(obj);case 0:
              for(var b=obj.c,l=caml_ml_bytes_length(obj),i=0;i < l;i++)
               hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0;
              break;
             case 2:
              for(var a=obj.c,l=caml_ml_bytes_length(obj),i=0;i < l;i++)
               hash_accu = hash_accu * 19 + a[i] | 0
             }}
         else
          if(caml_is_ml_string(obj))
           {var jsbytes=caml_jsbytes_of_string(obj);
            for(var b=jsbytes,l=jsbytes.length,i=0;i < l;i++)
             hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0}
          else
           if(typeof obj === "string")
            for(var b=obj,l=obj.length,i=0;i < l;i++)
             hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0;
           else
            if(obj === (obj | 0))
             {count--;hash_accu = hash_accu * 65599 + obj | 0}
            else
             if(obj === + obj)
              {count--;
               var p=caml_int64_to_bytes(caml_int64_bits_of_float(obj));
               for(var i=7;i >= 0;i--)hash_accu = hash_accu * 19 + p[i] | 0}
             else
              if(obj && obj.caml_custom)
               if
                (caml_custom_ops[obj.caml_custom]
                 &&
                 caml_custom_ops[obj.caml_custom].hash)
                {var h=caml_custom_ops[obj.caml_custom].hash(obj) | 0;
                 hash_accu = hash_accu * 65599 + h | 0}}
      hash_aux(obj);
      return hash_accu & 0x3FFFFFFF}
    function caml_hexstring_of_float(x,prec,style)
     {if(! isFinite(x))
       {if(isNaN(x))return caml_string_of_jsstring("nan");
        return caml_string_of_jsstring(x > 0?"infinity":"-infinity")}
      var sign=x == 0 && 1 / x == - Infinity?1:x >= 0?0:1;
      if(sign)x = - x;
      var exp=0;
      if(x == 0)
       ;
      else
       if(x < 1)
        while(x < 1 && exp > - 1022){x *= 2;exp--}
       else
        while(x >= 2){x /= 2;exp++}
      var exp_sign=exp < 0?"":"+",sign_str="";
      if(sign)
       sign_str = "-";
      else
       switch(style)
        {case 43:sign_str = "+";break;
         case 32:sign_str = " ";break;
         default:break}
      if(prec >= 0 && prec < 13)
       {var cst=Math.pow(2,prec * 4);x = Math.round(x * cst) / cst}
      var x_str=x.toString(16);
      if(prec >= 0)
       {var idx=x_str.indexOf(".");
        if(idx < 0)
         x_str += "." + caml_str_repeat(prec,"0");
        else
         {var size=idx + 1 + prec;
          if(x_str.length < size)
           x_str += caml_str_repeat(size - x_str.length,"0");
          else
           x_str = x_str.substr(0,size)}}
      return caml_string_of_jsstring
              (sign_str + "0x" + x_str + "p" + exp_sign + exp.toString(10))}
    function caml_int64_add(x,y){return x.add(y)}
    function caml_int64_and(x,y){return x.and(y)}
    function caml_int64_is_zero(x){return + x.isZero()}
    function caml_int64_of_int32(x)
     {return new MlInt64(x & 0xffffff,x >> 24 & 0xffffff,x >> 31 & 0xffff)}
    function caml_int64_to_int32(x){return x.toInt()}
    function caml_int64_is_negative(x){return + x.isNeg()}
    function caml_int64_neg(x){return x.neg()}
    function caml_int64_format(fmt,x)
     {var f=caml_parse_format(fmt);
      if(f.signedconv && caml_int64_is_negative(x))
       {f.sign = - 1;x = caml_int64_neg(x)}
      var
       buffer="",
       wbase=caml_int64_of_int32(f.base),
       cvtbl="0123456789abcdef";
      do
       {var p=x.udivmod(wbase);
        x = p.quotient;
        buffer = cvtbl.charAt(caml_int64_to_int32(p.modulus)) + buffer}
      while
       (! caml_int64_is_zero(x));
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - buffer.length;
        if(n > 0)buffer = caml_str_repeat(n,"0") + buffer}
      return caml_finish_formatting(f,buffer)}
    function caml_int64_of_float(x)
     {if(x < 0)x = Math.ceil(x);
      return new
              MlInt64
              (x & 0xffffff,
               Math.floor(x * caml_int64_offset) & 0xffffff,
               Math.floor(x * caml_int64_offset * caml_int64_offset) & 0xffff)}
    function caml_int64_or(x,y){return x.or(y)}
    function caml_int64_shift_left(x,s){return x.shift_left(s)}
    function caml_int64_shift_right(x,s){return x.shift_right(s)}
    function caml_int64_sub(x,y){return x.sub(y)}
    function caml_int64_to_float(x){return x.toFloat()}
    function caml_parse_sign_and_base(s)
     {var i=0,len=caml_ml_string_length(s),base=10,sign=1;
      if(len > 0)
       switch(caml_string_unsafe_get(s,i))
        {case 45:i++;sign = - 1;break;case 43:i++;sign = 1;break}
      if(i + 1 < len && caml_string_unsafe_get(s,i) == 48)
       switch(caml_string_unsafe_get(s,i + 1))
        {case 120:
         case 88:base = 16;i += 2;break;
         case 111:
         case 79:base = 8;i += 2;break;
         case 98:
         case 66:base = 2;i += 2;break;
         case 117:
         case 85:i += 2;break
         }
      return [i,sign,base]}
    function caml_parse_digit(c)
     {if(c >= 48 && c <= 57)return c - 48;
      if(c >= 65 && c <= 90)return c - 55;
      if(c >= 97 && c <= 122)return c - 87;
      return - 1}
    function caml_int_of_string(s)
     {var
       r=caml_parse_sign_and_base(s),
       i=r[0],
       sign=r[1],
       base=r[2],
       len=caml_ml_string_length(s),
       threshold=- 1 >>> 0,
       c=i < len?caml_string_unsafe_get(s,i):0,
       d=caml_parse_digit(c);
      if(d < 0 || d >= base)caml_failwith("int_of_string");
      var res=d;
      for(i++;i < len;i++)
       {c = caml_string_unsafe_get(s,i);
        if(c == 95)continue;
        d = caml_parse_digit(c);
        if(d < 0 || d >= base)break;
        res = base * res + d;
        if(res > threshold)caml_failwith("int_of_string")}
      if(i != len)caml_failwith("int_of_string");
      res = sign * res;
      if(base == 10 && (res | 0) != res)caml_failwith("int_of_string");
      return res | 0}
    function caml_js_from_array(a){return a.slice(1)}
    function caml_js_wrap_callback(f)
     {return function()
       {var len=arguments.length;
        if(len > 0)
         {var args=new Array(len);
          for(var i=0;i < len;i++)args[i] = arguments[i];
          return caml_call_gen(f,args)}
        else
         return caml_call_gen(f,[undefined])}}
    function caml_ldexp_float(x,exp)
     {exp |= 0;
      if(exp > 1023)
       {exp -= 1023;
        x *= Math.pow(2,1023);
        if(exp > 1023){exp -= 1023;x *= Math.pow(2,1023)}}
      if(exp < - 1023){exp += 1023;x *= Math.pow(2,- 1023)}
      x *= Math.pow(2,exp);
      return x}
    function caml_lessequal(x,y){return + (caml_compare_val(x,y,false) <= 0)}
    function caml_lessthan(x,y){return + (caml_compare_val(x,y,false) < 0)}
    function caml_lex_array(s)
     {s = caml_jsbytes_of_string(s);
      var l=s.length / 2,a=new Array(l);
      for(var i=0;i < l;i++)
       a[i]
       =
       (s.charCodeAt(2 * i) | s.charCodeAt(2 * i + 1) << 8)
       <<
       16
       >>
       16;
      return a}
    function caml_lex_engine(tbl,start_state,lexbuf)
     {var
       lex_buffer=2,
       lex_buffer_len=3,
       lex_start_pos=5,
       lex_curr_pos=6,
       lex_last_pos=7,
       lex_last_action=8,
       lex_eof_reached=9,
       lex_base=1,
       lex_backtrk=2,
       lex_default=3,
       lex_trans=4,
       lex_check=5;
      if(! tbl.lex_default)
       {tbl.lex_base = caml_lex_array(tbl[lex_base]);
        tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
        tbl.lex_check = caml_lex_array(tbl[lex_check]);
        tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
        tbl.lex_default = caml_lex_array(tbl[lex_default])}
      var c,state=start_state,buffer=caml_array_of_bytes(lexbuf[lex_buffer]);
      if(state >= 0)
       {lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = - 1}
      else
       state = - state - 1;
      for(;;)
       {var base=tbl.lex_base[state];
        if(base < 0)return - base - 1;
        var backtrk=tbl.lex_backtrk[state];
        if(backtrk >= 0)
         {lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = backtrk}
        if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
         if(lexbuf[lex_eof_reached] == 0)return - state - 1;else c = 256;
        else
         {c = buffer[lexbuf[lex_curr_pos]];lexbuf[lex_curr_pos]++}
        if(tbl.lex_check[base + c] == state)
         state = tbl.lex_trans[base + c];
        else
         state = tbl.lex_default[state];
        if(state < 0)
         {lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
          if(lexbuf[lex_last_action] == - 1)
           caml_failwith("lexing: empty token");
          else
           return lexbuf[lex_last_action]}
        else
         if(c == 256)lexbuf[lex_eof_reached] = 0}}
    function caml_list_of_js_array(a)
     {var l=0;
      for(var i=a.length - 1;i >= 0;i--){var e=a[i];l = [0,e,l]}
      return l}
    function caml_make_vect(len,init)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 0;
      for(var i=1;i < len;i++)b[i] = init;
      return b}
    function caml_string_of_array(a)
     {return caml_string_of_jsbytes(caml_subarray_to_jsbytes(a,0,a.length))}
    var
     caml_md5_bytes=
      function()
        {function add(x,y){return x + y | 0}
         function xx(q,a,b,x,s,t)
          {a = add(add(a,q),add(x,t));return add(a << s | a >>> 32 - s,b)}
         function ff(a,b,c,d,x,s,t){return xx(b & c | ~ b & d,a,b,x,s,t)}
         function gg(a,b,c,d,x,s,t){return xx(b & d | c & ~ d,a,b,x,s,t)}
         function hh(a,b,c,d,x,s,t){return xx(b ^ c ^ d,a,b,x,s,t)}
         function ii(a,b,c,d,x,s,t){return xx(c ^ (b | ~ d),a,b,x,s,t)}
         function md5(buffer,length)
          {var i=length;
           buffer[i >> 2] |= 0x80 << 8 * (i & 3);
           for(i = (i & ~ 0x3) + 8;(i & 0x3F) < 60;i += 4)
            buffer[(i >> 2) - 1] = 0;
           buffer[(i >> 2) - 1] = length << 3;
           buffer[i >> 2] = length >> 29 & 0x1FFFFFFF;
           var w=[0x67452301,0xEFCDAB89,0x98BADCFE,0x10325476];
           for(i = 0;i < buffer.length;i += 16)
            {var a=w[0],b=w[1],c=w[2],d=w[3];
             a = ff(a,b,c,d,buffer[i + 0],7,0xD76AA478);
             d = ff(d,a,b,c,buffer[i + 1],12,0xE8C7B756);
             c = ff(c,d,a,b,buffer[i + 2],17,0x242070DB);
             b = ff(b,c,d,a,buffer[i + 3],22,0xC1BDCEEE);
             a = ff(a,b,c,d,buffer[i + 4],7,0xF57C0FAF);
             d = ff(d,a,b,c,buffer[i + 5],12,0x4787C62A);
             c = ff(c,d,a,b,buffer[i + 6],17,0xA8304613);
             b = ff(b,c,d,a,buffer[i + 7],22,0xFD469501);
             a = ff(a,b,c,d,buffer[i + 8],7,0x698098D8);
             d = ff(d,a,b,c,buffer[i + 9],12,0x8B44F7AF);
             c = ff(c,d,a,b,buffer[i + 10],17,0xFFFF5BB1);
             b = ff(b,c,d,a,buffer[i + 11],22,0x895CD7BE);
             a = ff(a,b,c,d,buffer[i + 12],7,0x6B901122);
             d = ff(d,a,b,c,buffer[i + 13],12,0xFD987193);
             c = ff(c,d,a,b,buffer[i + 14],17,0xA679438E);
             b = ff(b,c,d,a,buffer[i + 15],22,0x49B40821);
             a = gg(a,b,c,d,buffer[i + 1],5,0xF61E2562);
             d = gg(d,a,b,c,buffer[i + 6],9,0xC040B340);
             c = gg(c,d,a,b,buffer[i + 11],14,0x265E5A51);
             b = gg(b,c,d,a,buffer[i + 0],20,0xE9B6C7AA);
             a = gg(a,b,c,d,buffer[i + 5],5,0xD62F105D);
             d = gg(d,a,b,c,buffer[i + 10],9,0x02441453);
             c = gg(c,d,a,b,buffer[i + 15],14,0xD8A1E681);
             b = gg(b,c,d,a,buffer[i + 4],20,0xE7D3FBC8);
             a = gg(a,b,c,d,buffer[i + 9],5,0x21E1CDE6);
             d = gg(d,a,b,c,buffer[i + 14],9,0xC33707D6);
             c = gg(c,d,a,b,buffer[i + 3],14,0xF4D50D87);
             b = gg(b,c,d,a,buffer[i + 8],20,0x455A14ED);
             a = gg(a,b,c,d,buffer[i + 13],5,0xA9E3E905);
             d = gg(d,a,b,c,buffer[i + 2],9,0xFCEFA3F8);
             c = gg(c,d,a,b,buffer[i + 7],14,0x676F02D9);
             b = gg(b,c,d,a,buffer[i + 12],20,0x8D2A4C8A);
             a = hh(a,b,c,d,buffer[i + 5],4,0xFFFA3942);
             d = hh(d,a,b,c,buffer[i + 8],11,0x8771F681);
             c = hh(c,d,a,b,buffer[i + 11],16,0x6D9D6122);
             b = hh(b,c,d,a,buffer[i + 14],23,0xFDE5380C);
             a = hh(a,b,c,d,buffer[i + 1],4,0xA4BEEA44);
             d = hh(d,a,b,c,buffer[i + 4],11,0x4BDECFA9);
             c = hh(c,d,a,b,buffer[i + 7],16,0xF6BB4B60);
             b = hh(b,c,d,a,buffer[i + 10],23,0xBEBFBC70);
             a = hh(a,b,c,d,buffer[i + 13],4,0x289B7EC6);
             d = hh(d,a,b,c,buffer[i + 0],11,0xEAA127FA);
             c = hh(c,d,a,b,buffer[i + 3],16,0xD4EF3085);
             b = hh(b,c,d,a,buffer[i + 6],23,0x04881D05);
             a = hh(a,b,c,d,buffer[i + 9],4,0xD9D4D039);
             d = hh(d,a,b,c,buffer[i + 12],11,0xE6DB99E5);
             c = hh(c,d,a,b,buffer[i + 15],16,0x1FA27CF8);
             b = hh(b,c,d,a,buffer[i + 2],23,0xC4AC5665);
             a = ii(a,b,c,d,buffer[i + 0],6,0xF4292244);
             d = ii(d,a,b,c,buffer[i + 7],10,0x432AFF97);
             c = ii(c,d,a,b,buffer[i + 14],15,0xAB9423A7);
             b = ii(b,c,d,a,buffer[i + 5],21,0xFC93A039);
             a = ii(a,b,c,d,buffer[i + 12],6,0x655B59C3);
             d = ii(d,a,b,c,buffer[i + 3],10,0x8F0CCC92);
             c = ii(c,d,a,b,buffer[i + 10],15,0xFFEFF47D);
             b = ii(b,c,d,a,buffer[i + 1],21,0x85845DD1);
             a = ii(a,b,c,d,buffer[i + 8],6,0x6FA87E4F);
             d = ii(d,a,b,c,buffer[i + 15],10,0xFE2CE6E0);
             c = ii(c,d,a,b,buffer[i + 6],15,0xA3014314);
             b = ii(b,c,d,a,buffer[i + 13],21,0x4E0811A1);
             a = ii(a,b,c,d,buffer[i + 4],6,0xF7537E82);
             d = ii(d,a,b,c,buffer[i + 11],10,0xBD3AF235);
             c = ii(c,d,a,b,buffer[i + 2],15,0x2AD7D2BB);
             b = ii(b,c,d,a,buffer[i + 9],21,0xEB86D391);
             w[0] = add(a,w[0]);
             w[1] = add(b,w[1]);
             w[2] = add(c,w[2]);
             w[3] = add(d,w[3])}
           var t=new Array(16);
           for(var i=0;i < 4;i++)
            for(var j=0;j < 4;j++)t[i * 4 + j] = w[i] >> 8 * j & 0xFF;
           return t}
         return function(s,ofs,len)
          {var buf=[];
           switch(s.t & 6)
            {default:caml_convert_string_to_bytes(s);case 0:
              var b=s.c;
              for(var i=0;i < len;i += 4)
               {var j=i + ofs;
                buf[i >> 2]
                =
                b.charCodeAt(j)
                |
                b.charCodeAt(j + 1)
                <<
                8
                |
                b.charCodeAt(j + 2)
                <<
                16
                |
                b.charCodeAt(j + 3)
                <<
                24}
              for(;i < len;i++)
               buf[i >> 2] |= b.charCodeAt(i + ofs) << 8 * (i & 3);
              break;
             case 4:
              var a=s.c;
              for(var i=0;i < len;i += 4)
               {var j=i + ofs;
                buf[i >> 2]
                =
                a[j]
                |
                a[j + 1]
                <<
                8
                |
                a[j + 2]
                <<
                16
                |
                a[j + 3]
                <<
                24}
              for(;i < len;i++)buf[i >> 2] |= a[i + ofs] << 8 * (i & 3)
             }
           return caml_string_of_array(md5(buf,len))}}
       ();
    function caml_md5_string(s,ofs,len)
     {return caml_md5_bytes(caml_bytes_of_string(s),ofs,len)}
    function caml_sys_close(fd){delete caml_global_data.fds[fd];return 0}
    var caml_ml_channels=new Array();
    function caml_ml_flush(chanid)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)caml_raise_sys_error("Cannot flush a closed channel");
      if(! chan.buffer || chan.buffer == "")return 0;
      if
       (chan.fd
        &&
        caml_global_data.fds[chan.fd]
        &&
        caml_global_data.fds[chan.fd].output)
       {var output=caml_global_data.fds[chan.fd].output;
        switch(output.length)
         {case 2:output(chanid,chan.buffer);break;default:output(chan.buffer)}}
      chan.buffer = "";
      return 0}
    function caml_ml_close_channel(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_flush(chanid);
      chan.opened = false;
      chan.file.close();
      caml_sys_close(chan.fd);
      return 0}
    function caml_ml_refill_input(chan)
     {var str=chan.refill(),str_len=caml_ml_string_length(str);
      if(str_len == 0)chan.refill = null;
      chan.file.write(chan.file.length(),str,0,str_len);
      return str_len}
    function caml_ml_input(chanid,s,i,l)
     {var chan=caml_ml_channels[chanid],l2=chan.file.length() - chan.offset;
      if(l2 == 0 && chan.refill != null)l2 = caml_ml_refill_input(chan);
      if(l2 < l)l = l2;
      chan.file.read(chan.offset,s,i,l);
      chan.offset += l;
      return l}
    function caml_ml_may_refill_input(chanid)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill == null)return;
      if(chan.file.length() != chan.offset)return;
      caml_ml_refill_input(chan)}
    function caml_raise_end_of_file()
     {caml_raise_constant(caml_global_data.End_of_file)}
    function caml_ml_input_char(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_may_refill_input(chanid);
      if(chan.offset >= chan.file.length())caml_raise_end_of_file();
      var res=chan.file.read_one(chan.offset);
      chan.offset++;
      return res}
    function caml_ml_input_scan_line(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_may_refill_input(chanid);
      var p=chan.offset,len=chan.file.length();
      if(p >= len)return 0;
      while(true)
       {if(p >= len)return - (p - chan.offset);
        if(chan.file.read_one(p) == 10)return p - chan.offset + 1;
        p++}}
    function caml_std_output(chanid,s)
     {var
       chan=caml_ml_channels[chanid],
       str=caml_string_of_jsbytes(s),
       slen=caml_ml_string_length(str);
      chan.file.write(chan.offset,str,0,slen);
      chan.offset += slen;
      return 0}
    function js_print_stderr(s)
     {var s=caml_utf16_of_utf8(s),g=joo_global_object;
      if(g.process && g.process.stdout && g.process.stdout.write)
       g.process.stderr.write(s);
      else
       {if(s.charCodeAt(s.length - 1) == 10)s = s.substr(0,s.length - 1);
        var v=g.console;
        v && v.error && v.error(s)}}
    function js_print_stdout(s)
     {var s=caml_utf16_of_utf8(s),g=joo_global_object;
      if(g.process && g.process.stdout && g.process.stdout.write)
       g.process.stdout.write(s);
      else
       {if(s.charCodeAt(s.length - 1) == 10)s = s.substr(0,s.length - 1);
        var v=g.console;
        v && v.log && v.log(s)}}
    function caml_sys_open_internal(idx,output,file,flags)
     {if(caml_global_data.fds === undefined)
       caml_global_data.fds = new Array();
      flags = flags?flags:{};
      var info={};
      info.file = file;
      info.offset = flags.append?file.length():0;
      info.flags = flags;
      info.output = output;
      caml_global_data.fds[idx] = info;
      if(! caml_global_data.fd_last_idx || idx > caml_global_data.fd_last_idx)
       caml_global_data.fd_last_idx = idx;
      return idx}
    function caml_sys_open(name,flags,_perms)
     {var f={};
      while(flags)
       {switch(flags[1])
         {case 0:f.rdonly = 1;break;
          case 1:f.wronly = 1;break;
          case 2:f.append = 1;break;
          case 3:f.create = 1;break;
          case 4:f.truncate = 1;break;
          case 5:f.excl = 1;break;
          case 6:f.binary = 1;break;
          case 7:f.text = 1;break;
          case 8:f.nonblock = 1;break
          }
        flags = flags[2]}
      if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (caml_jsbytes_of_string(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (caml_jsbytes_of_string(name)
         +
         " : flags Open_text and Open_binary are not compatible");
      var
       root=resolve_fs_device(name),
       file=root.device.open(root.rest,f),
       idx=caml_global_data.fd_last_idx?caml_global_data.fd_last_idx:0;
      return caml_sys_open_internal(idx + 1,caml_std_output,file,f)}
    caml_sys_open_internal
     (0,caml_std_output,new MlFakeFile(caml_create_bytes(0)));
    caml_sys_open_internal
     (1,js_print_stdout,new MlFakeFile(caml_create_bytes(0)));
    caml_sys_open_internal
     (2,js_print_stderr,new MlFakeFile(caml_create_bytes(0)));
    function caml_ml_open_descriptor_in(fd)
     {var data=caml_global_data.fds[fd];
      if(data.flags.wronly)caml_raise_sys_error("fd " + fd + " is writeonly");
      var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:false,
         refill:null};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function caml_ml_open_descriptor_out(fd)
     {var data=caml_global_data.fds[fd];
      if(data.flags.rdonly)caml_raise_sys_error("fd " + fd + " is readonly");
      var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:true,
         buffer:""};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function caml_ml_out_channels_list()
     {var l=0;
      for(var c=0;c < caml_ml_channels.length;c++)
       if
        (caml_ml_channels[c]
         &&
         caml_ml_channels[c].opened
         &&
         caml_ml_channels[c].out)
        l = [0,caml_ml_channels[c].fd,l];
      return l}
    function caml_string_of_bytes(s){return s}
    function caml_ml_output_bytes(chanid,buffer,offset,len)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)
       caml_raise_sys_error("Cannot output to a closed channel");
      var bytes;
      if(offset == 0 && caml_ml_bytes_length(buffer) == len)
       bytes = buffer;
      else
       {bytes = caml_create_bytes(len);
        caml_blit_bytes(buffer,offset,bytes,0,len)}
      var
       string=caml_string_of_bytes(bytes),
       jsstring=caml_jsbytes_of_string(string),
       id=jsstring.lastIndexOf("\n");
      if(id < 0)
       chan.buffer += jsstring;
      else
       {chan.buffer += jsstring.substr(0,id + 1);
        caml_ml_flush(chanid);
        chan.buffer += jsstring.substr(id + 1)}
      return 0}
    function caml_ml_output(chanid,buffer,offset,len)
     {return caml_ml_output_bytes
              (chanid,caml_bytes_of_string(buffer),offset,len)}
    function caml_ml_output_char(chanid,c)
     {var s=caml_string_of_jsbytes(String.fromCharCode(c));
      caml_ml_output(chanid,s,0,1);
      return 0}
    function caml_ml_set_channel_name(){return 0}
    function caml_ml_set_channel_output(chanid,f)
     {var chan=caml_ml_channels[chanid];
      caml_global_data.fds[chan.fd].output = f;
      return 0}
    function caml_mod(x,y){if(y == 0)caml_raise_zero_divide();return x % y}
    function caml_notequal(x,y){return + (caml_compare_val(x,y,false) != 0)}
    function caml_obj_set_tag(x,tag){x[0] = tag;return 0}
    function caml_obj_tag(x)
     {if(x instanceof Array && x[0] == x[0] >>> 0)
       return x[0];
      else
       if(caml_is_ml_bytes(x))
        return 252;
       else
        if(caml_is_ml_string(x))
         return 252;
        else
         if(x instanceof Function || typeof x == "function")
          return 247;
         else
          if(x && x.caml_custom)return 255;else return 1000}
    var MlObjectTable;
    if(typeof joo_global_object.WeakMap === "undefined")
     MlObjectTable
     =
     function()
       {function NaiveLookup(objs){this.objs = objs}
        NaiveLookup.prototype.get
        =
        function(v)
         {for(var i=0;i < this.objs.length;i++)if(this.objs[i] === v)return i};
        NaiveLookup.prototype.set = function(){};
        return function()
         {this.objs = [];this.lookup = new NaiveLookup(this.objs)}}
      ();
    else
     MlObjectTable
     =
     function()
      {this.objs = [];this.lookup = new (joo_global_object.WeakMap)()};
    MlObjectTable.prototype.store
    =
    function(v){this.lookup.set(v,this.objs.length);this.objs.push(v)};
    MlObjectTable.prototype.recall
    =
    function(v)
     {var i=this.lookup.get(v);
      return i === undefined?undefined:this.objs.length - i};
    function caml_list_to_js_array(l)
     {var a=[];for(;l !== 0;l = l[2])a.push(l[1]);return a}
    var
     caml_legacy_custom_code=true,
     caml_output_val=
      function()
        {function Writer(){this.chunk = []}
         Writer.prototype
         =
         {chunk_idx:20,
          block_len:0,
          obj_counter:0,
          size_32:0,
          size_64:0,
          write:
          function(size,value)
           {for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 0xFF},
          write_at:
          function(pos,size,value)
           {var pos=pos;
            for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[pos++] = value >> i & 0xFF},
          write_code:
          function(size,code,value)
           {this.chunk[this.chunk_idx++] = code;
            for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 0xFF},
          write_shared:
          function(offset)
           {if(offset < 1 << 8)
             this.write_code(8,0x04,offset);
            else
             if(offset < 1 << 16)
              this.write_code(16,0x05,offset);
             else
              this.write_code(32,0x06,offset)},
          pos:function(){return this.chunk_idx},
          finalize:
          function()
           {this.block_len = this.chunk_idx - 20;
            this.chunk_idx = 0;
            this.write(32,0x8495A6BE);
            this.write(32,this.block_len);
            this.write(32,this.obj_counter);
            this.write(32,this.size_32);
            this.write(32,this.size_64);
            return this.chunk}};
         return function(v,flags)
          {flags = caml_list_to_js_array(flags);
           var
            no_sharing=flags.indexOf(0) !== - 1,
            closures=flags.indexOf(1) !== - 1;
           if(closures)
            joo_global_object.console.warn
             ("in caml_output_val: flag Marshal.Closures is not supported.");
           var
            writer=new Writer(),
            stack=[],
            intern_obj_table=no_sharing?null:new MlObjectTable();
           function memo(v)
            {if(no_sharing)return false;
             var existing_offset=intern_obj_table.recall(v);
             if(existing_offset)
              {writer.write_shared(existing_offset);return true}
             else
              {intern_obj_table.store(v);return false}}
           function extern_rec(v)
            {if(v.caml_custom)
              {if(memo(v))return;
               var
                name=v.caml_custom,
                ops=caml_custom_ops[name],
                sz_32_64=[0,0];
               if(! ops.serialize)
                caml_invalid_argument("output_value: abstract value (Custom)");
               if(caml_legacy_custom_code)
                {writer.write(8,0x12);
                 for(var i=0;i < name.length;i++)
                  writer.write(8,name.charCodeAt(i));
                 writer.write(8,0);
                 ops.serialize(writer,v,sz_32_64)}
               else
                if(ops.fixed_length == undefined)
                 {writer.write(8,0x18);
                  for(var i=0;i < name.length;i++)
                   writer.write(8,name.charCodeAt(i));
                  writer.write(8,0);
                  var header_pos=writer.pos();
                  for(var i=0;i < 12;i++)writer.write(8,0);
                  ops.serialize(writer,v,sz_32_64);
                  writer.write_at(header_pos,32,sz_32_64[0]);
                  writer.write_at(header_pos + 4,32,0);
                  writer.write_at(header_pos + 8,32,sz_32_64[1])}
                else
                 {writer.write(8,0x19);
                  for(var i=0;i < name.length;i++)
                   writer.write(8,name.charCodeAt(i));
                  writer.write(8,0);
                  var old_pos=writer.pos();
                  ops.serialize(writer,v,sz_32_64);
                  if(ops.fixed_length != writer.pos() - old_pos)
                   caml_failwith
                    ("output_value: incorrect fixed sizes specified by " + name)}
               writer.size_32 += 2 + (sz_32_64[0] + 3 >> 2);
               writer.size_64 += 2 + (sz_32_64[1] + 7 >> 3)}
             else
              if(v instanceof Array && v[0] === (v[0] | 0))
               {if(v[0] == 251)
                 caml_failwith("output_value: abstract value (Abstract)");
                if(v.length > 1 && memo(v))return;
                if(v[0] < 16 && v.length - 1 < 8)
                 writer.write(8,0x80 + v[0] + (v.length - 1 << 4));
                else
                 writer.write_code(32,0x08,v.length - 1 << 10 | v[0]);
                writer.size_32 += v.length;
                writer.size_64 += v.length;
                if(v.length > 1)stack.push(v,1)}
              else
               if(caml_is_ml_bytes(v))
                {if(! caml_is_ml_bytes(caml_string_of_jsbytes("")))
                  caml_failwith
                   ("output_value: [Bytes.t] cannot safely be marshaled with [--enable use-js-string]");
                 if(memo(v))return;
                 var len=caml_ml_bytes_length(v);
                 if(len < 0x20)
                  writer.write(8,0x20 + len);
                 else
                  if(len < 0x100)
                   writer.write_code(8,0x09,len);
                  else
                   writer.write_code(32,0x0A,len);
                 for(var i=0;i < len;i++)
                  writer.write(8,caml_bytes_unsafe_get(v,i));
                 writer.size_32 += 1 + ((len + 4) / 4 | 0);
                 writer.size_64 += 1 + ((len + 8) / 8 | 0)}
               else
                if(caml_is_ml_string(v))
                 {var len=caml_ml_string_length(v);
                  if(len < 0x20)
                   writer.write(8,0x20 + len);
                  else
                   if(len < 0x100)
                    writer.write_code(8,0x09,len);
                   else
                    writer.write_code(32,0x0A,len);
                  for(var i=0;i < len;i++)
                   writer.write(8,caml_string_unsafe_get(v,i));
                  writer.size_32 += 1 + ((len + 4) / 4 | 0);
                  writer.size_64 += 1 + ((len + 8) / 8 | 0)}
                else
                 if(v != (v | 0))
                  {var type_of_v=typeof v;
                   caml_failwith
                    ("output_value: abstract value (" + type_of_v + ")")}
                 else
                  if(v >= 0 && v < 0x40)
                   writer.write(8,0X40 + v);
                  else
                   if(v >= - (1 << 7) && v < 1 << 7)
                    writer.write_code(8,0x00,v);
                   else
                    if(v >= - (1 << 15) && v < 1 << 15)
                     writer.write_code(16,0x01,v);
                    else
                     writer.write_code(32,0x02,v)}
           extern_rec(v);
           while(stack.length > 0)
            {var i=stack.pop(),v=stack.pop();
             if(i + 1 < v.length)stack.push(v,i + 1);
             extern_rec(v[i])}
           if(intern_obj_table)
            writer.obj_counter = intern_obj_table.objs.length;
           writer.finalize();
           return writer.chunk}}
       ();
    function caml_output_value_to_string(v,flags)
     {return caml_string_of_array(caml_output_val(v,flags))}
    function caml_output_value(chanid,v,flags)
     {var s=caml_output_value_to_string(v,flags);
      caml_ml_output(chanid,s,0,caml_ml_string_length(s));
      return 0}
    function caml_parse_engine(tables,env,cmd,arg)
     {var
       ERRCODE=256,
       loop=6,
       testshift=7,
       shift=8,
       shift_recover=9,
       reduce=10,
       READ_TOKEN=0,
       RAISE_PARSE_ERROR=1,
       GROW_STACKS_1=2,
       GROW_STACKS_2=3,
       COMPUTE_SEMANTIC_ACTION=4,
       CALL_ERROR_FUNCTION=5,
       env_s_stack=1,
       env_v_stack=2,
       env_symb_start_stack=3,
       env_symb_end_stack=4,
       env_stacksize=5,
       env_stackbase=6,
       env_curr_char=7,
       env_lval=8,
       env_symb_start=9,
       env_symb_end=10,
       env_asp=11,
       env_rule_len=12,
       env_rule_number=13,
       env_sp=14,
       env_state=15,
       env_errflag=16,
       tbl_transl_const=2,
       tbl_transl_block=3,
       tbl_lhs=4,
       tbl_len=5,
       tbl_defred=6,
       tbl_dgoto=7,
       tbl_sindex=8,
       tbl_rindex=9,
       tbl_gindex=10,
       tbl_tablesize=11,
       tbl_table=12,
       tbl_check=13;
      if(! tables.dgoto)
       {tables.defred = caml_lex_array(tables[tbl_defred]);
        tables.sindex = caml_lex_array(tables[tbl_sindex]);
        tables.check = caml_lex_array(tables[tbl_check]);
        tables.rindex = caml_lex_array(tables[tbl_rindex]);
        tables.table = caml_lex_array(tables[tbl_table]);
        tables.len = caml_lex_array(tables[tbl_len]);
        tables.lhs = caml_lex_array(tables[tbl_lhs]);
        tables.gindex = caml_lex_array(tables[tbl_gindex]);
        tables.dgoto = caml_lex_array(tables[tbl_dgoto])}
      var
       res=0,
       n,
       n1,
       n2,
       state1,
       sp=env[env_sp],
       state=env[env_state],
       errflag=env[env_errflag];
      exit:
      for(;;)
       switch(cmd)
        {case 0:state = 0;errflag = 0;
         case 6:
          n = tables.defred[state];
          if(n != 0){cmd = reduce;break}
          if(env[env_curr_char] >= 0){cmd = testshift;break}
          res = READ_TOKEN;
          break exit;
         case 1:
          if(arg instanceof Array)
           {env[env_curr_char] = tables[tbl_transl_block][arg[0] + 1];
            env[env_lval] = arg[1]}
          else
           {env[env_curr_char] = tables[tbl_transl_const][arg + 1];
            env[env_lval] = 0}
         case 7:
          n1 = tables.sindex[state];
          n2 = n1 + env[env_curr_char];
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char])
           {cmd = shift;break}
          n1 = tables.rindex[state];
          n2 = n1 + env[env_curr_char];
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char])
           {n = tables.table[n2];cmd = reduce;break}
          if(errflag <= 0){res = CALL_ERROR_FUNCTION;break exit}
         case 5:
          if(errflag < 3)
           {errflag = 3;
            for(;;)
             {state1 = env[env_s_stack][sp + 1];
              n1 = tables.sindex[state1];
              n2 = n1 + ERRCODE;
              if
               (n1
                !=
                0
                &&
                n2
                >=
                0
                &&
                n2
                <=
                tables[tbl_tablesize]
                &&
                tables.check[n2]
                ==
                ERRCODE)
               {cmd = shift_recover;break}
              else
               {if(sp <= env[env_stackbase])return RAISE_PARSE_ERROR;sp--}}}
          else
           {if(env[env_curr_char] == 0)return RAISE_PARSE_ERROR;
            env[env_curr_char] = - 1;
            cmd = loop;
            break}
         case 8:env[env_curr_char] = - 1;if(errflag > 0)errflag--;
         case 9:
          state = tables.table[n2];
          sp++;
          if(sp >= env[env_stacksize]){res = GROW_STACKS_1;break exit}
         case 2:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = env[env_lval];
          env[env_symb_start_stack][sp + 1] = env[env_symb_start];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end];
          cmd = loop;
          break;
         case 10:
          var m=tables.len[n];
          env[env_asp] = sp;
          env[env_rule_number] = n;
          env[env_rule_len] = m;
          sp = sp - m + 1;
          m = tables.lhs[n];
          state1 = env[env_s_stack][sp];
          n1 = tables.gindex[m];
          n2 = n1 + state1;
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            state1)
           state = tables.table[n2];
          else
           state = tables.dgoto[m];
          if(sp >= env[env_stacksize]){res = GROW_STACKS_2;break exit}
         case 3:res = COMPUTE_SEMANTIC_ACTION;break exit;
         case 4:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = arg;
          var asp=env[env_asp];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end_stack][asp + 1];
          if(sp > asp)
           env[env_symb_start_stack][sp + 1]
           =
           env[env_symb_end_stack][asp + 1];
          cmd = loop;
          break;
         default:return RAISE_PARSE_ERROR}
      env[env_sp] = sp;
      env[env_state] = state;
      env[env_errflag] = errflag;
      return res}
    function caml_register_global(n,v,name_opt)
     {if(name_opt && joo_global_object.toplevelReloc)
       n = joo_global_object.toplevelReloc(name_opt);
      caml_global_data[n + 1] = v;
      if(name_opt)caml_global_data[name_opt] = v}
    var caml_named_values={};
    function caml_register_named_value(nm,v)
     {caml_named_values[caml_jsbytes_of_string(nm)] = v;return 0}
    function caml_sinh_float(x){return (Math.exp(x) - Math.exp(- x)) / 2}
    function caml_string_equal(s1,s2){return caml_bytes_equal(s1,s2)}
    function caml_string_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_string_get(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s))caml_string_bound_error();
      return caml_string_unsafe_get(s,i)}
    function caml_string_notequal(s1,s2){return 1 - caml_string_equal(s1,s2)}
    function caml_sys_const_backend_type()
     {return [0,caml_string_of_jsbytes("js_of_ocaml")]}
    function caml_sys_const_max_wosize(){return 0x7FFFFFFF / 4 | 0}
    function caml_sys_exit(code)
     {var g=joo_global_object;
      if(g.quit)g.quit(code);
      if(g.process && g.process.exit)g.process.exit(code);
      caml_invalid_argument("Function 'exit' not implemented")}
    function caml_sys_file_exists(name)
     {var root=resolve_fs_device(name);return root.device.exists(root.rest)}
    var
     caml_argv=
      function()
        {var g=joo_global_object,main="a.out",args=[];
         if(g.process && g.process.argv && g.process.argv.length > 1)
          {var argv=g.process.argv;main = argv[1];args = argv.slice(2)}
         var p=caml_string_of_jsstring(main),args2=[0,p];
         for(var i=0;i < args.length;i++)
          args2.push(caml_string_of_jsstring(args[i]));
         return args2}
       ();
    function caml_sys_get_argv(a){return [0,caml_argv[1],caml_argv]}
    function caml_sys_get_config()
     {return [0,caml_string_of_jsbytes("Unix"),32,0]}
    function caml_raise_not_found()
     {caml_raise_constant(caml_global_data.Not_found)}
    function caml_sys_getenv(name)
     {var g=joo_global_object,n=caml_jsstring_of_string(name);
      if(g.process && g.process.env && g.process.env[n] != undefined)
       return caml_string_of_jsstring(g.process.env[n]);
      if
       (joo_global_object.jsoo_static_env
        &&
        joo_global_object.jsoo_static_env[n])
       return caml_string_of_jsstring(joo_global_object.jsoo_static_env[n]);
      caml_raise_not_found()}
    function caml_sys_is_directory(name)
     {var root=resolve_fs_device(name),a=root.device.is_dir(root.rest);
      return a?1:0}
    function caml_sys_random_seed()
     {var now=new Date().getTime(),x=now ^ 0xffffffff * Math.random();
      return [0,x]}
    function caml_sys_remove(name)
     {var root=resolve_fs_device(name),ok=root.device.unlink(root.rest);
      if(ok == 0)caml_raise_no_such_file(name);
      return 0}
    function caml_sys_system_command(cmd)
     {var cmd=caml_jsstring_of_string(cmd);
      if
       (typeof require
        !=
        "undefined"
        &&
        require("child_process")
        &&
        require("child_process").execSync)
       try
        {require("child_process").execSync(cmd,{stdio:"inherit"});return 0}
       catch(e){return 1}
      else
       return 127}
    function caml_tanh_float(x)
     {var y=Math.exp(x),z=Math.exp(- x);return (y - z) / (y + z)}
    function caml_trampoline(res)
     {var c=1;
      while(res && res.joo_tramp)
       {res = res.joo_tramp.apply(null,res.joo_args);c++}
      return res}
    function caml_trampoline_return(f,args)
     {return {joo_tramp:f,joo_args:args}}
    function caml_return_exn_constant(tag){return tag}
    function caml_named_value(nm){return caml_named_values[nm]}
    function caml_wrap_exception(e)
     {if(e instanceof Array)return e;
      if
       (joo_global_object.RangeError
        &&
        e instanceof joo_global_object.RangeError
        &&
        e.message
        &&
        e.message.match(/maximum call stack/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if
       (joo_global_object.InternalError
        &&
        e instanceof joo_global_object.InternalError
        &&
        e.message
        &&
        e.message.match(/too much recursion/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if(e instanceof joo_global_object.Error && caml_named_value("jsError"))
       return [0,caml_named_value("jsError"),e];
      return [0,caml_global_data.Failure,caml_string_of_jsstring(String(e))]}
    function num_digits_nat(nat,ofs,len)
     {for(var i=len - 1;i >= 0;i--)if(nat.data[ofs + i] != 0)return i + 1;
      return 1}
    function compare_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {var a=num_digits_nat(nat1,ofs1,len1),b=num_digits_nat(nat2,ofs2,len2);
      if(a > b)return 1;
      if(a < b)return - 1;
      for(var i=len1 - 1;i >= 0;i--)
       {if(nat1.data[ofs1 + i] >>> 0 > nat2.data[ofs2 + i] >>> 0)return 1;
        if(nat1.data[ofs1 + i] >>> 0 < nat2.data[ofs2 + i] >>> 0)return - 1}
      return 0}
    function MlNat(x)
     {this.data = new (joo_global_object.Int32Array)(x);
      this.length = this.data.length + 2}
    MlNat.prototype.caml_custom = "_nat";
    function create_nat(size)
     {var arr=new MlNat(size);
      for(var i=0;i < size;i++)arr.data[i] = - 1;
      return arr}
    function decr_nat(nat,ofs,len,carry_in)
     {var borrow=carry_in == 1?0:1;
      for(var i=0;i < len;i++)
       {var x=(nat.data[ofs + i] >>> 0) - borrow;
        nat.data[ofs + i] = x;
        if(x >= 0){borrow = 0;break}else borrow = 1}
      return borrow == 1?0:1}
    function div_helper(a,b,c)
     {var
       x=a * 65536 + (b >>> 16),
       y=Math.floor(x / c) * 65536,
       z=x % c * 65536,
       w=z + (b & 0x0000FFFF);
      return [y + Math.floor(w / c),w % c]}
    function div_digit_nat(natq,ofsq,natr,ofsr,nat1,ofs1,len,nat2,ofs2)
     {var rem=nat1.data[ofs1 + len - 1] >>> 0;
      for(var i=len - 2;i >= 0;i--)
       {var x=div_helper(rem,nat1.data[ofs1 + i] >>> 0,nat2.data[ofs2] >>> 0);
        natq.data[ofsq + i] = x[0];
        rem = x[1]}
      natr.data[ofsr] = rem;
      return 0}
    function num_leading_zero_bits_in_digit(nat,ofs)
     {var a=nat.data[ofs],b=0;
      if(a & 0xFFFF0000){b += 16;a >>>= 16}
      if(a & 0xFF00){b += 8;a >>>= 8}
      if(a & 0xF0){b += 4;a >>>= 4}
      if(a & 12){b += 2;a >>>= 2}
      if(a & 2){b += 1;a >>>= 1}
      if(a & 1)b += 1;
      return 32 - b}
    function shift_left_nat(nat1,ofs1,len1,nat2,ofs2,nbits)
     {if(nbits == 0){nat2.data[ofs2] = 0;return 0}
      var wrap=0;
      for(var i=0;i < len1;i++)
       {var a=nat1.data[ofs1 + i] >>> 0;
        nat1.data[ofs1 + i] = a << nbits | wrap;
        wrap = a >>> 32 - nbits}
      nat2.data[ofs2] = wrap;
      return 0}
    function shift_right_nat(nat1,ofs1,len1,nat2,ofs2,nbits)
     {if(nbits == 0){nat2.data[ofs2] = 0;return 0}
      var wrap=0;
      for(var i=len1 - 1;i >= 0;i--)
       {var a=nat1.data[ofs1 + i] >>> 0;
        nat1.data[ofs1 + i] = a >>> nbits | wrap;
        wrap = a << 32 - nbits}
      nat2.data[ofs2] = wrap;
      return 0}
    function set_to_zero_nat(nat,ofs,len)
     {for(var i=0;i < len;i++)nat.data[ofs + i] = 0;return 0}
    function nat_of_array(l){return new MlNat(l)}
    function mult_digit_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat3,ofs3)
     {var carry=0,a=nat3.data[ofs3] >>> 0;
      for(var i=0;i < len2;i++)
       {var
         x1=
          (nat1.data[ofs1 + i] >>> 0)
          +
          (nat2.data[ofs2 + i] >>> 0)
          *
          (a & 0x0000FFFF)
          +
          carry,
         x2=(nat2.data[ofs2 + i] >>> 0) * (a >>> 16);
        carry = Math.floor(x2 / 65536);
        var x3=x1 + x2 % 65536 * 65536;
        nat1.data[ofs1 + i] = x3;
        carry += Math.floor(x3 / 4294967296)}
      return len2 < len1 && carry
              ?add_nat
                (nat1,ofs1 + len2,len1 - len2,nat_of_array([carry]),0,1,0)
              :carry}
    function sub_nat(nat1,ofs1,len1,nat2,ofs2,len2,carry_in)
     {var borrow=carry_in == 1?0:1;
      for(var i=0;i < len2;i++)
       {var
         x=
          (nat1.data[ofs1 + i] >>> 0) - (nat2.data[ofs2 + i] >>> 0) - borrow;
        nat1.data[ofs1 + i] = x;
        if(x >= 0)borrow = 0;else borrow = 1}
      return decr_nat(nat1,ofs1 + len2,len1 - len2,borrow == 1?0:1)}
    function div_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {if(len2 == 1)
       {div_digit_nat(nat1,ofs1 + 1,nat1,ofs1,nat1,ofs1,len1,nat2,ofs2);
        return 0}
      var s=num_leading_zero_bits_in_digit(nat2,ofs2 + len2 - 1);
      shift_left_nat(nat2,ofs2,len2,nat_of_array([0]),0,s);
      shift_left_nat(nat1,ofs1,len1,nat_of_array([0]),0,s);
      var d=(nat2.data[ofs2 + len2 - 1] >>> 0) + 1,a=create_nat(len2 + 1);
      for(var i=len1 - 1;i >= len2;i--)
       {var
         quo=
          d == 4294967296
           ?nat1.data[ofs1 + i] >>> 0
           :div_helper
              (nat1.data[ofs1 + i] >>> 0,nat1.data[ofs1 + i - 1] >>> 0,d)
             [0];
        set_to_zero_nat(a,0,len2 + 1);
        mult_digit_nat(a,0,len2 + 1,nat2,ofs2,len2,nat_of_array([quo]),0);
        sub_nat(nat1,ofs1 + i - len2,len2 + 1,a,0,len2 + 1,1);
        while
         (nat1.data[ofs1 + i]
          !=
          0
          ||
          compare_nat(nat1,ofs1 + i - len2,len2,nat2,ofs2,len2)
          >=
          0)
         {quo = quo + 1;
          sub_nat(nat1,ofs1 + i - len2,len2 + 1,nat2,ofs2,len2,1)}
        nat1.data[ofs1 + i] = quo}
      shift_right_nat(nat1,ofs1,len2,nat_of_array([0]),0,s);
      shift_right_nat(nat2,ofs2,len2,nat_of_array([0]),0,s);
      return 0}
    function serialize_nat(writer,nat,sz)
     {var len=nat.data.length;
      writer.write(32,len);
      for(var i=0;i < len;i++)writer.write(32,nat.data[i]);
      sz[0] = len * 4;
      sz[1] = len * 8}
    function deserialize_nat(reader,sz)
     {var len=reader.read32s(),nat=new MlNat(len);
      for(var i=0;i < len;i++)nat.data[i] = reader.read32s();
      sz[0] = len * 4;
      return nat}
    function caml_hash_nat(x)
     {var len=num_digits_nat(x,0,x.data.length),h=0;
      for(var i=0;i < len;i++)h = caml_hash_mix_int(h,x.data[i]);
      return h}
    function initialize_nat()
     {caml_custom_ops["_nat"]
      =
      {deserialize:deserialize_nat,serialize:serialize_nat,hash:caml_hash_nat}}
    function is_digit_int(nat,ofs){if(nat.data[ofs] >= 0)return 1;return 0}
    function is_digit_odd(nat,ofs){if(nat.data[ofs] & 1)return 1;return 0}
    function is_digit_zero(nat,ofs){if(nat.data[ofs] == 0)return 1;return 0}
    function land_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] &= nat2.data[ofs2];return 0}
    function mult_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat3,ofs3,len3)
     {var carry=0;
      for(var i=0;i < len3;i++)
       carry
       +=
       mult_digit_nat(nat1,ofs1 + i,len1 - i,nat2,ofs2,len2,nat3,ofs3 + i);
      return carry}
    function nth_digit_nat(nat,ofs){return nat.data[ofs]}
    function nth_digit_nat_native(nat,ofs){return nat.data[ofs]}
    function re_replacement_text(repl,groups,orig)
     {var
       repl=caml_jsbytes_of_string(repl),
       len=repl.length,
       orig=caml_jsbytes_of_string(orig),
       res="",
       n=0,
       cur,
       start,
       end,
       c;
      while(n < len)
       {cur = repl.charAt(n++);
        if(cur != "\\")
         res += cur;
        else
         {if(n == len)
           caml_failwith("Str.replace: illegal backslash sequence");
          cur = repl.charAt(n++);
          switch(cur)
           {case "\\":res += cur;break;
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
             c = + cur;
             if(c * 2 >= groups.length - 1)
              caml_failwith("Str.replace: reference to unmatched group");
             start = caml_array_get(groups,c * 2);
             end = caml_array_get(groups,c * 2 + 1);
             if(start == - 1)
              caml_failwith("Str.replace: reference to unmatched group");
             res += orig.slice(start,end);
             break;
            default:res += "\\" + cur}}}
      return caml_string_of_jsbytes(res)}
    var
     re_match=
      function()
        {var
          re_word_letters=
           [0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0x03,
            0xFE,
            0xFF,
            0xFF,
            0x87,
            0xFE,
            0xFF,
            0xFF,
            0x07,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0xFF,
            0x7F,
            0xFF,
            0xFF,
            0xFF,
            0x7F,
            0xFF],
          opcodes=
           {CHAR:0,
            CHARNORM:1,
            STRING:2,
            STRINGNORM:3,
            CHARCLASS:4,
            BOL:5,
            EOL:6,
            WORDBOUNDARY:7,
            BEGGROUP:8,
            ENDGROUP:9,
            REFGROUP:10,
            ACCEPT:11,
            SIMPLEOPT:12,
            SIMPLESTAR:13,
            SIMPLEPLUS:14,
            GOTO:15,
            PUSHBACK:16,
            SETMARK:17,
            CHECKPROGRESS:18};
         function is_word_letter(c)
          {return re_word_letters[c >> 3] >> (c & 7) & 1}
         function in_bitset(s,i)
          {return caml_string_get(s,i >> 3) >> (i & 7) & 1}
         function re_match_impl(re,s,pos,partial)
          {var
            prog=caml_js_from_array(re[1]),
            cpool=caml_js_from_array(re[2]),
            normtable=caml_jsbytes_of_string(re[3]),
            numgroups=re[4] | 0,
            numregisters=re[5] | 0,
            startchars=re[6] | 0,
            s=caml_array_of_string(s),
            pc=0,
            quit=false,
            stack=[],
            groups=new Array(numgroups),
            re_register=new Array(numregisters);
           for(var i=0;i < groups.length;i++)groups[i] = {start:- 1,end:- 1};
           groups[0].start = pos;
           function backtrack()
            {while(stack.length)
              {var item=stack.pop();
               if(item.undo)
                item.undo.obj[item.undo.prop] = item.undo.value;
               else
                if(item.pos){pc = item.pos.pc;pos = item.pos.txt;return}}
             quit = true}
           function push(item){stack.push(item)}
           function accept()
            {groups[0].end = pos;
             var result=new Array(1 + groups.length * 2);
             result[0] = 0;
             for(var i=0;i < groups.length;i++)
              {var g=groups[i];
               if(g.start < 0 || g.end < 0)g.start = g.end = - 1;
               result[2 * i + 1] = g.start;
               result[2 * i + 1 + 1] = g.end}
             return result}
           function prefix_match()
            {if(partial)return accept();else backtrack()}
           while(! quit)
            {var
              op=prog[pc] & 0xff,
              sarg=prog[pc] >> 8,
              uarg=sarg & 0xff,
              c=s[pos],
              group;
             pc++;
             switch(op)
              {case opcodes.CHAR:
                if(pos === s.length){prefix_match();break}
                if(c === uarg)pos++;else backtrack();
                break;
               case opcodes.CHARNORM:
                if(pos === s.length){prefix_match();break}
                if(normtable.charCodeAt(c) === uarg)pos++;else backtrack();
                break;
               case opcodes.STRING:
                for
                 (var arg=caml_jsbytes_of_string(cpool[uarg]),i=0;
                  i
                  <
                  arg.length;
                  i++)
                 {if(pos === s.length){prefix_match();break}
                  if(c === arg.charCodeAt(i))
                   c = s[++pos];
                  else
                   {backtrack();break}}
                break;
               case opcodes.STRINGNORM:
                for
                 (var arg=caml_jsbytes_of_string(cpool[uarg]),i=0;
                  i
                  <
                  arg.length;
                  i++)
                 {if(pos === s.length){prefix_match();break}
                  if(normtable.charCodeAt(c) === arg.charCodeAt(i))
                   c = s[++pos];
                  else
                   {backtrack();break}}
                break;
               case opcodes.CHARCLASS:
                if(pos === s.length){prefix_match();break}
                if(in_bitset(cpool[uarg],c))pos++;else backtrack();
                break;
               case opcodes.BOL:
                if(pos > 0 && s[pos - 1] != 10)backtrack();break;
               case opcodes.EOL:
                if(pos < s.length && s[pos] != 10)backtrack();break;
               case opcodes.WORDBOUNDARY:
                if(pos == 0)
                 {if(pos === s.length){prefix_match();break}
                  if(is_word_letter(s[0]))break;
                  backtrack()}
                else
                 if(pos === s.length)
                  {if(is_word_letter(s[pos - 1]))break;backtrack()}
                 else
                  {if(is_word_letter(s[pos - 1]) != is_word_letter(s[pos]))
                    break;
                   backtrack()}
                break;
               case opcodes.BEGGROUP:
                group = groups[uarg];
                push({undo:{obj:group,prop:"start",value:group.start}});
                group.start = pos;
                break;
               case opcodes.ENDGROUP:
                group = groups[uarg];
                push({undo:{obj:group,prop:"end",value:group.end}});
                group.end = pos;
                break;
               case opcodes.REFGROUP:
                group = groups[uarg];
                if(group.start < 0 || group.end < 0){backtrack();break}
                for(var i=group.start;i < group.end;i++)
                 {if(pos === s.length){prefix_match();break}
                  if(s[i] != s[pos]){backtrack();break}
                  pos++}
                break;
               case opcodes.SIMPLEOPT:if(in_bitset(cpool[uarg],c))pos++;break;
               case opcodes.SIMPLESTAR:
                while(in_bitset(cpool[uarg],c))c = s[++pos];break;
               case opcodes.SIMPLEPLUS:
                if(pos === s.length){prefix_match();break}
                if(in_bitset(cpool[uarg],c))
                 do c = s[++pos];while(in_bitset(cpool[uarg],c));
                else
                 backtrack();
                break;
               case opcodes.ACCEPT:return accept();
               case opcodes.GOTO:pc = pc + sarg;break;
               case opcodes.PUSHBACK:push({pos:{pc:pc + sarg,txt:pos}});break;
               case opcodes.SETMARK:
                push
                 ({undo:{obj:re_register,prop:uarg,value:re_register[uarg]}});
                re_register[uarg] = pos;
                break;
               case opcodes.CHECKPROGRESS:
                if(re_register[uarg] === pos)backtrack();break;
               default:throw new Error("Invalid bytecode")}}
           return 0}
         return re_match_impl}
       ();
    function re_search_forward(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.search_forward");
      while(pos <= caml_ml_string_length(s))
       {var res=re_match(re,s,pos,0);if(res)return res;pos++}
      return [0]}
    function re_string_match(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.string_match");
      var res=re_match(re,s,pos,0);
      return res?res:[0]}
    function set_digit_nat(nat,ofs,digit){nat.data[ofs] = digit;return 0}
    function set_digit_nat_native(nat,ofs,digit)
     {nat.data[ofs] = digit;return 0}
    function square_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {var carry=0;
      carry += add_nat(nat1,ofs1,len1,nat1,ofs1,len1,0);
      carry += mult_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat2,ofs2,len2);
      return carry}
    function unix_gettimeofday(){return new Date().getTime() / 1000}
    function unix_inet_addr_of_string(){return 0}
    function unix_localtime(t)
     {var
       d=new Date(t * 1000),
       d_num=d.getTime(),
       januaryfirst=new Date(d.getFullYear(),0,1).getTime(),
       doy=Math.floor((d_num - januaryfirst) / 86400000),
       jan=new Date(d.getFullYear(),0,1),
       jul=new Date(d.getFullYear(),6,1),
       stdTimezoneOffset=
        Math.max(jan.getTimezoneOffset(),jul.getTimezoneOffset());
      return [0,
              d.getSeconds(),
              d.getMinutes(),
              d.getHours(),
              d.getDate(),
              d.getMonth(),
              d.getFullYear() - 1900,
              d.getDay(),
              doy,
              d.getTimezoneOffset() < stdTimezoneOffset | 0]}
    function unix_time(){return Math.floor(unix_gettimeofday())}
    var
     unix_waitpid=
      joo_global_object.unix_waitpid !== undefined
       ?joo_global_object.unix_waitpid
       :function(){caml_failwith("unix_waitpid" + " not implemented")},
     unix_pipe=
      joo_global_object.unix_pipe !== undefined
       ?joo_global_object.unix_pipe
       :function(){caml_failwith("unix_pipe" + " not implemented")},
     unix_mkdir=
      joo_global_object.unix_mkdir !== undefined
       ?joo_global_object.unix_mkdir
       :function(){caml_failwith("unix_mkdir" + " not implemented")},
     unix_fork=
      joo_global_object.unix_fork !== undefined
       ?joo_global_object.unix_fork
       :function(){caml_failwith("unix_fork" + " not implemented")},
     unix_execv=
      joo_global_object.unix_execv !== undefined
       ?joo_global_object.unix_execv
       :function(){caml_failwith("unix_execv" + " not implemented")},
     unix_dup2=
      joo_global_object.unix_dup2 !== undefined
       ?joo_global_object.unix_dup2
       :function(){caml_failwith("unix_dup2" + " not implemented")},
     unix_dup=
      joo_global_object.unix_dup !== undefined
       ?joo_global_object.unix_dup
       :function(){caml_failwith("unix_dup" + " not implemented")},
     unix_close=
      joo_global_object.unix_close !== undefined
       ?joo_global_object.unix_close
       :function(){caml_failwith("unix_close" + " not implemented")};
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4?f(a0,a1,a2,a3):caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5?f(a0,a1,a2,a3,a4):caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call6(f,a0,a1,a2,a3,a4,a5)
     {return f.length == 6
              ?f(a0,a1,a2,a3,a4,a5)
              :caml_call_gen(f,[a0,a1,a2,a3,a4,a5])}
    function caml_call7(f,a0,a1,a2,a3,a4,a5,a6)
     {return f.length == 7
              ?f(a0,a1,a2,a3,a4,a5,a6)
              :caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6])}
    caml_fs_init();
    var
     Out_of_memory=[248,caml_string_of_jsbytes("Out_of_memory"),-1],
     Sys_error=[248,caml_string_of_jsbytes("Sys_error"),-2],
     Failure=[248,caml_string_of_jsbytes("Failure"),-3],
     Invalid_argument=[248,caml_string_of_jsbytes("Invalid_argument"),-4],
     End_of_file=[248,caml_string_of_jsbytes("End_of_file"),-5],
     Division_by_zero=[248,caml_string_of_jsbytes("Division_by_zero"),-6],
     Not_found=[248,caml_string_of_jsbytes("Not_found"),-7],
     Match_failure=[248,caml_string_of_jsbytes("Match_failure"),-8],
     Stack_overflow=[248,caml_string_of_jsbytes("Stack_overflow"),-9],
     Sys_blocked_io=[248,caml_string_of_jsbytes("Sys_blocked_io"),-10],
     Assert_failure=[248,caml_string_of_jsbytes("Assert_failure"),-11],
     Undefined_recursive_module=
      [248,caml_string_of_jsbytes("Undefined_recursive_module"),-12],
     mode=[0,0,[0,7,0]],
     min_int=caml_int64_create_lo_mi_hi(0,0,32768),
     dummy_pos=[0,caml_string_of_jsbytes(""),0,0,-1],
     zero_pos=[0,caml_string_of_jsbytes(""),1,0,0],
     param=
      [0,
       [11,caml_string_of_jsbytes("invalid box description "),[3,0,0]],
       caml_string_of_jsbytes("invalid box description %S")],
     current_dir_name=caml_string_of_jsbytes("."),
     dir_sep=caml_string_of_jsbytes("/"),
     quotequote=caml_string_of_jsbytes("'\\''"),
     current_dir_name$0=caml_string_of_jsbytes("."),
     parent_dir_name=caml_string_of_jsbytes(".."),
     dir_sep$0=caml_string_of_jsbytes("\\"),
     current_dir_name$1=caml_string_of_jsbytes("."),
     parent_dir_name$0=caml_string_of_jsbytes(".."),
     dir_sep$1=caml_string_of_jsbytes("/"),
     fun_name=caml_string_of_jsbytes("close_process"),
     shell=caml_string_of_jsbytes("/bin/sh"),
     fold_case_table=caml_string_of_jsbytes(""),
     s$0=caml_string_of_jsbytes("infinite or undefined rational number"),
     _gl_=[254,0.,0.],
     _gm_=[254,1.,1.],
     version=caml_string_of_jsbytes("0.9.3+dev"),
     neg_one_I=[254,-1.,-1.],
     neg_one_one_I=[254,-1.,1.],
     num2=[0,-100000],
     num2$0=[0,100000],
     partial=[12,93,0],
     n2=[0,2],
     one=[0,1],
     yylhs=
      caml_string_of_jsbytes
       ("\xff\xff\x01\0\x01\0\x06\0\x06\0\x05\0\x07\0\x07\0\b\0\b\0\b\0\b\0\b\0\x0e\0\x0e\0\t\0\t\0\x0f\0\n\0\n\0\x10\0\x10\0\x11\0\x11\0\x11\0\x11\0\x0b\0\x0b\0\x12\0\x12\0\f\0\f\0\x13\0\x13\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\r\0\r\0\x14\0\x14\0\x14\0\x15\0\x15\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\0\0\0\0"),
     yylen=
      caml_string_of_jsbytes
       ("\x02\0\x01\0\x04\0\0\0\x04\0\x01\0\0\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x01\0\x01\0\0\0\x03\0\x03\0\0\0\x03\0\n\0\b\0\0\0\x01\0\x01\0\x01\0\0\0\x03\0\x03\0\x04\0\0\0\x03\0\x03\0\x04\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\0\0\x03\0\x03\0\x04\0\x01\0\x01\0\x02\0\f\0\x01\0\b\0\x06\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x04\0\x03\0\x03\0\x03\0\x03\0\x02\0\x02\0\x03\0\x03\0\x06\0\x03\0\x04\0\x04\0\b\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x06\0\x06\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x06\0\x06\0\x04\0\x06\0\x02\0\x02\0"),
     yydefred=
      caml_string_of_jsbytes
       ("\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\\\0\x01\0\x05\0\0\0\0\0\0\0\0\x005\x006\x007\x008\x003\0\0\x000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\b\0\0\0\x17\0\x18\0\x19\0\t\0\0\0\0\0\0\0\n\0\0\0\0\0\x0b\0\0\0\0\0\0\0\f\0\0\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0e\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0C\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0A\0\0\0\0\0\x02\0\0\0\x10\0\x13\0\0\0\0\0\0\0\x1b\0\0\0\0\0 \0\0\0\x1f\0\0\0\0\0)\0\0\0D\0E\0G\0\0\0\0\0\0\0H\0I\0J\0K\0L\0O\0P\0Q\0R\0S\0T\0U\0V\0W\0\0\0\0\0Z\0\0\0\0\x009\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0!\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\0\0\0\0\0\0\0\0\0\0\0\0\x002\0\0\0M\0N\0X\0Y\0[\0B\0\x04\0\0\0\0\0\0\0\0\0\0\x001\0F\0\0\0\0\0-\0\0\0\0\0.\0\0\0\0\0\0\0/\0"),
     yydgoto=
      caml_string_of_jsbytes
       ("\x03\0\n\0D\0\xa8\x002\0\x0b\0\x9e\0\f\0\r\x005\0:\0>\0A\0E\0o\x006\0;\0<\0?\0B\0F\0\xf9\0"),
     yysindex=
      caml_string_of_jsbytes
       ('"\0\xfb\xfe\x90\xff\0\x000\xff\xee\xfe\xf3\xfe\xf7\xfe\x0f\xff\xca\xff\0\0\0\0\0\x000\xff\x90\xff\x90\xff\x90\xff\0\0\0\0\0\0\0\0\0\0\x03\xff\0\0\x1d\xff4\xff7\xff\\\xffn\xff\x80\xff\x8e\xff\x8f\xff\x92\xff\xcf\xff\x04\0\x05\0\x14\0\x16\x000\0E\0G\0H\0M\0W\0Y\0Z\0_\0i\0k\0|\xffl\0I\xffU\xff\0\0>\xff\0\0\0\0\0\0\0\0>\xff\xbb\xff\xf9\xfe\0\0>\xff\x06\xff\0\0>\xff\xfd\xfe|\xff\0\0>\xff\0\0\xa0\xffh\xffh\xff\xf7\xff\x90\xff\x90\xff\x90\xff\x90\xff\x90\xff\x90\xff\x90\xff\x90\xff\x90\xff\x90\xff\x90\xff\x90\xff\x90\xff\x90\xff\x90\xff\x90\xff\x90\xff\x90\xff\x90\xff\x90\xff\x90\xff\x90\xff\x90\xff\x90\xff\x90\xff\x90\xff\x90\xff\x90\xff\x90\xff\x0b\xff\x90\xff?\0\x90\xff\0\0\0\0\xee\xfe\xf3\xfe\xfe\xff\x90\xffJ\0\xf7\xfe\xb1\0j\0\x0f\xff\x90\xfff\0\xca\xff\0\0z\0h\xff+\0\xc1\0\xea\0L\xffQ\xff^\xff$\x01.\x018\x01B\x01X\x01e\x01\x83\x01\x8d\x01\x9b\x01\xa6\x01\xb0\x01\xba\x01\xc4\x01\xce\x01c\xffp\xff\xd8\x01u\xff%\0%\0h\xffh\xfft\0\0\0\xe2\x010\xff\0\0|\xff\0\0\0\0{\0|\xff\x90\xff\0\0\xb1\0\xcc\xff\0\0\xb1\0\0\0|\xff\x90\xff\0\0q\0\0\0\0\0\0\0\x90\xff\x90\xff\x90\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\xff\x90\xff\0\0\x90\xffx\0\0\0\x88\0\x90\xff|\xff"\xff}\0\x90\xff\x90\xff\x90\xff\x90\xff\x90\xff\0\0|\xff\x07\xff\x82\xff\xec\x01\xf6\x01\0\x02\n\x02\x14\x02\x8e\0?\0\x94\xff\0\0|\xff|\xff|\xff|\xff|\xff\x82\0\0\0\x90\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\xff\x17\xff\x1e\x02\xdd\xff\xfa\xfe\0\0\0\0\x7f\0\x8a\0\0\0\xa0\0\x90\xff\0\0\xfa\xfe|\xff\x9e\0\0\0'),
     yyrindex=
      caml_string_of_jsbytes
       ("\0\0\xa9\x01\0\0\0\0\xa1\0\x06\0\x01\0\x0b\0\x10\0&\0\0\0\0\0\0\0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x005\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xab\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0;\xff\xa1\xff\0\0\0\0\0\0\0\0C\0U\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb3\x01\0\0\0\0\0\0\x06\0\x01\0\0\0\0\0\0\0\x0b\0\0\0\0\0\x10\0\0\0\0\0&\0\0\0\0\0g\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x9d\0\xaf\0y\0\x8b\0\0\0\0\0\0\0\xa1\0\0\0\xae\xff\0\0\0\0\0\0\xe3\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\n\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x008\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb3\x01\0\0\0\0N\xff`\xffr\xff\xcd\xff\x0e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0:\0\0\0\0\0\0\0\0\0\0\0\0\0<\0\0\0\0\0"),
     yygindex=
      caml_string_of_jsbytes
       ("\0\0\0\0\xb5\x01\x91\xff\xff\xff\xfc\xff\xc9\0\xc3\x01\0\0I\x01M\x01]\x01[\x01v\x01V\0\0\0\0\0\0\0\0\0\0\0\0\0\xf5\0"),
     yytable=
      caml_string_of_jsbytes
       ('3\0\x12\0\x06\0\x04\x004\0\xf7\0\x0f\0u\0r\0K\0\xe5\0\x1a\0x\0=\0\xe6\0\x9a\0\x1e\0\xf8\x007\x008\x009\0\x05\0\x06\0\x07\0\b\0\t\0\xf3\0\x15\0\x16\0\x17\0\xf4\0\x15\0\x16\0\x17\0\x9b\0\x01\0\x02\0@\0(\0{\0\x15\0\x16\0\x17\0L\0e\0f\0g\0h\0i\0\xce\0\xcf\0\xd0\0\xd1\0\xd2\x004\0\xcd\0M\x004\0\xd3\0N\0s\x005\x005\0v\0m\0n\0y\0?\x004\x005\x005\x005\x005\x005\0\x05\0\x06\0\x07\0\b\0\t\0\xb2\0"\0"\0k\0"\0\xb3\0>\0e\0f\0g\0h\0i\0e\0f\0g\0h\0i\0O\0\xb4\0#\0#\0l\0#\0\xc3\0@\0e\0f\0g\0h\0i\0e\0f\0g\0h\0i\0P\0\xc4\0%\0%\0i\0%\0\xc6\0<\0e\0f\0g\0h\0i\0e\0f\0g\0h\0i\0Q\0\xe7\0e\0f\0g\0h\0i\0=\0e\0f\0g\0h\0i\0p\0R\0S\0\x0e\0t\0T\0\xef\0w\0\xc9\0\x0f\0\x10\0z\0:\0e\0f\0g\0h\0i\0,\0,\0{\0\x11\0\x12\0\x13\0\x14\0e\0f\0g\0h\0i\0;\0\x11\0\x11\0\x15\0\x16\0\x17\0\x18\0\x19\0\x1a\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0 \0!\0"\0#\0$\0%\0&\0\'\0(\0)\0*\0+\0,\0-\0.\0/\x000\0\x0e\0$\0$\0q\0$\0U\0\x0f\0\x10\0e\0f\0g\0h\0i\0\xce\0\xcf\0\xd0\0\xd1\0\xd2\0C\0\x12\0\x13\0\x14\0\xf6\0\x1c\0\x1c\0e\0f\0g\0h\0i\0\x15\0\x16\0\x17\0\x18\0\x19\0\x1a\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0 \0!\0"\0#\0$\0%\0&\0\'\0(\0)\0*\0+\0,\0-\0.\0/\x000\0V\0W\0\x12\0\x06\0*\0*\0|\0\x0f\0&\0&\0\xa2\0&\0\x1a\0\x1d\0\x1d\0\x16\0X\0\x1e\0Y\0\x12\0\x12\0\x12\0\x12\0\x12\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0(\0\xaf\0g\0h\0i\0Z\0e\0f\0g\0h\0i\0+\0+\0\x15\0\x15\0\x14\0\x14\0(\0(\0(\0(\0(\0?\0?\0\x9d\0?\0[\0?\0\\\0]\0?\0?\0?\0?\0^\0?\0?\0?\0?\0?\0>\0>\0\xa4\0>\0_\0>\0`\0a\0>\0>\0>\0>\0b\0>\0>\0>\0>\0>\0@\0@\0\xa9\0@\0c\0@\0d\0j\0@\0@\0@\0@\0\xac\0@\0@\0@\0@\0@\0<\0<\0\xae\0<\0\xc7\0<\0\xca\0\xdf\0<\0<\0<\0<\0\xd5\0<\0<\0<\0<\0<\0=\0=\0\xdc\0=\0\xdd\0=\0\xed\0\xfa\0=\0=\0=\0=\0\xf0\0=\0=\0=\0=\0=\0:\0:\0\xfb\0:\0\xfc\0:\0\xff\0\xee\0:\0:\0\x06\0\x06\0]\0:\0:\0:\0:\0:\0;\0;\0\x03\0;\0\xa6\0;\x001\0\xa0\0;\0;\0\x0f\0\x10\0\xa1\0;\0;\0;\0;\0;\0H\0I\0J\0\xb0\0\x11\0\x12\0\x13\0\x14\0e\0f\0g\0h\0i\0G\0\xa5\0\xaa\0\x15\0\x16\0\x17\0\x18\0\x19\0\x1a\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0 \0!\0"\0#\0$\0%\0&\0\'\0(\0)\0*\0+\0,\0-\0.\0/\x000\0\xb1\0\xad\0\xfe\0\0\0\0\0e\0f\0g\0h\0i\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0}\0~\0\x7f\0\x80\0\x81\0\x82\0\x83\0\x84\0\x85\0\x86\0\x87\0\x88\0\x89\0\x8a\0\x8b\0\x8c\0\x8d\0\x8e\0\x8f\0\x90\0\x91\0\x92\0\x93\0\x94\0\x95\0\x96\0\x97\0\x98\0\x99\0\0\0\x9c\0\0\0\x9f\0\0\0\0\0\0\0\0\0\0\0\xa3\0\0\0\xb5\0\xa7\0\0\0\0\0\xab\0e\0f\0g\0h\0i\0\xb6\0\0\0\0\0\0\0\0\0e\0f\0g\0h\0i\0\xb7\0\0\0\0\0\0\0\0\0e\0f\0g\0h\0i\0\xb8\0\0\0\0\0\0\0\0\0e\0f\0g\0h\0i\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xcb\0\0\0\xcc\0\0\0\xb9\0\xa7\0\0\0\0\0\xd4\0e\0f\0g\0h\0i\0\xd6\0\xd7\0\xd8\0\xba\0\0\0\0\0\0\0\0\0e\0f\0g\0h\0i\0\0\0\0\0\0\0\0\0\xd9\0\xda\0\0\0\xdb\0\0\0\0\0\0\0\xde\0\0\0\0\0\0\0\xe0\0\xe1\0\xe2\0\xe3\0\xe4\0\xbb\0\0\0\0\0\0\0\0\0e\0f\0g\0h\0i\0\xbc\0\0\0\0\0\0\0\0\0e\0f\0g\0h\0i\0\xf1\0\0\0\0\0\0\0\xbd\0\0\0\0\0\0\0\xf2\0e\0f\0g\0h\0i\0\0\0\xbe\0\0\0\0\0\0\0\xfd\0e\0f\0g\0h\0i\0\xbf\0\0\0\0\0\0\0\0\0e\0f\0g\0h\0i\0\xc0\0\0\0\0\0\0\0\0\0e\0f\0g\0h\0i\0\xc1\0\0\0\0\0\0\0\0\0e\0f\0g\0h\0i\0\xc2\0\0\0\0\0\0\0\0\0e\0f\0g\0h\0i\0\xc5\0\0\0\0\0\0\0\0\0e\0f\0g\0h\0i\0\xc8\0\0\0\0\0\0\0\0\0e\0f\0g\0h\0i\0\xe8\0\0\0\0\0\0\0\0\0e\0f\0g\0h\0i\0\xe9\0\0\0\0\0\0\0\0\0e\0f\0g\0h\0i\0\xea\0\0\0\0\0\0\0\0\0e\0f\0g\0h\0i\0\xeb\0\0\0\0\0\0\0\0\0e\0f\0g\0h\0i\0\xec\0\0\0\0\0\0\0\0\0e\0f\0g\0h\0i\0\xf5\0\0\0\0\0\0\0\0\0e\0f\0g\0h\0i\0'),
     yycheck=
      caml_string_of_jsbytes
       ('\x04\0\0\0\0\0\b\x01\x16\x01\x0b\x01\0\0\x01\x01\x0f\x01\x06\x01\x03\x01\0\0\x0f\x01\x16\x01\x07\x01\x04\x01\0\0\x17\x01\x1f\x01 \x01!\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x03\x01"\x01#\x01$\x01\x07\x01"\x01#\x01$\x01\x17\x01\x01\0\x02\0\x16\x01\0\0\x05\x01"\x01#\x01$\x01\x0e\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x01\x01\xa6\0\x04\x01\x04\x01\xa9\0\x04\x01=\0\x02\x01\x03\x01@\0\x02\x01\x03\x01C\0\0\0\x0f\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x03\x01\x02\x01\x03\x01\t\x01\x05\x01\x03\x01\0\0\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x04\x01\x03\x01\x02\x01\x03\x01\x0f\x01\x05\x01\x03\x01\0\0\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x04\x01\x03\x01\x02\x01\x03\x01\x0e\x01\x05\x01\x03\x01\0\0\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x04\x01\x03\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\0\0\n\x01\x0b\x01\f\x01\r\x01\x0e\x01;\0\x04\x01\x04\x01\x04\x01?\0\x04\x01\x03\x01B\0\x9d\0\n\x01\x0b\x01F\0\0\0\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x02\x01\x03\x01\x05\x01\x16\x01\x17\x01\x18\x01\x19\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\0\0\x02\x01\x03\x01"\x01#\x01$\x01%\x01&\x01\'\x01(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x015\x016\x017\x018\x019\x01:\x01;\x01<\x01=\x01\x04\x01\x02\x01\x03\x01\x16\x01\x05\x01\x04\x01\n\x01\x0b\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x16\x01\x17\x01\x18\x01\x19\x01\x07\x01\x02\x01\x03\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01"\x01#\x01$\x01%\x01&\x01\'\x01(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x015\x016\x017\x018\x019\x01:\x01;\x01<\x01=\x01\x04\x01\x04\x01\t\x01\t\x01\x02\x01\x03\x01\x17\x01\t\x01\x02\x01\x03\x01\x14\x01\x05\x01\t\x01\x02\x01\x03\x01\x16\x01\x04\x01\t\x01\x04\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\t\x01\x05\x01\f\x01\r\x01\x0e\x01\x04\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x02\x01\x03\x01\x02\x01\x03\x01\x02\x01\x03\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x02\x01\x03\x01\b\x01\x05\x01\x04\x01\x07\x01\x04\x01\x04\x01\n\x01\x0b\x01\f\x01\r\x01\x04\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x02\x01\x03\x01\x0f\x01\x05\x01\x04\x01\x07\x01\x04\x01\x04\x01\n\x01\x0b\x01\f\x01\r\x01\x04\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x02\x01\x03\x01\x01\x01\x05\x01\x04\x01\x07\x01\x04\x01\x04\x01\n\x01\x0b\x01\f\x01\r\x01\x0f\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x02\x01\x03\x01\x03\x01\x05\x01\x0b\x01\x07\x01\x06\x01\x05\x01\n\x01\x0b\x01\f\x01\r\x01\x16\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x02\x01\x03\x01\x17\x01\x05\x01\t\x01\x07\x01\x05\x01\x15\x01\n\x01\x0b\x01\f\x01\r\x01\x17\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x02\x01\x03\x01\x17\x01\x05\x01\x03\x01\x07\x01\x07\x01\xdd\0\n\x01\x0b\x01\0\0\t\x01\0\0\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x02\x01\x03\x01\0\0\x05\x01\x04\x01\x07\x01\x02\0o\0\n\x01\x0b\x01\n\x01\x0b\x01p\0\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x0e\0\x0f\0\x10\0\x05\x01\x16\x01\x17\x01\x18\x01\x19\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\r\0t\0w\0"\x01#\x01$\x01%\x01&\x01\'\x01(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x015\x016\x017\x018\x019\x01:\x01;\x01<\x01=\x01\x05\x01z\0\xfc\0\xff\xff\xff\xff\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffL\0M\0N\0O\0P\0Q\0R\0S\0T\0U\0V\0W\0X\0Y\0Z\0[\0\\\0]\0^\0_\0`\0a\0b\0c\0d\0e\0f\0g\0h\0\xff\xffj\0\xff\xffl\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffr\0\xff\xff\x05\x01u\0\xff\xff\xff\xffx\0\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x05\x01\xff\xff\xff\xff\xff\xff\xff\xff\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x05\x01\xff\xff\xff\xff\xff\xff\xff\xff\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x05\x01\xff\xff\xff\xff\xff\xff\xff\xff\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa4\0\xff\xff\xa6\0\xff\xff\x05\x01\xa9\0\xff\xff\xff\xff\xac\0\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\xb2\0\xb3\0\xb4\0\x05\x01\xff\xff\xff\xff\xff\xff\xff\xff\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\xff\xff\xff\xff\xff\xff\xff\xff\xc3\0\xc4\0\xff\xff\xc6\0\xff\xff\xff\xff\xff\xff\xca\0\xff\xff\xff\xff\xff\xff\xce\0\xcf\0\xd0\0\xd1\0\xd2\0\x05\x01\xff\xff\xff\xff\xff\xff\xff\xff\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x05\x01\xff\xff\xff\xff\xff\xff\xff\xff\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\xe7\0\xff\xff\xff\xff\xff\xff\x05\x01\xff\xff\xff\xff\xff\xff\xef\0\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\xff\xff\x05\x01\xff\xff\xff\xff\xff\xff\xfa\0\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x05\x01\xff\xff\xff\xff\xff\xff\xff\xff\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x05\x01\xff\xff\xff\xff\xff\xff\xff\xff\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x05\x01\xff\xff\xff\xff\xff\xff\xff\xff\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x05\x01\xff\xff\xff\xff\xff\xff\xff\xff\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x05\x01\xff\xff\xff\xff\xff\xff\xff\xff\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x05\x01\xff\xff\xff\xff\xff\xff\xff\xff\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x05\x01\xff\xff\xff\xff\xff\xff\xff\xff\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x05\x01\xff\xff\xff\xff\xff\xff\xff\xff\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x05\x01\xff\xff\xff\xff\xff\xff\xff\xff\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x05\x01\xff\xff\xff\xff\xff\xff\xff\xff\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x05\x01\xff\xff\xff\xff\xff\xff\xff\xff\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x05\x01\xff\xff\xff\xff\xff\xff\xff\xff\n\x01\x0b\x01\f\x01\r\x01\x0e\x01'),
     yynames_const=
      caml_string_of_jsbytes
       ("EOF\0COLON\0SEMICOLON\0COMMA\0LPAREN\0RPAREN\0LBRACKET\0RBRACKET\0LBRACE\0RBRACE\0PLUS\0MINUS\0MULT\0DIVIDE\0POW\0EQ\0LE\0GE\0LT\0GT\0IN\0PLUS_MINUS\0CONSTANTS\0VARIABLES\0DEFINITIONS\0CONSTRAINTS\0EXPRESSIONS\0INT\0REAL\0RND\0NO_RND\0E_CONST\0ABS\0INV\0SQRT\0FMA\0MIN\0MAX\0EXP\0LOG\0COS\0SIN\0TAN\0COSH\0SINH\0TANH\0ACOS\0ASIN\0ATAN\0ACOSH\0ASINH\0ATANH\0ATAN2\0SUB2\0FLOOR_POWER2\0INTERVAL\0"),
     yynames_block=
      caml_string_of_jsbytes
       ("ID\0NUMBER\0SINGLE_NUMERAL\0DOUBLE_NUMERAL\0FLOAT\0RND_PAR\0"),
     tbl=
      [0,
       caml_string_of_jsbytes
        ("\0\0\xe3\xff\xe4\xffX\0\x19\0\x02\0\x03\0\xec\xff\xed\xff\xef\xff\xf0\xff-\0\xf2\xff\xf3\xff\xf4\xff\xf5\xff\xf6\xff\xf7\xff\xf8\xff\xf9\xff\xfa\xff\xa5\0\xb2\0\x01\0\xfe\xff\x03\x001\0\x04\0\xfc\xff\xfd\xff\xc1\0\xfb\0\x0b\x01$\x01J\x01p\x01\x96\x01\xbc\x01\xd7\x01\xe3\x01\xfd\x01\t\x02J\x02p\x02\x96\x02\x01\0\xe7\xff\xeb\xff\xea\xff\xe6\xff"),
       caml_string_of_jsbytes
        ("\xff\xff\xff\xff\xff\xff\x1a\0\x1b\0\x17\0\x16\0\xff\xff\xff\xff\xff\xff\xff\xff\x0e\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x04\0\x04\0\x01\0\xff\xff\0\0\x11\0\0\0\xff\xff\xff\xff\xff\xff\x04\0\xff\xff\x04\0\x04\0\x03\0\x02\0\x04\0\xff\xff\x04\0\x04\0\x03\0\x02\0\x04\0\x04\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"),
       caml_string_of_jsbytes
        ("\x02\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\0\0\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\x1b\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\0\0"),
       caml_string_of_jsbytes
        ('\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x19\0\x18\0\x18\0\x19\0\x17\0\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x19\0\0\0\0\0\x19\0\x03\0\x04\0\0\0\0\0\x14\0\x13\0\t\0\x0b\0\f\0\n\0.\0\x1a\0\x16\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\r\0\x0e\0\x06\0\x07\0\x05\x000\0/\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x12\0-\0\x11\0\b\0\x03\0\x1b\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x10\0\x03\0\x0f\x001\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\0\0\0\0\0\0\0\0\x03\0\0\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x1f\0\0\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\0\0\x1f\0\0\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0&\0\0\0&\0\0\0\0\0(\0(\0(\0(\0(\0(\0(\0(\0(\0(\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\xff\xff\0\0\0\0\0\0\0\0\x1c\0\x1e\0\x1d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x1e\0\x1c\0\x1e\0\x1d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x1e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0 \0\x1f\0\x1f\0\x1f\0\x1f\0\x1f\0\x1f\0\x1f\0\x1f\0\x1f\0\x1f\0\0\0\0\0\0\0\0\0\0\0\0\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0!\0!\0!\0!\0!\0!\0"\0\0\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0\0\0\x1c\0\x1e\0\x1d\0\0\0\0\0\0\0!\0!\0!\0!\0!\0!\0\x1e\0!\0!\0!\0!\0!\0!\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0\0\0!\0!\0!\0#\0%\0$\0"\0"\0"\0"\0"\0"\0\0\0\0\0\0\0\x1e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"\0\0\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0\0\0"\0"\0"\0)\0+\0*\0!\0!\0!\0!\0!\0!\0\0\0\0\0\0\0\x1e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"\0\0\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0\0\0!\0!\0!\0#\0%\0$\0!\0!\0!\0!\0!\0!\0\0\0\0\0\0\0\x1e\0\0\0\0\0\0\0\0\0\0\0\0\0&\0\0\0&\0"\0\0\0\'\0\'\0\'\0\'\0\'\0\'\0\'\0\'\0\'\0\'\0\0\0!\0!\0!\0#\0%\0$\0!\0!\0!\0!\0!\0!\0\0\0\0\0\0\0\x1e\0(\0(\0(\0(\0(\0(\0(\0(\0(\0(\0"\0\0\0\'\0\'\0\'\0\'\0\'\0\'\0\'\0\'\0\'\0\'\0!\0!\0!\0#\0%\0$\0\0\0!\0!\0!\0!\0!\0!\0\0\0\0\0\x1e\0(\0(\0(\0(\0(\0(\0(\0(\0(\0(\0\0\0\0\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0\0\0!\0!\0!\0#\0%\0$\0"\0"\0"\0"\0"\0"\0\0\0\0\0\0\0\x1e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x1c\0\0\0\x1d\0\0\0\0\0\0\0\0\0\0\0\0\0"\0"\0"\0)\0+\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x1e\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"\0"\0"\0"\0"\0"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0&\0\0\0&\0\0\0\0\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0\0\0"\0"\0"\0)\0+\0*\0"\0"\0"\0"\0"\0"\0\0\0\0\0\0\0\x1e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0\0\0"\0"\0"\0)\0+\0*\0"\0"\0"\0"\0"\0"\0\0\0\0\0\0\0\x1e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"\0"\0"\0)\0+\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x1e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'),
       caml_string_of_jsbytes
        ("\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\x17\0\x19\0\0\0\x1b\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\x19\0\0\0\0\0\xff\xff\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0-\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\0\x06\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0b\0\0\0\0\0\0\0\x1a\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x03\0\0\0\x04\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\xff\xff\xff\xff\xff\xff\xff\xff\x03\0\xff\xff\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x15\0\xff\xff\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\xff\xff\x16\0\xff\xff\x16\0\x16\0\x16\0\x16\0\x16\0\x16\0\x16\0\x16\0\x16\0\x16\0\x1e\0\xff\xff\x1e\0\xff\xff\xff\xff\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\x1b\0\xff\xff\xff\xff\xff\xff\xff\xff\x15\0\x15\0\x15\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x15\0\x16\0\x16\0\x16\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16\0\x1f\0\x1f\0\x1f\0\x1f\0\x1f\0\x1f\0\x1f\0\x1f\0\x1f\0\x1f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff \0 \0 \0 \0 \0 \0 \0 \0 \0 \0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff \0 \0 \0 \0 \0 \0!\0\xff\xff!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0\xff\xff\x1f\0\x1f\0\x1f\0\xff\xff\xff\xff\xff\xff!\0!\0!\0!\0!\0!\0\x1f\0 \0 \0 \0 \0 \0 \0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\xff\xff!\0!\0!\0!\0!\0!\0\"\0\"\0\"\0\"\0\"\0\"\0\xff\xff\xff\xff\xff\xff!\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff#\0\xff\xff#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\xff\xff\"\0\"\0\"\0\"\0\"\0\"\0#\0#\0#\0#\0#\0#\0\xff\xff\xff\xff\xff\xff\"\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\0\xff\xff$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0\xff\xff#\0#\0#\0#\0#\0#\0$\0$\0$\0$\0$\0$\0\xff\xff\xff\xff\xff\xff#\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\0\xff\xff%\0%\0\xff\xff%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0\xff\xff$\0$\0$\0$\0$\0$\0%\0%\0%\0%\0%\0%\0\xff\xff\xff\xff\xff\xff$\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0'\0\xff\xff'\0'\0'\0'\0'\0'\0'\0'\0'\0'\0%\0%\0%\0%\0%\0%\0\xff\xff'\0'\0'\0'\0'\0'\0\xff\xff\xff\xff%\0(\0(\0(\0(\0(\0(\0(\0(\0(\0(\0\xff\xff\xff\xff)\0)\0)\0)\0)\0)\0)\0)\0)\0)\0\xff\xff'\0'\0'\0'\0'\0'\0)\0)\0)\0)\0)\0)\0\xff\xff\xff\xff\xff\xff'\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff(\0\xff\xff(\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\0)\0)\0)\0)\0)\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\0*\0*\0*\0*\0*\0*\0*\0*\0*\0*\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff*\0*\0*\0*\0*\0*\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff+\0\xff\xff+\0\xff\xff\xff\xff+\0+\0+\0+\0+\0+\0+\0+\0+\0+\0\xff\xff*\0*\0*\0*\0*\0*\0+\0+\0+\0+\0+\0+\0\xff\xff\xff\xff\xff\xff*\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0\xff\xff+\0+\0+\0+\0+\0+\0,\0,\0,\0,\0,\0,\0\xff\xff\xff\xff\xff\xff+\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff,\0,\0,\0,\0,\0,\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff,\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"),
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes("")],
     suffix=caml_string_of_jsbytes(".out"),
     prefix=caml_string_of_jsbytes("maxima"),
     empty_result=[0,0.,0.,0,0.],
     partial$0=[11,caml_string_of_jsbytes(", bounds="),[2,0,[12,41,0]]],
     task_vars$0=[0,caml_string_of_jsbytes("unused"),0],
     task_vars=[0,caml_string_of_jsbytes("unused"),0],
     mp_prefix=caml_string_of_jsbytes("mpfr"),
     mp_type=caml_string_of_jsbytes("mpfr_t"),
     msg$0=caml_string_of_jsbytes("inv_form: division by zero"),
     abs_approx_str=
      caml_string_of_jsbytes("The absolute error model (approximate):"),
     abs_exact_str=caml_string_of_jsbytes("The absolute error model (exact):"),
     rel_approx_str=
      caml_string_of_jsbytes("The relative error model (approximate):"),
     rel_exact_str=caml_string_of_jsbytes("The relative error model (exact):"),
     ulp_approx_str=
      caml_string_of_jsbytes("The ULP error model (approximate):"),
     ulp_exact_str=caml_string_of_jsbytes("The ULP error model (exact):"),
     abs_approx_str$0=caml_string_of_jsbytes("Absolute error (approximate):"),
     abs_exact_str$0=caml_string_of_jsbytes("Absolute error (exact):"),
     rel_approx_str$0=caml_string_of_jsbytes("Relative error (approximate):"),
     rel_exact_str$0=caml_string_of_jsbytes("Relative error (exact):"),
     ulp_approx_str$0=caml_string_of_jsbytes("ULP error (approximate):"),
     ulp_exact_str$0=caml_string_of_jsbytes("ULP error (exact):"),
     default_cfg=
      caml_string_of_jsbytes
       ("\n# All options of FPTaylor and their default values.\n# Any line which starts with * or # is a comment line.\n\n# All FPTaylor options are declared in this file.\n# It is not necessary to edit this file to change options.\n# A separate config file can be created with new values for some options\n# and then it can be passed as a parameter to fptaylor:\n#\n# fptaylor -c config_file_name ...\n#\n# It is also possible to pass options as parameters in the following way:\n# fptaylor --option_name value ...\n#\n# Some options have short names declared in this file as [short: id].\n# An option with a short name can be used in the command line in the following way:\n# fptaylor -id value ...\n#\n# A comment starting with ## gives a short description of the next defined option.\n# `fptaylor -help` prints out all these short descriptions.\n\n#**************************\n# Basic options\n#**************************\n\n## If true then additional debug information is printed.\n[short: d]\ndebug = true\n\n## Specifies the verbosity level of the output.\n# 0: print main results only\n# 1: print important steps\n# 2: print additional information for each step\n# 3: print everything (including debug information)\n[short: v]\nverbosity = 2\n\n## The output precision of all important values (final error bounds).\n# The final error bounds are printed as correctly rounded decimal numbers\n# with the `print-precision` number of digits.\nprint-precision = 7\n\n## If true then lower bounds are printed for all optimization problems.\n# If the difference between lower and upper bounds is significant\n# (more than 10%) then it may be possible to increase the precision\n# by changing optimization parameters (for instance, opt-x-abs-tol = 0).\nprint-opt-lower-bounds = true\n\n## If true then exact error bound values are printed as hexadecimal floating-point numbers.\nprint-hex-floats = true\n\n## If true then absolute round-off error is computed.\n[short: abs]\nabs-error = true\n\n## If true then relative round-off error is computed.\n[short: rel]\nrel-error = false\n\n## If true then ulp round-off error is computed\n[short: ulp]\nulp-error = false\n\n## The function range threshold for relative errors.\nrel-error-threshold = 0.0001\n\n## Type of variables without explicit types\ndefault-var-type = float64\n\n## Default rounding operation (for rounding operations without parameters)\ndefault-rnd = rnd64\n\n## If true then bounds of the analyzed expressions are computed.\n# These bounds are always computed if rel-error = true.\nfind-bounds = false\n\n## If true then uncertainty specifications for input variables are used.\nuncertainty = false\n\n## If true, all potential overflows and invalid operations throw an exception.\nfail-on-exception = true\n\n## If true then expressions are algebraically simplified before optimization.\n# Maxima must be installed if maxima-simplification = true.\nmaxima-simplification = false\n\n## If true then a more accurate rounding model is used.\n# This model introduces discontinuous functions in optimization problems.\nfp-power2-model = true\n\n## If true then a special rounding model is used for real variables.\n# This rounding model computes constant erros based on interval bounds of a variable.\n# This model may yield better results when fp-power2-model = false.\nconst-approx-real-vars = false\n\n## If true then second order error terms are estimated with an optimization procedure.\n# This mode is slower but can yield more accurate results.\n# It may be useful if the total second order error is too large.\nintermediate-opt = false\n\n# If true then rounding of equivalent expression will\n# produce different indices (i.e., no error cancellation effect).\n# May be useful to measure the error cancellation effect.\nunique-indices = false\n\n## If true then a proof certificate is created and saved.\nproof-record = false\n\n## Path to a directory where proof certificates are saved.\nproof-dir = proofs\n\n#**************************\n# Logging options\n#**************************\n\n## Path to a log directory.\n# Can be absolute or relative to a directory from which FPTaylor is called.\nlog-base-dir =\n\n# Current date may be attached to log file names.\n# This option specifies where date is attached to log file names.\n# Possible values: start, end, none.\n# Note: any value different from 'start' and 'end' has the same effect\n# as 'none' (date is not attached).\n# Log file names has the following format:\n# start: [YYYY-MM-DD-hhmmss]_input_file_name.log\n# end: input_file_name_[YYYY-MM-DD-hhmmss].log\n# none: input_file_name.log\nlog-append-date = start\n\n## Export all configuration options into the given file\nexport-options =\n\n#**************************\n# Temporary files\n#**************************\n\n## Path to a directory where temporary files are created.\ntmp-base-dir =\n\n## If true then subdirectories in the tmp directory are created.\n# Each subdirectory has current date as its name.\ntmp-date = false\n\n## If defined then a C file for the search_mpfr(mpfi) tool (from ErrorBounds) is created.\n# The following templates are supported:\n# {task} is replaced with task's name.\nexport-error-bounds =\n\n## If defined then a C file for the data_mpfi tool (from ErrorBounds) is created.\n# The following templates are supported:\n# {task} is replaced with task's name.\nexport-error-bounds-data =\n\n#**************************\n# Optimization options\n#**************************\n\n## Optimization method.\n# Possible values:\n# bb (basic interval branch and bound; OCaml compiler is required)\n# bb-eval (basic interval branch and bound which does not require\n#          OCaml compiler to be installed; slower than bb)\n# z3 (z3 SMT solver with binary search)\n# nlopt (nlopt optimization library; not rigorous)\n# gelpia (GELPIA tool)\nopt = bb-eval\n\n## If true then an approximate optimization problem is solved.\n[short: approx]\nopt-approx = false\n\n## If true then a full optimization problem is solved.\n# In general, this problem is harder than the approximate optimization problem\n# but may yield a better result.\n[short: exact]\nopt-exact = true\n\n# Parameters below may be not supported by all optimization methods.\n\n## Optimization relative tolerance for a function.\nopt-f-rel-tol = 0.01\n\n## Optimization absolute tolerance for a function.\nopt-f-abs-tol = 0.01\n\n## Optimization relative tolerance for a domain.\n# If the initial infinite norm of a domain is R then\n# subdomains will be subdivided only if\n# ||subdomain||_inf > R * opt-x-rel-tol + opt-f-abs-tol.\nopt-x-rel-tol = 0.0\n\n## Optimization absolute tolerance for a domain.\nopt-x-abs-tol = 0.01\n\n## Optimization maximum number of iterations.\n# Negative numbers denote unlimited iterations.\nopt-max-iters = 1000000\n\n## Optimization timeout (in milliseconds; should be integer).\nopt-timeout = 10000\n\n#**************************\n# z3 options\n#**************************\n\n## If true then interval bounds are used as the first approximation for the Z3 backend.\nz3-interval-bounds = true\n\n## Path to the Z3 installation (use a full home directory path instead of ~).\n# This path will be added to the LD_LIBRARY_PATH environment variable\n# before invoking Z3.\n# This path can be empty if it is already added to required environment\n# variables.\nz3-bin = \n\n## Path to the Z3 python library (use a full home directory path instead of ~).\n# This path will be added to the PYTHONPATH environment variable\n# before invoking Z3.\n# This path can be empty if it is already added to required environment\n# variables.\nz3-python-lib = \n\n## Python command for Z3.\nz3-python-cmd = python\n\n## Z3 random seed\nz3-seed = 0\n\n#**************************\n# bb options\n#**************************\n\nbb-compile = {base}/b_and_b/compile.sh {base} {input} {out}\n\n# bb algorithm (possible values: opt0)\nbb-alg = opt0\n\n#**************************\n# Gelpia options\n#**************************\n\n# In order to use Gelpia, set the GELPIA_PATH environment variable\n# or copy Gelpia to the FPTaylor root directory.\n\n#**************************\n# nlopt options\n#**************************\n\nnlopt-cc = gcc -std=c99 -O3\n\nnlopt-lib = -lnlopt -lm\n\n\n#**************************\n# Extra options\n#**************************\n\ndevelop = false\n"),
     config_files=[0,caml_string_of_jsbytes("user.cfg"),0];
    caml_register_global
     (11,Undefined_recursive_module,"Undefined_recursive_module");
    caml_register_global(10,Assert_failure,"Assert_failure");
    caml_register_global(9,Sys_blocked_io,"Sys_blocked_io");
    caml_register_global(8,Stack_overflow,"Stack_overflow");
    caml_register_global(7,Match_failure,"Match_failure");
    caml_register_global(6,Not_found,"Not_found");
    caml_register_global(5,Division_by_zero,"Division_by_zero");
    caml_register_global(4,End_of_file,"End_of_file");
    caml_register_global(3,Invalid_argument,"Invalid_argument");
    caml_register_global(2,Failure,"Failure");
    caml_register_global(1,Sys_error,"Sys_error");
    caml_register_global(0,Out_of_memory,"Out_of_memory");
    var
     _p_=caml_string_of_jsbytes("output_substring"),
     _o_=[0,1,[0,3,[0,4,[0,6,0]]]],
     _n_=[0,1,[0,3,[0,4,[0,7,0]]]],
     _m_=caml_string_of_jsbytes("%.12g"),
     _l_=caml_string_of_jsbytes("."),
     _i_=caml_string_of_jsbytes("false"),
     _j_=caml_string_of_jsbytes("true"),
     _k_=caml_string_of_jsbytes("bool_of_string"),
     _g_=caml_string_of_jsbytes("true"),
     _h_=caml_string_of_jsbytes("false"),
     _a_=caml_string_of_jsbytes("Stdlib.Pervasives.Exit"),
     _b_=caml_int64_create_lo_mi_hi(0,0,32752),
     _c_=caml_int64_create_lo_mi_hi(0,0,65520),
     _d_=caml_int64_create_lo_mi_hi(1,0,32752),
     _e_=caml_int64_create_lo_mi_hi(16777215,16777215,32751),
     _f_=caml_int64_create_lo_mi_hi(0,0,16),
     _r_=caml_string_of_jsbytes("\\\\"),
     _s_=caml_string_of_jsbytes("\\'"),
     _t_=caml_string_of_jsbytes("\\b"),
     _u_=caml_string_of_jsbytes("\\t"),
     _v_=caml_string_of_jsbytes("\\n"),
     _w_=caml_string_of_jsbytes("\\r"),
     _q_=caml_string_of_jsbytes("Char.chr"),
     _z_=caml_string_of_jsbytes("List.map2"),
     _A_=[0,caml_string_of_jsbytes("list.ml"),268,11],
     _x_=caml_string_of_jsbytes("hd"),
     _D_=caml_string_of_jsbytes("String.blit / Bytes.blit_string"),
     _C_=caml_string_of_jsbytes("Bytes.blit"),
     _B_=caml_string_of_jsbytes("String.sub / Bytes.sub"),
     _H_=caml_string_of_jsbytes("String.contains_from / Bytes.contains_from"),
     _G_=caml_string_of_jsbytes(""),
     _F_=caml_string_of_jsbytes(""),
     _E_=caml_string_of_jsbytes("String.concat"),
     _L_=[0,caml_string_of_jsbytes("array.ml"),233,4],
     _J_=caml_string_of_jsbytes("Array.blit"),
     _I_=caml_string_of_jsbytes("Array.sub"),
     _K_=caml_string_of_jsbytes("Stdlib.Array.Bottom"),
     _N_=caml_int64_create_lo_mi_hi(1,0,0),
     _M_=caml_int64_create_lo_mi_hi(1,0,0),
     _Q_=caml_string_of_jsbytes("syntax error"),
     _O_=caml_string_of_jsbytes("Stdlib.Parsing.YYexit"),
     _P_=caml_string_of_jsbytes("Stdlib.Parsing.Parse_error"),
     _V_=caml_string_of_jsbytes("Map.remove_min_elt"),
     _W_=[0,0,0,0],
     _X_=[0,caml_string_of_jsbytes("map.ml"),397,10],
     _Y_=[0,0,0],
     _R_=caml_string_of_jsbytes("Map.bal"),
     _S_=caml_string_of_jsbytes("Map.bal"),
     _T_=caml_string_of_jsbytes("Map.bal"),
     _U_=caml_string_of_jsbytes("Map.bal"),
     ___=caml_string_of_jsbytes("CamlinternalLazy.Undefined"),
     _ab_=caml_string_of_jsbytes("Buffer.add_substring/add_subbytes"),
     _aa_=caml_string_of_jsbytes("Buffer.add: cannot grow buffer"),
     _$_=caml_string_of_jsbytes("Buffer.sub"),
     _ak_=caml_string_of_jsbytes("%c"),
     _al_=caml_string_of_jsbytes("%s"),
     _am_=caml_string_of_jsbytes("%i"),
     _an_=caml_string_of_jsbytes("%li"),
     _ao_=caml_string_of_jsbytes("%ni"),
     _ap_=caml_string_of_jsbytes("%Li"),
     _aq_=caml_string_of_jsbytes("%f"),
     _ar_=caml_string_of_jsbytes("%B"),
     _as_=caml_string_of_jsbytes("%{"),
     _at_=caml_string_of_jsbytes("%}"),
     _au_=caml_string_of_jsbytes("%("),
     _av_=caml_string_of_jsbytes("%)"),
     _aw_=caml_string_of_jsbytes("%a"),
     _ax_=caml_string_of_jsbytes("%t"),
     _ay_=caml_string_of_jsbytes("%?"),
     _az_=caml_string_of_jsbytes("%r"),
     _aA_=caml_string_of_jsbytes("%_r"),
     _aB_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),846,23],
     _aM_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),810,21],
     _aE_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),811,21],
     _aN_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),814,21],
     _aF_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),815,21],
     _aO_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),818,19],
     _aG_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),819,19],
     _aP_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),822,22],
     _aH_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),823,22],
     _aQ_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),827,30],
     _aI_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),828,30],
     _aK_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),832,26],
     _aC_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),833,26],
     _aL_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),842,28],
     _aD_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),843,28],
     _aJ_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),847,23],
     _bN_=caml_string_of_jsbytes("%u"),
     _bL_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1525,4],
     _bM_=caml_string_of_jsbytes("Printf: bad conversion %["),
     _bO_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1593,39],
     _bP_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1616,31],
     _bQ_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1617,31],
     _bR_=caml_string_of_jsbytes("Printf: bad conversion %_"),
     _bS_=caml_string_of_jsbytes("@{"),
     _bT_=caml_string_of_jsbytes("@["),
     _bU_=caml_string_of_jsbytes("@{"),
     _bV_=caml_string_of_jsbytes("@["),
     _bW_=caml_string_of_jsbytes("@{"),
     _bX_=caml_string_of_jsbytes("@["),
     _bY_=caml_string_of_jsbytes(""),
     _bZ_=[0,0,4],
     _b0_=caml_string_of_jsbytes(""),
     _b1_=caml_string_of_jsbytes("b"),
     _b2_=caml_string_of_jsbytes("h"),
     _b3_=caml_string_of_jsbytes("hov"),
     _b4_=caml_string_of_jsbytes("hv"),
     _b5_=caml_string_of_jsbytes("v"),
     _bJ_=caml_string_of_jsbytes("nan"),
     _bK_=caml_string_of_jsbytes("."),
     _bH_=caml_string_of_jsbytes("neg_infinity"),
     _bI_=caml_string_of_jsbytes("infinity"),
     _bG_=caml_string_of_jsbytes("%.12g"),
     _bt_=caml_string_of_jsbytes("%nd"),
     _bu_=caml_string_of_jsbytes("%+nd"),
     _bv_=caml_string_of_jsbytes("% nd"),
     _bw_=caml_string_of_jsbytes("%ni"),
     _bx_=caml_string_of_jsbytes("%+ni"),
     _by_=caml_string_of_jsbytes("% ni"),
     _bz_=caml_string_of_jsbytes("%nx"),
     _bA_=caml_string_of_jsbytes("%#nx"),
     _bB_=caml_string_of_jsbytes("%nX"),
     _bC_=caml_string_of_jsbytes("%#nX"),
     _bD_=caml_string_of_jsbytes("%no"),
     _bE_=caml_string_of_jsbytes("%#no"),
     _bF_=caml_string_of_jsbytes("%nu"),
     _bg_=caml_string_of_jsbytes("%ld"),
     _bh_=caml_string_of_jsbytes("%+ld"),
     _bi_=caml_string_of_jsbytes("% ld"),
     _bj_=caml_string_of_jsbytes("%li"),
     _bk_=caml_string_of_jsbytes("%+li"),
     _bl_=caml_string_of_jsbytes("% li"),
     _bm_=caml_string_of_jsbytes("%lx"),
     _bn_=caml_string_of_jsbytes("%#lx"),
     _bo_=caml_string_of_jsbytes("%lX"),
     _bp_=caml_string_of_jsbytes("%#lX"),
     _bq_=caml_string_of_jsbytes("%lo"),
     _br_=caml_string_of_jsbytes("%#lo"),
     _bs_=caml_string_of_jsbytes("%lu"),
     _a5_=caml_string_of_jsbytes("%Ld"),
     _a6_=caml_string_of_jsbytes("%+Ld"),
     _a7_=caml_string_of_jsbytes("% Ld"),
     _a8_=caml_string_of_jsbytes("%Li"),
     _a9_=caml_string_of_jsbytes("%+Li"),
     _a__=caml_string_of_jsbytes("% Li"),
     _a$_=caml_string_of_jsbytes("%Lx"),
     _ba_=caml_string_of_jsbytes("%#Lx"),
     _bb_=caml_string_of_jsbytes("%LX"),
     _bc_=caml_string_of_jsbytes("%#LX"),
     _bd_=caml_string_of_jsbytes("%Lo"),
     _be_=caml_string_of_jsbytes("%#Lo"),
     _bf_=caml_string_of_jsbytes("%Lu"),
     _aS_=caml_string_of_jsbytes("%d"),
     _aT_=caml_string_of_jsbytes("%+d"),
     _aU_=caml_string_of_jsbytes("% d"),
     _aV_=caml_string_of_jsbytes("%i"),
     _aW_=caml_string_of_jsbytes("%+i"),
     _aX_=caml_string_of_jsbytes("% i"),
     _aY_=caml_string_of_jsbytes("%x"),
     _aZ_=caml_string_of_jsbytes("%#x"),
     _a0_=caml_string_of_jsbytes("%X"),
     _a1_=caml_string_of_jsbytes("%#X"),
     _a2_=caml_string_of_jsbytes("%o"),
     _a3_=caml_string_of_jsbytes("%#o"),
     _a4_=caml_string_of_jsbytes("%u"),
     _ac_=caml_string_of_jsbytes("@]"),
     _ad_=caml_string_of_jsbytes("@}"),
     _ae_=caml_string_of_jsbytes("@?"),
     _af_=caml_string_of_jsbytes("@\n"),
     _ag_=caml_string_of_jsbytes("@."),
     _ah_=caml_string_of_jsbytes("@@"),
     _ai_=caml_string_of_jsbytes("@%"),
     _aj_=caml_string_of_jsbytes("@"),
     _aR_=caml_string_of_jsbytes("CamlinternalFormat.Type_mismatch"),
     _cH_=caml_string_of_jsbytes(""),
     _cI_=caml_string_of_jsbytes("\n"),
     _cF_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _cG_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _cv_=caml_string_of_jsbytes("a boolean"),
     _cw_=caml_string_of_jsbytes("an integer"),
     _cx_=caml_string_of_jsbytes("an integer"),
     _cy_=caml_string_of_jsbytes("a float"),
     _cz_=caml_string_of_jsbytes("a float"),
     _cA_=caml_string_of_jsbytes(""),
     _cB_=caml_string_of_jsbytes(" "),
     _cC_=caml_string_of_jsbytes(""),
     _cD_=caml_string_of_jsbytes("one of: "),
     _cE_=
      caml_string_of_jsbytes
       ("Arg.Expand is is only allowed with Arg.parse_and_expand_argv_dynamic"),
     _cu_=caml_string_of_jsbytes("no argument"),
     _ct_=caml_string_of_jsbytes("(?)"),
     _cl_=caml_string_of_jsbytes("--help"),
     _cm_=caml_string_of_jsbytes("-help"),
     _cn_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(": unknown option '"),
         [2,0,[11,caml_string_of_jsbytes("'.\n"),0]]]],
       caml_string_of_jsbytes("%s: unknown option '%s'.\n")],
     _cq_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(": wrong argument '"),
         [2,
          0,
          [11,
           caml_string_of_jsbytes("'; option '"),
           [2,
            0,
            [11,
             caml_string_of_jsbytes("' expects "),
             [2,0,[11,caml_string_of_jsbytes(".\n"),0]]]]]]]],
       caml_string_of_jsbytes
        ("%s: wrong argument '%s'; option '%s' expects %s.\n")],
     _cr_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(": option '"),
         [2,0,[11,caml_string_of_jsbytes("' needs an argument.\n"),0]]]],
       caml_string_of_jsbytes("%s: option '%s' needs an argument.\n")],
     _cs_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(": "),
         [2,0,[11,caml_string_of_jsbytes(".\n"),0]]]],
       caml_string_of_jsbytes("%s: %s.\n")],
     _co_=[0,caml_string_of_jsbytes("-help")],
     _cp_=[0,caml_string_of_jsbytes("--help")],
     _ck_=[0,[2,0,[12,10,0]],caml_string_of_jsbytes("%s\n")],
     _cj_=caml_string_of_jsbytes("-help"),
     _ce_=caml_string_of_jsbytes(" Display this list of options"),
     _cf_=caml_string_of_jsbytes("-help"),
     _ci_=caml_string_of_jsbytes("--help"),
     _cg_=caml_string_of_jsbytes(" Display this list of options"),
     _ch_=caml_string_of_jsbytes("--help"),
     _cd_=[0,caml_string_of_jsbytes("-help")],
     _b__=
      [0,
       [11,caml_string_of_jsbytes("  "),[2,0,[12,32,[2,0,[12,10,0]]]]],
       caml_string_of_jsbytes("  %s %s\n")],
     _b$_=caml_string_of_jsbytes("}"),
     _ca_=caml_string_of_jsbytes("|"),
     _cb_=caml_string_of_jsbytes("{"),
     _cc_=
      [0,
       [11,caml_string_of_jsbytes("  "),[2,0,[12,32,[2,0,[2,0,[12,10,0]]]]]],
       caml_string_of_jsbytes("  %s %s%s\n")],
     _b9_=caml_string_of_jsbytes("<none>"),
     _b6_=caml_string_of_jsbytes("Stdlib.Arg.Bad"),
     _b7_=caml_string_of_jsbytes("Stdlib.Arg.Help"),
     _b8_=caml_string_of_jsbytes("Stdlib.Arg.Stop"),
     _cJ_=caml_string_of_jsbytes("x"),
     _cN_=[0,0],
     _cM_=[0,caml_string_of_jsbytes("hashtbl.ml"),108,23],
     _BN_=caml_string_of_jsbytes("OCAMLRUNPARAM"),
     _BL_=caml_string_of_jsbytes("CAMLRUNPARAM"),
     _cK_=caml_string_of_jsbytes(""),
     _cV_=[3,0,3],
     _cW_=caml_string_of_jsbytes("."),
     _cT_=caml_string_of_jsbytes(">"),
     _cU_=caml_string_of_jsbytes("<\/"),
     _cR_=caml_string_of_jsbytes(">"),
     _cS_=caml_string_of_jsbytes("<"),
     _cQ_=caml_string_of_jsbytes("\n"),
     _cO_=caml_string_of_jsbytes("Stdlib.Format.Empty_queue"),
     _cP_=[0,caml_string_of_jsbytes("")],
     _c9_=[0,1,[0,3,[0,5,0]]],
     _c8_=[0,[2,0,[4,6,[0,2,6],0,[2,0,0]]],caml_string_of_jsbytes("%s%06x%s")],
     _c5_=caml_string_of_jsbytes(""),
     _c3_=caml_string_of_jsbytes("./"),
     _c2_=caml_string_of_jsbytes(".\\"),
     _c1_=caml_string_of_jsbytes("../"),
     _c0_=caml_string_of_jsbytes("..\\"),
     _cY_=caml_string_of_jsbytes(""),
     _cX_=caml_string_of_jsbytes(""),
     _BJ_=caml_string_of_jsbytes("TMPDIR"),
     _cZ_=caml_string_of_jsbytes("/tmp"),
     _BH_=caml_string_of_jsbytes("TEMP"),
     _c4_=caml_string_of_jsbytes("."),
     _c6_=caml_string_of_jsbytes("Cygwin"),
     _c7_=caml_string_of_jsbytes("Win32"),
     _c__=caml_string_of_jsbytes("Js_of_ocaml__Js.Error"),
     _c$_=caml_string_of_jsbytes("jsError"),
     _db_=caml_string_of_jsbytes("Worker.onmessage is undefined"),
     _da_=caml_string_of_jsbytes("Worker.onmessage is undefined"),
     _eu_=caml_string_of_jsbytes(""),
     _es_=[0,1],
     _et_=[0,1],
     _er_=caml_string_of_jsbytes("-c"),
     _eo_=[0,0],
     _ep_=[0,0],
     _eq_=[0,0],
     _dg_=caml_string_of_jsbytes("E2BIG"),
     _di_=caml_string_of_jsbytes("EACCES"),
     _dj_=caml_string_of_jsbytes("EAGAIN"),
     _dk_=caml_string_of_jsbytes("EBADF"),
     _dl_=caml_string_of_jsbytes("EBUSY"),
     _dm_=caml_string_of_jsbytes("ECHILD"),
     _dn_=caml_string_of_jsbytes("EDEADLK"),
     _do_=caml_string_of_jsbytes("EDOM"),
     _dp_=caml_string_of_jsbytes("EEXIST"),
     _dq_=caml_string_of_jsbytes("EFAULT"),
     _dr_=caml_string_of_jsbytes("EFBIG"),
     _ds_=caml_string_of_jsbytes("EINTR"),
     _dt_=caml_string_of_jsbytes("EINVAL"),
     _du_=caml_string_of_jsbytes("EIO"),
     _dv_=caml_string_of_jsbytes("EISDIR"),
     _dw_=caml_string_of_jsbytes("EMFILE"),
     _dx_=caml_string_of_jsbytes("EMLINK"),
     _dy_=caml_string_of_jsbytes("ENAMETOOLONG"),
     _dz_=caml_string_of_jsbytes("ENFILE"),
     _dA_=caml_string_of_jsbytes("ENODEV"),
     _dB_=caml_string_of_jsbytes("ENOENT"),
     _dC_=caml_string_of_jsbytes("ENOEXEC"),
     _dD_=caml_string_of_jsbytes("ENOLCK"),
     _dE_=caml_string_of_jsbytes("ENOMEM"),
     _dF_=caml_string_of_jsbytes("ENOSPC"),
     _dG_=caml_string_of_jsbytes("ENOSYS"),
     _dH_=caml_string_of_jsbytes("ENOTDIR"),
     _dI_=caml_string_of_jsbytes("ENOTEMPTY"),
     _dJ_=caml_string_of_jsbytes("ENOTTY"),
     _dK_=caml_string_of_jsbytes("ENXIO"),
     _dL_=caml_string_of_jsbytes("EPERM"),
     _dM_=caml_string_of_jsbytes("EPIPE"),
     _dN_=caml_string_of_jsbytes("ERANGE"),
     _dO_=caml_string_of_jsbytes("EROFS"),
     _dP_=caml_string_of_jsbytes("ESPIPE"),
     _dQ_=caml_string_of_jsbytes("ESRCH"),
     _dR_=caml_string_of_jsbytes("EXDEV"),
     _dS_=caml_string_of_jsbytes("EWOULDBLOCK"),
     _dT_=caml_string_of_jsbytes("EINPROGRESS"),
     _dU_=caml_string_of_jsbytes("EALREADY"),
     _dV_=caml_string_of_jsbytes("ENOTSOCK"),
     _dW_=caml_string_of_jsbytes("EDESTADDRREQ"),
     _dX_=caml_string_of_jsbytes("EMSGSIZE"),
     _dY_=caml_string_of_jsbytes("EPROTOTYPE"),
     _dZ_=caml_string_of_jsbytes("ENOPROTOOPT"),
     _d0_=caml_string_of_jsbytes("EPROTONOSUPPORT"),
     _d1_=caml_string_of_jsbytes("ESOCKTNOSUPPORT"),
     _d2_=caml_string_of_jsbytes("EOPNOTSUPP"),
     _d3_=caml_string_of_jsbytes("EPFNOSUPPORT"),
     _d4_=caml_string_of_jsbytes("EAFNOSUPPORT"),
     _d5_=caml_string_of_jsbytes("EADDRINUSE"),
     _d6_=caml_string_of_jsbytes("EADDRNOTAVAIL"),
     _d7_=caml_string_of_jsbytes("ENETDOWN"),
     _d8_=caml_string_of_jsbytes("ENETUNREACH"),
     _d9_=caml_string_of_jsbytes("ENETRESET"),
     _d__=caml_string_of_jsbytes("ECONNABORTED"),
     _d$_=caml_string_of_jsbytes("ECONNRESET"),
     _ea_=caml_string_of_jsbytes("ENOBUFS"),
     _eb_=caml_string_of_jsbytes("EISCONN"),
     _ec_=caml_string_of_jsbytes("ENOTCONN"),
     _ed_=caml_string_of_jsbytes("ESHUTDOWN"),
     _ee_=caml_string_of_jsbytes("ETOOMANYREFS"),
     _ef_=caml_string_of_jsbytes("ETIMEDOUT"),
     _eg_=caml_string_of_jsbytes("ECONNREFUSED"),
     _eh_=caml_string_of_jsbytes("EHOSTDOWN"),
     _ei_=caml_string_of_jsbytes("EHOSTUNREACH"),
     _ej_=caml_string_of_jsbytes("ELOOP"),
     _ek_=caml_string_of_jsbytes("EOVERFLOW"),
     _el_=
      [0,
       [11,caml_string_of_jsbytes("EUNKNOWNERR "),[4,0,0,0,0]],
       caml_string_of_jsbytes("EUNKNOWNERR %d")],
     _dh_=
      [0,
       [11,
        caml_string_of_jsbytes("Unix.Unix_error(Unix."),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(", "),
          [3,0,[11,caml_string_of_jsbytes(", "),[3,0,[12,41,0]]]]]]],
       caml_string_of_jsbytes("Unix.Unix_error(Unix.%s, %S, %S)")],
     _dc_=caml_string_of_jsbytes("Unix.Unix_error"),
     _dd_=caml_string_of_jsbytes(""),
     _de_=caml_string_of_jsbytes(""),
     _df_=caml_string_of_jsbytes("Unix.Unix_error"),
     _em_=caml_string_of_jsbytes("0.0.0.0"),
     _en_=caml_string_of_jsbytes("127.0.0.1"),
     _BF_=caml_string_of_jsbytes("::"),
     _BE_=caml_string_of_jsbytes("::1"),
     _ev_=caml_string_of_jsbytes(""),
     _ew_=caml_string_of_jsbytes(""),
     _eH_=caml_string_of_jsbytes(""),
     _eG_=caml_string_of_jsbytes("Str.matched_group"),
     _eF_=caml_string_of_jsbytes("Str.group_end"),
     _eA_=[0,92],
     _eC_=caml_string_of_jsbytes("\\( group not closed by \\)"),
     _eB_=[0,caml_string_of_jsbytes("str.ml"),520,10],
     _eD_=caml_string_of_jsbytes("[ class not closed by ]"),
     _eE_=caml_string_of_jsbytes("spurious \\) in regular expression"),
     _ey_=caml_string_of_jsbytes("too many r* or r+ where r is nullable"),
     _ez_=caml_string_of_jsbytes(""),
     _ex_=[0,caml_string_of_jsbytes("str.ml"),213,11],
     _eN_=caml_string_of_jsbytes("invalid digit"),
     _eM_=caml_string_of_jsbytes("number too long"),
     _eL_=caml_string_of_jsbytes("power_base_int"),
     _eK_=caml_string_of_jsbytes("nat_of_int"),
     _eJ_=caml_string_of_jsbytes("int_of_nat"),
     _eI_=caml_string_of_jsbytes("make_nat"),
     _fb_=[0,caml_string_of_jsbytes("big_int.ml"),879,2],
     _fa_=caml_int64_create_lo_mi_hi(1,0,0),
     _e$_=caml_string_of_jsbytes("and_big_int"),
     _e__=caml_string_of_jsbytes("shift_right_big_int"),
     _e9_=caml_string_of_jsbytes("two_power_m1_big_int"),
     _e8_=caml_string_of_jsbytes("shift_right_towards_zero_big_int"),
     _e7_=caml_string_of_jsbytes("shift_left_big_int"),
     _e6_=caml_string_of_jsbytes("power_big_int_positive_big_int"),
     _e5_=caml_string_of_jsbytes("power_int_positive_big_int"),
     _e4_=caml_string_of_jsbytes("power_big_int_positive_int"),
     _e3_=caml_string_of_jsbytes("power_int_positive_int"),
     _e2_=caml_string_of_jsbytes("sys_big_int_of_string"),
     _e1_=caml_string_of_jsbytes("sys_big_int_of_string"),
     _e0_=caml_string_of_jsbytes("sys_big_int_of_string"),
     _eZ_=caml_string_of_jsbytes("-"),
     _eY_=caml_string_of_jsbytes("int64_of_big_int"),
     _eX_=caml_int64_create_lo_mi_hi(16777215,255,0),
     _eS_=caml_int64_create_lo_mi_hi(16777215,255,0),
     _eT_=caml_int64_create_lo_mi_hi(0,0,0),
     _eU_=caml_string_of_jsbytes("int64_of_big_int"),
     _eV_=caml_int64_create_lo_mi_hi(0,0,0),
     _eW_=caml_string_of_jsbytes("int64_of_big_int"),
     _eP_=caml_int64_create_lo_mi_hi(0,0,0),
     _eQ_=caml_int64_create_lo_mi_hi(0,0,0),
     _eR_=caml_int64_create_lo_mi_hi(0,0,0),
     _eO_=caml_string_of_jsbytes("int_of_big_int"),
     _fl_=[0,caml_string_of_jsbytes("ratio.ml"),575,11],
     _fk_=caml_string_of_jsbytes("/"),
     _fj_=caml_string_of_jsbytes("big_int_of_ratio"),
     _fi_=caml_string_of_jsbytes("integer argument required"),
     _fh_=caml_string_of_jsbytes("integer_ratio"),
     _fg_=caml_string_of_jsbytes("inverse_ratio"),
     _ff_=caml_string_of_jsbytes("create_normalized_ratio"),
     _fe_=caml_string_of_jsbytes("create_ratio"),
     _fd_=caml_string_of_jsbytes(""),
     _fc_=caml_string_of_jsbytes(" "),
     _ft_=caml_string_of_jsbytes("num_of_string"),
     _fs_=caml_string_of_jsbytes("power_num"),
     _fp_=[0,1],
     _fq_=[0,1],
     _fr_=[0,1],
     _fm_=[0,1],
     _fn_=[0,1],
     _fo_=[0,1],
     _gI_=caml_string_of_jsbytes("cos_i: Not implemented"),
     _gG_=caml_string_of_jsbytes("sin_i: Not implemented"),
     _gw_=[254,0.,0.],
     _f9_=[0,caml_string_of_jsbytes("interval2.ml"),236,2],
     _f7_=[0,caml_string_of_jsbytes("interval2.ml"),228,2],
     _fV_=[0,caml_string_of_jsbytes("interval2.ml"),112,2],
     _fU_=[0,2],
     _fS_=[0,caml_string_of_jsbytes("interval2.ml"),98,2],
     _fR_=[0,2],
     _fN_=[0,1],
     _fO_=[0,1],
     _fP_=[0,2],
     _fF_=[0,0],
     _fG_=[0,2],
     _fH_=
      [0,
       [11,caml_string_of_jsbytes("num_of_float: "),[8,3,0,0,0]],
       caml_string_of_jsbytes("num_of_float: %e")],
     _BC_=[0,caml_string_of_jsbytes("interval2.ml"),27,8],
     _BB_=[0,caml_string_of_jsbytes("interval2.ml"),28,8],
     _BA_=[0,caml_string_of_jsbytes("interval2.ml"),29,8],
     _Bz_=[0,caml_string_of_jsbytes("interval2.ml"),30,8],
     _g1_=caml_string_of_jsbytes("tanh_I: Not implemented"),
     _gZ_=caml_string_of_jsbytes("cosh_I: Not implemented"),
     _gX_=caml_string_of_jsbytes("sinh_I: Not implemented"),
     _gV_=caml_string_of_jsbytes("atan_I: Not implemented"),
     _gT_=caml_string_of_jsbytes("acos_I: Not implemented"),
     _gR_=caml_string_of_jsbytes("asin_I: Not implemented"),
     _gP_=caml_string_of_jsbytes("tan_I: Not implemented"),
     _gN_=caml_string_of_jsbytes("(**$.): Not implemented"),
     _gK_=
      [0,
       [12,91,[2,0,[11,caml_string_of_jsbytes(", "),[2,0,[12,93,0]]]]],
       caml_string_of_jsbytes("[%s, %s]")],
     _g3_=caml_string_of_jsbytes("zip"),
     _g4_=[0,0,0],
     _g7_=caml_string_of_jsbytes(""),
     _g8_=caml_string_of_jsbytes(":"),
     _g9_=caml_string_of_jsbytes(""),
     _g__=caml_string_of_jsbytes("make_path: "),
     _g6_=caml_string_of_jsbytes(""),
     _g5_=caml_string_of_jsbytes("option_value: None"),
     _g$_=caml_string_of_jsbytes("tmp"),
     _hb_=caml_string_of_jsbytes("atanh_I"),
     _ha_=caml_string_of_jsbytes("acosh_I"),
     _hf_=caml_string_of_jsbytes("**ERROR**: "),
     _he_=caml_string_of_jsbytes("**WARNING**: "),
     _hd_=caml_string_of_jsbytes("log"),
     _hc_=
      [0,
       [11,
        caml_string_of_jsbytes("**ERROR** ("),
        [2,
         0,
         [11,
          caml_string_of_jsbytes("): Cannot open a log file ("),
          [2,
           0,
           [11,
            caml_string_of_jsbytes
             ("). Make sure that there is no file named '"),
            [2,
             0,
             [11,caml_string_of_jsbytes("' in the current directory.\n"),0]]]]]]],
       caml_string_of_jsbytes
        ("**ERROR** (%s): Cannot open a log file (%s). Make sure that there is no file named '%s' in the current directory.\n")],
     _h2_=[0,0],
     _h3_=caml_string_of_jsbytes("default.cfg"),
     _h7_=caml_string_of_jsbytes("filename Load options from a file."),
     _h8_=caml_string_of_jsbytes("-c"),
     _h9_=
      caml_string_of_jsbytes("filename Exports tasks to the FPCore format"),
     _h__=caml_string_of_jsbytes("fpcore-out"),
     _h$_=[0,1],
     _ia_=caml_string_of_jsbytes("--fpcore-out"),
     _ib_=[0,1],
     _h6_=
      [0,
       [11,caml_string_of_jsbytes("Cannot open default.cfg: "),[2,0,0]],
       caml_string_of_jsbytes("Cannot open default.cfg: %s")],
     _h4_=caml_string_of_jsbytes("verbosity"),
     _h5_=
      [0,
       [11,caml_string_of_jsbytes("verbosity < 0: "),[4,0,0,0,0]],
       caml_string_of_jsbytes("verbosity < 0: %d")],
     _h1_=caml_string_of_jsbytes(""),
     _hZ_=caml_string_of_jsbytes("FPTAYLOR_BASE"),
     _h0_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("***** The environment variable FPTAYLOR_BASE is defined = '"),
        [2,0,[12,39,0]]],
       caml_string_of_jsbytes
        ("***** The environment variable FPTAYLOR_BASE is defined = '%s'")],
     _hY_=caml_string_of_jsbytes("fail-on-exception"),
     _hX_=caml_string_of_jsbytes("proof-record"),
     _hW_=caml_string_of_jsbytes("debug"),
     _hV_=caml_string_of_jsbytes("??"),
     _hU_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("Cannot convert a string into a floating-point value: "),
        [2,0,[11,caml_string_of_jsbytes(" (parameter = "),[2,0,[12,41,0]]]]],
       caml_string_of_jsbytes
        ("Cannot convert a string into a floating-point value: %s (parameter = %s)")],
     _hT_=caml_string_of_jsbytes("??"),
     _hS_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("Cannot convert a string into an integer value: "),
        [2,0,[11,caml_string_of_jsbytes(" (parameter = "),[2,0,[12,41,0]]]]],
       caml_string_of_jsbytes
        ("Cannot convert a string into an integer value: %s (parameter = %s)")],
     _hR_=caml_string_of_jsbytes("??"),
     _hQ_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("Cannot convert a string into a boolean value: "),
        [2,0,[11,caml_string_of_jsbytes(" (parameter = "),[2,0,[12,41,0]]]]],
       caml_string_of_jsbytes
        ("Cannot convert a string into a boolean value: %s (parameter = %s)")],
     _hN_=
      [0,
       [2,0,[11,caml_string_of_jsbytes(" = "),[2,0,0]]],
       caml_string_of_jsbytes("%s = %s")],
     _hO_=
      [0,
       [11,caml_string_of_jsbytes("Base path: "),[2,0,0]],
       caml_string_of_jsbytes("Base path: %s")],
     _hP_=
      [0,
       [11,caml_string_of_jsbytes("Config file: "),[2,0,0]],
       caml_string_of_jsbytes("Config file: %s")],
     _hL_=caml_string_of_jsbytes("export-options"),
     _hM_=
      [0,
       [2,0,[11,caml_string_of_jsbytes(" = "),[2,0,[12,10,0]]]],
       caml_string_of_jsbytes("%s = %s\n")],
     _hF_=caml_string_of_jsbytes(""),
     _hG_=caml_string_of_jsbytes("##"),
     _hH_=caml_string_of_jsbytes("["),
     _hI_=caml_string_of_jsbytes(""),
     _hJ_=caml_string_of_jsbytes(""),
     _hE_=caml_string_of_jsbytes(""),
     _hC_=
      [0,
       [11,
        caml_string_of_jsbytes("[File "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(", line "),
          [4,
           0,
           0,
           0,
           [11,caml_string_of_jsbytes("] Parameter parsing error: "),[2,0,0]]]]]],
       caml_string_of_jsbytes
        ("[File %s, line %d] Parameter parsing error: %s")],
     _hD_=caml_string_of_jsbytes("Error while parsing a configuration file: "),
     _hu_=caml_string_of_jsbytes(""),
     _hv_=caml_string_of_jsbytes(")"),
     _hw_=caml_string_of_jsbytes("(-"),
     _hB_=caml_string_of_jsbytes(""),
     _hx_=caml_string_of_jsbytes("--"),
     _hy_=caml_string_of_jsbytes(""),
     _hz_=caml_string_of_jsbytes(""),
     _hA_=caml_string_of_jsbytes("-"),
     _hp_=
      [0,
       [11,caml_string_of_jsbytes("Loading configuration file: "),[2,0,0]],
       caml_string_of_jsbytes("Loading configuration file: %s")],
     _hq_=caml_string_of_jsbytes(""),
     _hr_=caml_string_of_jsbytes(""),
     _hs_=caml_string_of_jsbytes("="),
     _ht_=
      caml_string_of_jsbytes("^\\[short:[ \t]*\\([a-zA-Z][a-zA-Z0-9]*\\)\\]$"),
     _hK_=caml_string_of_jsbytes("Cannot open a configuration file: "),
     _hn_=caml_string_of_jsbytes(""),
     _hk_=caml_string_of_jsbytes(""),
     _hl_=
      [0,
       [11,
        caml_string_of_jsbytes("Short name '"),
        [2,
         0,
         [11,
          caml_string_of_jsbytes("' is already used for '"),
          [2,
           0,
           [11,
            caml_string_of_jsbytes("' (new option name = '"),
            [2,0,[11,caml_string_of_jsbytes("')"),0]]]]]]],
       caml_string_of_jsbytes
        ("Short name '%s' is already used for '%s' (new option name = '%s')")],
     _hm_=
      [0,
       [11,
        caml_string_of_jsbytes("Unknown option: "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(" = "),
          [2,
           0,
           [11,
            caml_string_of_jsbytes(" (see available options in default.cfg)"),
            0]]]]],
       caml_string_of_jsbytes
        ("Unknown option: %s = %s (see available options in default.cfg)")],
     _hj_=caml_string_of_jsbytes("Unknown option: "),
     _hh_=
      [0,
       [11,
        caml_string_of_jsbytes("\nUsage: "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes
           (" [--opt_name opt_value ...] [-c config1 ...] input_file1 [input_file2 ...]\n\nSee default.cfg for a complete list of available options and their values.\n"),
          0]]],
       caml_string_of_jsbytes
        ("\nUsage: %s [--opt_name opt_value ...] [-c config1 ...] input_file1 [input_file2 ...]\n\nSee default.cfg for a complete list of available options and their values.\n")],
     _hi_=caml_string_of_jsbytes(""),
     _ho_=caml_string_of_jsbytes("^[ \t]*[\\*#].*"),
     _iR_=caml_string_of_jsbytes(""),
     _iP_=caml_string_of_jsbytes("NaN"),
     _iQ_=caml_string_of_jsbytes(""),
     _iO_=caml_string_of_jsbytes("Overflow"),
     _iN_=[0,caml_string_of_jsbytes("more_num.ml"),303,2],
     _iM_=[0,2],
     _iL_=[0,caml_string_of_jsbytes("more_num.ml"),289,2],
     _iK_=[0,2],
     _iH_=[0,1],
     _iI_=[0,1],
     _iJ_=[0,2],
     _iG_=[0,0],
     _iC_=caml_string_of_jsbytes("0.0"),
     _iD_=caml_string_of_jsbytes("+inf"),
     _iE_=caml_string_of_jsbytes("-inf"),
     _iF_=caml_string_of_jsbytes("nan"),
     _iB_=caml_string_of_jsbytes("-"),
     _ix_=caml_string_of_jsbytes("0.0"),
     _iy_=caml_string_of_jsbytes("+inf"),
     _iz_=caml_string_of_jsbytes("-inf"),
     _iA_=caml_string_of_jsbytes("nan"),
     _iw_=caml_string_of_jsbytes("-"),
     _iv_=[0,caml_string_of_jsbytes("more_num.ml"),156,2],
     _is_=caml_string_of_jsbytes("."),
     _it_=caml_string_of_jsbytes("e+"),
     _iu_=caml_string_of_jsbytes("e"),
     _ir_=[0,caml_string_of_jsbytes("more_num.ml"),120,2],
     _io_=caml_string_of_jsbytes("."),
     _ip_=caml_string_of_jsbytes("e+"),
     _iq_=caml_string_of_jsbytes("e"),
     _il_=
      [0,
       [11,caml_string_of_jsbytes("num_of_float: "),[8,3,0,0,0]],
       caml_string_of_jsbytes("num_of_float: %e")],
     _im_=[0,0],
     _in_=[0,2],
     _ik_=[0,0],
     _ii_=caml_string_of_jsbytes("0x"),
     _ij_=caml_string_of_jsbytes("-0x"),
     _ih_=
      caml_string_of_jsbytes
       ("Fractional part is not allowed for the given base"),
     _ie_=caml_string_of_jsbytes(""),
     _if_=caml_string_of_jsbytes(""),
     _ig_=caml_string_of_jsbytes("0"),
     _id_=caml_string_of_jsbytes(""),
     _ic_=
      caml_string_of_jsbytes
       ("num_of_gen_float: the exponent is out of bounds"),
     _j7_=
      [0,
       [11,
        caml_string_of_jsbytes("rnd["),
        [4,
         0,
         0,
         0,
         [12,
          44,
          [2,
           0,
           [12,44,[8,0,0,[0,2],[12,44,[4,0,0,0,[12,44,[4,0,0,0,partial]]]]]]]]]],
       caml_string_of_jsbytes("rnd[%d,%s,%.2f,%d,%d]")],
     _j3_=caml_string_of_jsbytes("ne"),
     _j4_=caml_string_of_jsbytes("up"),
     _j5_=caml_string_of_jsbytes("down"),
     _j6_=caml_string_of_jsbytes("zero"),
     _j1_=caml_string_of_jsbytes(" is not defined"),
     _j2_=caml_string_of_jsbytes("Rounding mode "),
     _i5_=caml_string_of_jsbytes("down"),
     _i6_=caml_string_of_jsbytes("ne"),
     _i7_=caml_string_of_jsbytes("nearest"),
     _i8_=caml_string_of_jsbytes("negative_infinity"),
     _i9_=caml_string_of_jsbytes("positive_infinity"),
     _i__=caml_string_of_jsbytes("toward_zero"),
     _i$_=caml_string_of_jsbytes("up"),
     _ja_=caml_string_of_jsbytes("zero"),
     _jb_=caml_string_of_jsbytes("Unknown rounding type: "),
     _jf_=[0,0,0],
     _je_=[0,1,2],
     _jd_=[0,1,1],
     _jc_=[0,1,3],
     _i4_=caml_string_of_jsbytes("max_value_from_bits: Unsupported fp size: "),
     _i1_=[0,-24,-126],
     _iZ_=[0,-113,-16382],
     _iY_=[0,-53,-1022],
     _i3_=[0,-11,-14],
     _i2_=[0,0,0],
     _i0_=caml_string_of_jsbytes("Unsupported fp size: "),
     _iS_=caml_string_of_jsbytes("float128"),
     _iT_=caml_string_of_jsbytes("float16"),
     _iU_=caml_string_of_jsbytes("float32"),
     _iV_=caml_string_of_jsbytes("float64"),
     _iW_=caml_string_of_jsbytes("real"),
     _iX_=caml_string_of_jsbytes("Unknown type: "),
     _jg_=caml_string_of_jsbytes("zero"),
     _jh_=caml_string_of_jsbytes("rnd128_0"),
     _jj_=caml_string_of_jsbytes("down"),
     _jk_=caml_string_of_jsbytes("rnd128_down"),
     _jm_=caml_string_of_jsbytes("up"),
     _jn_=caml_string_of_jsbytes("rnd128_up"),
     _jp_=caml_string_of_jsbytes("ne"),
     _jq_=caml_string_of_jsbytes("rnd128"),
     _js_=caml_string_of_jsbytes("zero"),
     _jt_=caml_string_of_jsbytes("rnd64_0"),
     _jv_=caml_string_of_jsbytes("down"),
     _jw_=caml_string_of_jsbytes("rnd64_down"),
     _jy_=caml_string_of_jsbytes("up"),
     _jz_=caml_string_of_jsbytes("rnd64_up"),
     _jB_=caml_string_of_jsbytes("ne"),
     _jC_=caml_string_of_jsbytes("rnd64"),
     _jE_=caml_string_of_jsbytes("zero"),
     _jF_=caml_string_of_jsbytes("rnd32_0"),
     _jH_=caml_string_of_jsbytes("down"),
     _jI_=caml_string_of_jsbytes("rnd32_down"),
     _jK_=caml_string_of_jsbytes("up"),
     _jL_=caml_string_of_jsbytes("rnd32_up"),
     _jN_=caml_string_of_jsbytes("ne"),
     _jO_=caml_string_of_jsbytes("rnd32"),
     _jQ_=caml_string_of_jsbytes("zero"),
     _jR_=caml_string_of_jsbytes("rnd16_0"),
     _jT_=caml_string_of_jsbytes("down"),
     _jU_=caml_string_of_jsbytes("rnd16_down"),
     _jW_=caml_string_of_jsbytes("up"),
     _jX_=caml_string_of_jsbytes("rnd16_up"),
     _jZ_=caml_string_of_jsbytes("ne"),
     _j0_=caml_string_of_jsbytes("rnd16"),
     _kc_=[0,2],
     _ka_=[0,2],
     _kb_=[0,2],
     _kd_=[0,caml_string_of_jsbytes("binary_float.ml"),56,10],
     _j__=[0,2],
     _j$_=[0,1],
     _j9_=[0,2],
     _kg_=caml_string_of_jsbytes("Const.to_num: interval constant"),
     _ke_=[0,[8,3,0,[0,20],0],caml_string_of_jsbytes("%.20e")],
     _kf_=caml_string_of_jsbytes("Const.of_interval: bad argument: "),
     _kP_=caml_string_of_jsbytes("Impossible"),
     _kO_=caml_string_of_jsbytes("ref~"),
     _kN_=caml_string_of_jsbytes("ref_var_index: not a reference"),
     _kM_=caml_string_of_jsbytes("ref~"),
     _kL_=caml_string_of_jsbytes("ref~"),
     _kK_=caml_string_of_jsbytes("ulp"),
     _kJ_=caml_string_of_jsbytes("fma"),
     _kA_=caml_string_of_jsbytes("max"),
     _kB_=caml_string_of_jsbytes("min"),
     _kC_=caml_string_of_jsbytes("+"),
     _kD_=caml_string_of_jsbytes("-"),
     _kE_=caml_string_of_jsbytes("*"),
     _kF_=caml_string_of_jsbytes("/"),
     _kG_=caml_string_of_jsbytes("^"),
     _kH_=caml_string_of_jsbytes("sub2"),
     _kI_=caml_string_of_jsbytes("abs_err"),
     _kh_=caml_string_of_jsbytes("neg"),
     _ki_=caml_string_of_jsbytes("abs"),
     _kj_=caml_string_of_jsbytes("inv"),
     _kk_=caml_string_of_jsbytes("sqrt"),
     _kl_=caml_string_of_jsbytes("sin"),
     _km_=caml_string_of_jsbytes("cos"),
     _kn_=caml_string_of_jsbytes("tan"),
     _ko_=caml_string_of_jsbytes("asin"),
     _kp_=caml_string_of_jsbytes("acos"),
     _kq_=caml_string_of_jsbytes("atan"),
     _kr_=caml_string_of_jsbytes("exp"),
     _ks_=caml_string_of_jsbytes("log"),
     _kt_=caml_string_of_jsbytes("sinh"),
     _ku_=caml_string_of_jsbytes("cosh"),
     _kv_=caml_string_of_jsbytes("tanh"),
     _kw_=caml_string_of_jsbytes("asinh"),
     _kx_=caml_string_of_jsbytes("acosh"),
     _ky_=caml_string_of_jsbytes("atanh"),
     _kz_=caml_string_of_jsbytes("floor_power2"),
     _nj_=
      [0,
       [12,
        91,
        [8,
         3,
         0,
         [0,20],
         [11,caml_string_of_jsbytes(", "),[8,3,0,[0,20],[12,93,0]]]]],
       caml_string_of_jsbytes("[%.20e, %.20e]")],
     _nk_=
      [0,
       [11,caml_string_of_jsbytes("var_"),[2,0,0]],
       caml_string_of_jsbytes("var_%s")],
     _nl_=caml_string_of_jsbytes("Gelpia: rounding is not allowed: "),
     _nm_=
      [0,
       [11,
        caml_string_of_jsbytes("(-("),
        [15,[11,caml_string_of_jsbytes("))"),0]]],
       caml_string_of_jsbytes("(-(%a))")],
     _nn_=
      [0,
       [11,caml_string_of_jsbytes("abs("),[15,[12,41,0]]],
       caml_string_of_jsbytes("abs(%a)")],
     _no_=
      [0,
       [11,caml_string_of_jsbytes("inv("),[15,[12,41,0]]],
       caml_string_of_jsbytes("inv(%a)")],
     _np_=
      [0,
       [11,caml_string_of_jsbytes("sqrt("),[15,[12,41,0]]],
       caml_string_of_jsbytes("sqrt(%a)")],
     _nq_=
      [0,
       [11,caml_string_of_jsbytes("sin("),[15,[12,41,0]]],
       caml_string_of_jsbytes("sin(%a)")],
     _nr_=
      [0,
       [11,caml_string_of_jsbytes("cos("),[15,[12,41,0]]],
       caml_string_of_jsbytes("cos(%a)")],
     _ns_=
      [0,
       [11,caml_string_of_jsbytes("tan("),[15,[12,41,0]]],
       caml_string_of_jsbytes("tan(%a)")],
     _nt_=
      [0,
       [11,caml_string_of_jsbytes("asin("),[15,[12,41,0]]],
       caml_string_of_jsbytes("asin(%a)")],
     _nu_=
      [0,
       [11,caml_string_of_jsbytes("acos("),[15,[12,41,0]]],
       caml_string_of_jsbytes("acos(%a)")],
     _nv_=
      [0,
       [11,caml_string_of_jsbytes("atan("),[15,[12,41,0]]],
       caml_string_of_jsbytes("atan(%a)")],
     _nw_=
      [0,
       [11,caml_string_of_jsbytes("exp("),[15,[12,41,0]]],
       caml_string_of_jsbytes("exp(%a)")],
     _nx_=
      [0,
       [11,caml_string_of_jsbytes("log("),[15,[12,41,0]]],
       caml_string_of_jsbytes("log(%a)")],
     _ny_=
      [0,
       [11,caml_string_of_jsbytes("sinh("),[15,[12,41,0]]],
       caml_string_of_jsbytes("sinh(%a)")],
     _nz_=
      [0,
       [11,caml_string_of_jsbytes("cosh("),[15,[12,41,0]]],
       caml_string_of_jsbytes("cosh(%a)")],
     _nA_=
      [0,
       [11,caml_string_of_jsbytes("tanh("),[15,[12,41,0]]],
       caml_string_of_jsbytes("tanh(%a)")],
     _nB_=
      [0,
       [11,caml_string_of_jsbytes("asinh("),[15,[12,41,0]]],
       caml_string_of_jsbytes("asinh(%a)")],
     _nC_=
      [0,
       [11,caml_string_of_jsbytes("acosh("),[15,[12,41,0]]],
       caml_string_of_jsbytes("acosh(%a)")],
     _nD_=
      [0,
       [11,caml_string_of_jsbytes("atanh("),[15,[12,41,0]]],
       caml_string_of_jsbytes("atanh(%a)")],
     _nE_=
      [0,
       [11,caml_string_of_jsbytes("floor_power2("),[15,[12,41,0]]],
       caml_string_of_jsbytes("floor_power2(%a)")],
     _nF_=
      [0,
       [11,
        caml_string_of_jsbytes("max("),
        [15,[11,caml_string_of_jsbytes(", "),[15,[12,41,0]]]]],
       caml_string_of_jsbytes("max(%a, %a)")],
     _nG_=
      [0,
       [11,
        caml_string_of_jsbytes("min("),
        [15,[11,caml_string_of_jsbytes(", "),[15,[12,41,0]]]]],
       caml_string_of_jsbytes("min(%a, %a)")],
     _nH_=
      [0,
       [12,40,[15,[11,caml_string_of_jsbytes(" + "),[15,[12,41,0]]]]],
       caml_string_of_jsbytes("(%a + %a)")],
     _nI_=
      [0,
       [12,40,[15,[11,caml_string_of_jsbytes(" - "),[15,[12,41,0]]]]],
       caml_string_of_jsbytes("(%a - %a)")],
     _nJ_=
      [0,
       [12,40,[15,[11,caml_string_of_jsbytes(" * "),[15,[12,41,0]]]]],
       caml_string_of_jsbytes("(%a * %a)")],
     _nK_=
      [0,
       [12,40,[15,[11,caml_string_of_jsbytes(" / "),[15,[12,41,0]]]]],
       caml_string_of_jsbytes("(%a / %a)")],
     _nL_=
      [0,
       [11,
        caml_string_of_jsbytes("pow("),
        [15,[11,caml_string_of_jsbytes(", "),[2,0,[12,41,0]]]]],
       caml_string_of_jsbytes("pow(%a, %s)")],
     _nM_=caml_string_of_jsbytes("Gelpia: Op_nat_pow: non-integer exponent"),
     _nN_=
      [0,
       [11,
        caml_string_of_jsbytes("sub2("),
        [15,[11,caml_string_of_jsbytes(", "),[15,[12,41,0]]]]],
       caml_string_of_jsbytes("sub2(%a, %a)")],
     _nO_=
      [0,
       [11,
        caml_string_of_jsbytes("abs_err("),
        [15,[11,caml_string_of_jsbytes(", "),[15,[12,41,0]]]]],
       caml_string_of_jsbytes("abs_err(%a, %a)")],
     _nP_=caml_string_of_jsbytes("Gelpia: unknown general operation: "),
     _m2_=
      [0,
       [11,
        caml_string_of_jsbytes("Q("),
        [2,0,[11,caml_string_of_jsbytes(", "),[2,0,[12,41,0]]]]],
       caml_string_of_jsbytes("Q(%s, %s)")],
     _m3_=
      caml_string_of_jsbytes("Z3Python: interval constants are not supported"),
     _m4_=
      [0,
       [11,caml_string_of_jsbytes("var_"),[2,0,0]],
       caml_string_of_jsbytes("var_%s")],
     _m5_=caml_string_of_jsbytes("Z3Python: rounding is not allowed: "),
     _m6_=caml_string_of_jsbytes("Z3Python: unknown unary operation: "),
     _m7_=
      [0,
       [11,
        caml_string_of_jsbytes("(-("),
        [15,[11,caml_string_of_jsbytes("))"),0]]],
       caml_string_of_jsbytes("(-(%a))")],
     _m8_=
      [0,
       [11,caml_string_of_jsbytes("z3_abs("),[15,[12,41,0]]],
       caml_string_of_jsbytes("z3_abs(%a)")],
     _m9_=
      [0,
       [11,caml_string_of_jsbytes("inv("),[15,[12,41,0]]],
       caml_string_of_jsbytes("inv(%a)")],
     _m__=
      [0,
       [11,caml_string_of_jsbytes("sqrt("),[15,[12,41,0]]],
       caml_string_of_jsbytes("sqrt(%a)")],
     _m$_=
      [0,
       [11,
        caml_string_of_jsbytes("z3_max("),
        [15,[11,caml_string_of_jsbytes(", "),[15,[12,41,0]]]]],
       caml_string_of_jsbytes("z3_max(%a, %a)")],
     _na_=
      [0,
       [11,
        caml_string_of_jsbytes("z3_min("),
        [15,[11,caml_string_of_jsbytes(", "),[15,[12,41,0]]]]],
       caml_string_of_jsbytes("z3_min(%a, %a)")],
     _nb_=
      [0,
       [12,40,[15,[11,caml_string_of_jsbytes(" + "),[15,[12,41,0]]]]],
       caml_string_of_jsbytes("(%a + %a)")],
     _nc_=
      [0,
       [12,40,[15,[11,caml_string_of_jsbytes(" - "),[15,[12,41,0]]]]],
       caml_string_of_jsbytes("(%a - %a)")],
     _nd_=
      [0,
       [12,40,[15,[11,caml_string_of_jsbytes(" * "),[15,[12,41,0]]]]],
       caml_string_of_jsbytes("(%a * %a)")],
     _ne_=
      [0,
       [12,40,[15,[11,caml_string_of_jsbytes(" / "),[15,[12,41,0]]]]],
       caml_string_of_jsbytes("(%a / %a)")],
     _nf_=
      [0,
       [12,40,[15,[11,caml_string_of_jsbytes(" ** "),[15,[12,41,0]]]]],
       caml_string_of_jsbytes("(%a ** %a)")],
     _ng_=caml_string_of_jsbytes("Z3Python: unknown binary operation: "),
     _ni_=
      [0,
       [12,
        40,
        [15,
         [11,
          caml_string_of_jsbytes(" * "),
          [15,[11,caml_string_of_jsbytes(" + "),[15,[12,41,0]]]]]]],
       caml_string_of_jsbytes("(%a * %a + %a)")],
     _nh_=caml_string_of_jsbytes("Z3Python: unknown general operation: "),
     _mv_=
      [0,[12,40,[8,3,0,[0,20],[12,41,0]]],caml_string_of_jsbytes("(%.20e)")],
     _mw_=
      [0,
       [11,caml_string_of_jsbytes("var_"),[2,0,0]],
       caml_string_of_jsbytes("var_%s")],
     _mx_=[0,[2,0,[12,40,[15,[12,41,0]]]],caml_string_of_jsbytes("%s(%a)")],
     _my_=
      [0,
       [11,
        caml_string_of_jsbytes("(-("),
        [15,[11,caml_string_of_jsbytes("))"),0]]],
       caml_string_of_jsbytes("(-(%a))")],
     _mz_=
      [0,
       [11,caml_string_of_jsbytes("fabs("),[15,[12,41,0]]],
       caml_string_of_jsbytes("fabs(%a)")],
     _mA_=
      [0,
       [11,caml_string_of_jsbytes("inv("),[15,[12,41,0]]],
       caml_string_of_jsbytes("inv(%a)")],
     _mB_=
      [0,
       [11,caml_string_of_jsbytes("sqrt("),[15,[12,41,0]]],
       caml_string_of_jsbytes("sqrt(%a)")],
     _mC_=
      [0,
       [11,caml_string_of_jsbytes("sin("),[15,[12,41,0]]],
       caml_string_of_jsbytes("sin(%a)")],
     _mD_=
      [0,
       [11,caml_string_of_jsbytes("cos("),[15,[12,41,0]]],
       caml_string_of_jsbytes("cos(%a)")],
     _mE_=
      [0,
       [11,caml_string_of_jsbytes("tan("),[15,[12,41,0]]],
       caml_string_of_jsbytes("tan(%a)")],
     _mF_=
      [0,
       [11,caml_string_of_jsbytes("asin("),[15,[12,41,0]]],
       caml_string_of_jsbytes("asin(%a)")],
     _mG_=
      [0,
       [11,caml_string_of_jsbytes("acos("),[15,[12,41,0]]],
       caml_string_of_jsbytes("acos(%a)")],
     _mH_=
      [0,
       [11,caml_string_of_jsbytes("atan("),[15,[12,41,0]]],
       caml_string_of_jsbytes("atan(%a)")],
     _mI_=
      [0,
       [11,caml_string_of_jsbytes("exp("),[15,[12,41,0]]],
       caml_string_of_jsbytes("exp(%a)")],
     _mJ_=
      [0,
       [11,caml_string_of_jsbytes("log("),[15,[12,41,0]]],
       caml_string_of_jsbytes("log(%a)")],
     _mK_=
      [0,
       [11,caml_string_of_jsbytes("sinh("),[15,[12,41,0]]],
       caml_string_of_jsbytes("sinh(%a)")],
     _mL_=
      [0,
       [11,caml_string_of_jsbytes("cosh("),[15,[12,41,0]]],
       caml_string_of_jsbytes("cosh(%a)")],
     _mM_=
      [0,
       [11,caml_string_of_jsbytes("tanh("),[15,[12,41,0]]],
       caml_string_of_jsbytes("tanh(%a)")],
     _mN_=
      [0,
       [11,caml_string_of_jsbytes("asinh("),[15,[12,41,0]]],
       caml_string_of_jsbytes("asinh(%a)")],
     _mO_=
      [0,
       [11,caml_string_of_jsbytes("acosh("),[15,[12,41,0]]],
       caml_string_of_jsbytes("acosh(%a)")],
     _mP_=
      [0,
       [11,caml_string_of_jsbytes("atanh("),[15,[12,41,0]]],
       caml_string_of_jsbytes("atanh(%a)")],
     _mQ_=
      [0,
       [11,caml_string_of_jsbytes("floor_power2("),[15,[12,41,0]]],
       caml_string_of_jsbytes("floor_power2(%a)")],
     _mR_=
      [0,
       [11,
        caml_string_of_jsbytes("fmax("),
        [15,[11,caml_string_of_jsbytes(", "),[15,[12,41,0]]]]],
       caml_string_of_jsbytes("fmax(%a, %a)")],
     _mS_=
      [0,
       [11,
        caml_string_of_jsbytes("fmin("),
        [15,[11,caml_string_of_jsbytes(", "),[15,[12,41,0]]]]],
       caml_string_of_jsbytes("fmin(%a, %a)")],
     _mT_=
      [0,
       [12,40,[15,[11,caml_string_of_jsbytes(" + "),[15,[12,41,0]]]]],
       caml_string_of_jsbytes("(%a + %a)")],
     _mU_=
      [0,
       [12,40,[15,[11,caml_string_of_jsbytes(" - "),[15,[12,41,0]]]]],
       caml_string_of_jsbytes("(%a - %a)")],
     _mV_=
      [0,
       [12,40,[15,[11,caml_string_of_jsbytes(" * "),[15,[12,41,0]]]]],
       caml_string_of_jsbytes("(%a * %a)")],
     _mW_=
      [0,
       [12,40,[15,[11,caml_string_of_jsbytes(" / "),[15,[12,41,0]]]]],
       caml_string_of_jsbytes("(%a / %a)")],
     _mX_=
      [0,
       [11,
        caml_string_of_jsbytes("pow("),
        [15,[11,caml_string_of_jsbytes(", "),[15,[12,41,0]]]]],
       caml_string_of_jsbytes("pow(%a, %a)")],
     _mY_=
      [0,
       [11,
        caml_string_of_jsbytes("sub2("),
        [15,[11,caml_string_of_jsbytes(", "),[15,[12,41,0]]]]],
       caml_string_of_jsbytes("sub2(%a, %a)")],
     _mZ_=
      [0,
       [11,
        caml_string_of_jsbytes("abs_err("),
        [15,[11,caml_string_of_jsbytes(", "),[15,[12,41,0]]]]],
       caml_string_of_jsbytes("abs_err(%a, %a)")],
     _m1_=
      [0,
       [11,
        caml_string_of_jsbytes("fma("),
        [15,
         [11,
          caml_string_of_jsbytes(", "),
          [15,[11,caml_string_of_jsbytes(", "),[15,[12,41,0]]]]]]],
       caml_string_of_jsbytes("fma(%a, %a, %a)")],
     _m0_=caml_string_of_jsbytes("C: unknown general operation: "),
     _l0_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _l1_=
      [0,
       [11,caml_string_of_jsbytes("(interval "),[2,0,[12,32,[2,0,[12,41,0]]]]],
       caml_string_of_jsbytes("(interval %s %s)")],
     _l2_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _l3_=
      [0,
       [12,40,[2,0,[12,32,[15,[12,41,0]]]]],
       caml_string_of_jsbytes("(%s %a)")],
     _l4_=
      [0,
       [11,caml_string_of_jsbytes("(- "),[15,[12,41,0]]],
       caml_string_of_jsbytes("(- %a)")],
     _l5_=
      [0,
       [11,caml_string_of_jsbytes("(fabs "),[15,[12,41,0]]],
       caml_string_of_jsbytes("(fabs %a)")],
     _l6_=
      [0,
       [11,caml_string_of_jsbytes("(/ 1 "),[15,[12,41,0]]],
       caml_string_of_jsbytes("(/ 1 %a)")],
     _l7_=
      [0,
       [11,caml_string_of_jsbytes("(sqrt "),[15,[12,41,0]]],
       caml_string_of_jsbytes("(sqrt %a)")],
     _l8_=
      [0,
       [11,caml_string_of_jsbytes("(sin "),[15,[12,41,0]]],
       caml_string_of_jsbytes("(sin %a)")],
     _l9_=
      [0,
       [11,caml_string_of_jsbytes("(cos "),[15,[12,41,0]]],
       caml_string_of_jsbytes("(cos %a)")],
     _l__=
      [0,
       [11,caml_string_of_jsbytes("(tan "),[15,[12,41,0]]],
       caml_string_of_jsbytes("(tan %a)")],
     _l$_=
      [0,
       [11,caml_string_of_jsbytes("(asin "),[15,[12,41,0]]],
       caml_string_of_jsbytes("(asin %a)")],
     _ma_=
      [0,
       [11,caml_string_of_jsbytes("(acos "),[15,[12,41,0]]],
       caml_string_of_jsbytes("(acos %a)")],
     _mb_=
      [0,
       [11,caml_string_of_jsbytes("(atan "),[15,[12,41,0]]],
       caml_string_of_jsbytes("(atan %a)")],
     _mc_=
      [0,
       [11,caml_string_of_jsbytes("(exp "),[15,[12,41,0]]],
       caml_string_of_jsbytes("(exp %a)")],
     _md_=
      [0,
       [11,caml_string_of_jsbytes("(log "),[15,[12,41,0]]],
       caml_string_of_jsbytes("(log %a)")],
     _me_=
      [0,
       [11,caml_string_of_jsbytes("(sinh "),[15,[12,41,0]]],
       caml_string_of_jsbytes("(sinh %a)")],
     _mf_=
      [0,
       [11,caml_string_of_jsbytes("(cosh "),[15,[12,41,0]]],
       caml_string_of_jsbytes("(cosh %a)")],
     _mg_=
      [0,
       [11,caml_string_of_jsbytes("(tanh "),[15,[12,41,0]]],
       caml_string_of_jsbytes("(tanh %a)")],
     _mh_=
      [0,
       [11,caml_string_of_jsbytes("(asinh "),[15,[12,41,0]]],
       caml_string_of_jsbytes("(asinh %a)")],
     _mi_=
      [0,
       [11,caml_string_of_jsbytes("(acosh "),[15,[12,41,0]]],
       caml_string_of_jsbytes("(acosh %a)")],
     _mj_=
      [0,
       [11,caml_string_of_jsbytes("(atanh "),[15,[12,41,0]]],
       caml_string_of_jsbytes("(atanh %a)")],
     _mk_=
      [0,
       [11,caml_string_of_jsbytes("(p2 "),[15,[12,41,0]]],
       caml_string_of_jsbytes("(p2 %a)")],
     _ml_=
      [0,
       [18,
        [1,
         [0,
          [11,caml_string_of_jsbytes("<6>"),0],
          caml_string_of_jsbytes("<6>")]],
        [11,
         caml_string_of_jsbytes("(fmax "),
         [15,[17,[0,caml_string_of_jsbytes("@ "),1,0],[15,[12,41,[17,0,0]]]]]]],
       caml_string_of_jsbytes("@[<6>(fmax %a@ %a)@]")],
     _mm_=
      [0,
       [18,
        [1,
         [0,
          [11,caml_string_of_jsbytes("<6>"),0],
          caml_string_of_jsbytes("<6>")]],
        [11,
         caml_string_of_jsbytes("(fmin "),
         [15,[17,[0,caml_string_of_jsbytes("@ "),1,0],[15,[12,41,[17,0,0]]]]]]],
       caml_string_of_jsbytes("@[<6>(fmin %a@ %a)@]")],
     _mn_=
      [0,
       [18,
        [1,
         [0,
          [11,caml_string_of_jsbytes("<3>"),0],
          caml_string_of_jsbytes("<3>")]],
        [11,
         caml_string_of_jsbytes("(+ "),
         [15,[17,[0,caml_string_of_jsbytes("@ "),1,0],[15,[12,41,[17,0,0]]]]]]],
       caml_string_of_jsbytes("@[<3>(+ %a@ %a)@]")],
     _mo_=
      [0,
       [18,
        [1,
         [0,
          [11,caml_string_of_jsbytes("<3>"),0],
          caml_string_of_jsbytes("<3>")]],
        [11,
         caml_string_of_jsbytes("(- "),
         [15,[17,[0,caml_string_of_jsbytes("@ "),1,0],[15,[12,41,[17,0,0]]]]]]],
       caml_string_of_jsbytes("@[<3>(- %a@ %a)@]")],
     _mp_=
      [0,
       [18,
        [1,
         [0,
          [11,caml_string_of_jsbytes("<3>"),0],
          caml_string_of_jsbytes("<3>")]],
        [11,
         caml_string_of_jsbytes("(* "),
         [15,[17,[0,caml_string_of_jsbytes("@ "),1,0],[15,[12,41,[17,0,0]]]]]]],
       caml_string_of_jsbytes("@[<3>(* %a@ %a)@]")],
     _mq_=
      [0,
       [18,
        [1,
         [0,
          [11,caml_string_of_jsbytes("<3>"),0],
          caml_string_of_jsbytes("<3>")]],
        [11,
         caml_string_of_jsbytes("(/ "),
         [15,[17,[0,caml_string_of_jsbytes("@ "),1,0],[15,[12,41,[17,0,0]]]]]]],
       caml_string_of_jsbytes("@[<3>(/ %a@ %a)@]")],
     _mr_=
      [0,
       [18,
        [1,
         [0,
          [11,caml_string_of_jsbytes("<5>"),0],
          caml_string_of_jsbytes("<5>")]],
        [11,
         caml_string_of_jsbytes("(pow "),
         [15,[17,[0,caml_string_of_jsbytes("@ "),1,0],[15,[12,41,[17,0,0]]]]]]],
       caml_string_of_jsbytes("@[<5>(pow %a@ %a)@]")],
     _ms_=caml_string_of_jsbytes("FPCore: unknown binary operation: "),
     _mu_=
      [0,
       [11,
        caml_string_of_jsbytes("(fma "),
        [15,[12,32,[15,[12,32,[15,[12,41,0]]]]]]],
       caml_string_of_jsbytes("(fma %a %a %a)")],
     _mt_=caml_string_of_jsbytes("FPCore: unknown general operation: "),
     _lr_=
      [0,
       [11,
        caml_string_of_jsbytes("{low = "),
        [8,
         3,
         0,
         [0,20],
         [11,caml_string_of_jsbytes("; high = "),[8,3,0,[0,20],[12,125,0]]]]],
       caml_string_of_jsbytes("{low = %.20e; high = %.20e}")],
     _ls_=
      [0,
       [11,caml_string_of_jsbytes("ref_"),[4,0,0,0,0]],
       caml_string_of_jsbytes("ref_%d")],
     _lt_=
      [0,
       [11,caml_string_of_jsbytes("var_"),[2,0,0]],
       caml_string_of_jsbytes("var_%s")],
     _lu_=caml_string_of_jsbytes("OCamlInterval: rounding is not allowed: "),
     _lv_=
      [0,
       [11,
        caml_string_of_jsbytes("(~-$("),
        [15,[11,caml_string_of_jsbytes("))"),0]]],
       caml_string_of_jsbytes("(~-$(%a))")],
     _lw_=
      [0,
       [11,caml_string_of_jsbytes("abs_I("),[15,[12,41,0]]],
       caml_string_of_jsbytes("abs_I(%a)")],
     _lx_=
      [0,
       [11,caml_string_of_jsbytes("inv_I("),[15,[12,41,0]]],
       caml_string_of_jsbytes("inv_I(%a)")],
     _ly_=
      [0,
       [11,caml_string_of_jsbytes("sqrt_I("),[15,[12,41,0]]],
       caml_string_of_jsbytes("sqrt_I(%a)")],
     _lz_=
      [0,
       [11,caml_string_of_jsbytes("sin_I("),[15,[12,41,0]]],
       caml_string_of_jsbytes("sin_I(%a)")],
     _lA_=
      [0,
       [11,caml_string_of_jsbytes("cos_I("),[15,[12,41,0]]],
       caml_string_of_jsbytes("cos_I(%a)")],
     _lB_=
      [0,
       [11,caml_string_of_jsbytes("tan_I("),[15,[12,41,0]]],
       caml_string_of_jsbytes("tan_I(%a)")],
     _lC_=
      [0,
       [11,caml_string_of_jsbytes("asin_I("),[15,[12,41,0]]],
       caml_string_of_jsbytes("asin_I(%a)")],
     _lD_=
      [0,
       [11,caml_string_of_jsbytes("acos_I("),[15,[12,41,0]]],
       caml_string_of_jsbytes("acos_I(%a)")],
     _lE_=
      [0,
       [11,caml_string_of_jsbytes("atan_I("),[15,[12,41,0]]],
       caml_string_of_jsbytes("atan_I(%a)")],
     _lF_=
      [0,
       [11,caml_string_of_jsbytes("exp_I("),[15,[12,41,0]]],
       caml_string_of_jsbytes("exp_I(%a)")],
     _lG_=
      [0,
       [11,caml_string_of_jsbytes("log_I("),[15,[12,41,0]]],
       caml_string_of_jsbytes("log_I(%a)")],
     _lH_=
      [0,
       [11,caml_string_of_jsbytes("sinh_I("),[15,[12,41,0]]],
       caml_string_of_jsbytes("sinh_I(%a)")],
     _lI_=
      [0,
       [11,caml_string_of_jsbytes("cosh_I("),[15,[12,41,0]]],
       caml_string_of_jsbytes("cosh_I(%a)")],
     _lJ_=
      [0,
       [11,caml_string_of_jsbytes("tanh_I("),[15,[12,41,0]]],
       caml_string_of_jsbytes("tanh_I(%a)")],
     _lK_=
      [0,
       [11,caml_string_of_jsbytes("asinh_I("),[15,[12,41,0]]],
       caml_string_of_jsbytes("asinh_I(%a)")],
     _lL_=
      [0,
       [11,caml_string_of_jsbytes("acosh_I("),[15,[12,41,0]]],
       caml_string_of_jsbytes("acosh_I(%a)")],
     _lM_=
      [0,
       [11,caml_string_of_jsbytes("atanh_I("),[15,[12,41,0]]],
       caml_string_of_jsbytes("atanh_I(%a)")],
     _lN_=
      [0,
       [11,caml_string_of_jsbytes("floor_power2_I("),[15,[12,41,0]]],
       caml_string_of_jsbytes("floor_power2_I(%a)")],
     _lO_=
      [0,
       [11,
        caml_string_of_jsbytes("max_I_I ("),
        [15,[11,caml_string_of_jsbytes(") ("),[15,[12,41,0]]]]],
       caml_string_of_jsbytes("max_I_I (%a) (%a)")],
     _lP_=
      [0,
       [11,
        caml_string_of_jsbytes("min_I_I ("),
        [15,[11,caml_string_of_jsbytes(") ("),[15,[12,41,0]]]]],
       caml_string_of_jsbytes("min_I_I (%a) (%a)")],
     _lQ_=
      [0,
       [12,40,[15,[11,caml_string_of_jsbytes(" +$ "),[15,[12,41,0]]]]],
       caml_string_of_jsbytes("(%a +$ %a)")],
     _lR_=
      [0,
       [12,40,[15,[11,caml_string_of_jsbytes(" -$ "),[15,[12,41,0]]]]],
       caml_string_of_jsbytes("(%a -$ %a)")],
     _lS_=
      [0,
       [12,40,[15,[11,caml_string_of_jsbytes(" *$ "),[15,[12,41,0]]]]],
       caml_string_of_jsbytes("(%a *$ %a)")],
     _lT_=
      [0,
       [12,40,[15,[11,caml_string_of_jsbytes(" /$ "),[15,[12,41,0]]]]],
       caml_string_of_jsbytes("(%a /$ %a)")],
     _lU_=
      [0,
       [11,
        caml_string_of_jsbytes("pow_I_i ("),
        [15,[11,caml_string_of_jsbytes(") ("),[2,0,[12,41,0]]]]],
       caml_string_of_jsbytes("pow_I_i (%a) (%s)")],
     _lV_=
      caml_string_of_jsbytes
       ("OCamlInterval: Op_nat_pow: non-integer exponent"),
     _lW_=
      [0,
       [11,
        caml_string_of_jsbytes("sub2_I ("),
        [15,[11,caml_string_of_jsbytes(", "),[15,[12,41,0]]]]],
       caml_string_of_jsbytes("sub2_I (%a, %a)")],
     _lX_=
      [0,
       [11,
        caml_string_of_jsbytes("abs_err_I("),
        [15,[11,caml_string_of_jsbytes(", "),[15,[12,41,0]]]]],
       caml_string_of_jsbytes("abs_err_I(%a, %a)")],
     _lZ_=
      [0,
       [11,
        caml_string_of_jsbytes("goldberg_ulp_I ("),
        [4,
         0,
         0,
         0,
         [12,44,[4,0,0,0,[11,caml_string_of_jsbytes(") ("),[15,[12,41,0]]]]]]],
       caml_string_of_jsbytes("goldberg_ulp_I (%d,%d) (%a)")],
     _lY_=caml_string_of_jsbytes("OCamlInterval: unknown general operation: "),
     _kT_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _kU_=[0,[12,40,[2,0,[12,41,0]]],caml_string_of_jsbytes("(%s)")],
     _kV_=
      [0,
       [11,
        caml_string_of_jsbytes("interval("),
        [8,
         3,
         0,
         [0,20],
         [11,caml_string_of_jsbytes(", "),[8,3,0,[0,20],[12,41,0]]]]],
       caml_string_of_jsbytes("interval(%.20e, %.20e)")],
     _kW_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _kX_=
      [0,
       [18,
        [1,[0,0,caml_string_of_jsbytes("")]],
        [2,
         0,
         [12,
          40,
          [17,[0,caml_string_of_jsbytes("@,"),0,0],[15,[12,41,[17,0,0]]]]]]],
       caml_string_of_jsbytes("@[%s(@,%a)@]")],
     _kY_=
      [0,
       [11,
        caml_string_of_jsbytes("(-("),
        [15,[11,caml_string_of_jsbytes("))"),0]]],
       caml_string_of_jsbytes("(-(%a))")],
     _kZ_=
      [0,
       [11,caml_string_of_jsbytes("abs("),[15,[12,41,0]]],
       caml_string_of_jsbytes("abs(%a)")],
     _k0_=
      [0,
       [11,caml_string_of_jsbytes("inv("),[15,[12,41,0]]],
       caml_string_of_jsbytes("inv(%a)")],
     _k1_=
      [0,
       [11,caml_string_of_jsbytes("sqrt("),[15,[12,41,0]]],
       caml_string_of_jsbytes("sqrt(%a)")],
     _k2_=
      [0,
       [11,caml_string_of_jsbytes("sin("),[15,[12,41,0]]],
       caml_string_of_jsbytes("sin(%a)")],
     _k3_=
      [0,
       [11,caml_string_of_jsbytes("cos("),[15,[12,41,0]]],
       caml_string_of_jsbytes("cos(%a)")],
     _k4_=
      [0,
       [11,caml_string_of_jsbytes("tan("),[15,[12,41,0]]],
       caml_string_of_jsbytes("tan(%a)")],
     _k5_=
      [0,
       [11,caml_string_of_jsbytes("asin("),[15,[12,41,0]]],
       caml_string_of_jsbytes("asin(%a)")],
     _k6_=
      [0,
       [11,caml_string_of_jsbytes("acos("),[15,[12,41,0]]],
       caml_string_of_jsbytes("acos(%a)")],
     _k7_=
      [0,
       [11,caml_string_of_jsbytes("atan("),[15,[12,41,0]]],
       caml_string_of_jsbytes("atan(%a)")],
     _k8_=
      [0,
       [11,caml_string_of_jsbytes("exp("),[15,[12,41,0]]],
       caml_string_of_jsbytes("exp(%a)")],
     _k9_=
      [0,
       [11,caml_string_of_jsbytes("log("),[15,[12,41,0]]],
       caml_string_of_jsbytes("log(%a)")],
     _k__=
      [0,
       [11,caml_string_of_jsbytes("sinh("),[15,[12,41,0]]],
       caml_string_of_jsbytes("sinh(%a)")],
     _k$_=
      [0,
       [11,caml_string_of_jsbytes("cosh("),[15,[12,41,0]]],
       caml_string_of_jsbytes("cosh(%a)")],
     _la_=
      [0,
       [11,caml_string_of_jsbytes("tanh("),[15,[12,41,0]]],
       caml_string_of_jsbytes("tanh(%a)")],
     _lb_=
      [0,
       [11,caml_string_of_jsbytes("asinh("),[15,[12,41,0]]],
       caml_string_of_jsbytes("asinh(%a)")],
     _lc_=
      [0,
       [11,caml_string_of_jsbytes("acosh("),[15,[12,41,0]]],
       caml_string_of_jsbytes("acosh(%a)")],
     _ld_=
      [0,
       [11,caml_string_of_jsbytes("atanh("),[15,[12,41,0]]],
       caml_string_of_jsbytes("atanh(%a)")],
     _le_=
      [0,
       [11,caml_string_of_jsbytes("floor_power2("),[15,[12,41,0]]],
       caml_string_of_jsbytes("floor_power2(%a)")],
     _lf_=
      [0,
       [11,
        caml_string_of_jsbytes("max("),
        [15,[11,caml_string_of_jsbytes(", "),[15,[12,41,0]]]]],
       caml_string_of_jsbytes("max(%a, %a)")],
     _lg_=
      [0,
       [11,
        caml_string_of_jsbytes("min("),
        [15,[11,caml_string_of_jsbytes(", "),[15,[12,41,0]]]]],
       caml_string_of_jsbytes("min(%a, %a)")],
     _lh_=
      [0,
       [18,
        [1,[0,0,caml_string_of_jsbytes("")]],
        [12,
         40,
         [15,
          [11,
           caml_string_of_jsbytes(" +"),
           [17,[0,caml_string_of_jsbytes("@ "),1,0],[15,[12,41,[17,0,0]]]]]]]],
       caml_string_of_jsbytes("@[(%a +@ %a)@]")],
     _li_=
      [0,
       [18,
        [1,[0,0,caml_string_of_jsbytes("")]],
        [12,
         40,
         [15,
          [11,
           caml_string_of_jsbytes(" -"),
           [17,[0,caml_string_of_jsbytes("@ "),1,0],[15,[12,41,[17,0,0]]]]]]]],
       caml_string_of_jsbytes("@[(%a -@ %a)@]")],
     _lj_=
      [0,
       [18,
        [1,[0,0,caml_string_of_jsbytes("")]],
        [12,
         40,
         [15,
          [11,
           caml_string_of_jsbytes(" *"),
           [17,[0,caml_string_of_jsbytes("@ "),1,0],[15,[12,41,[17,0,0]]]]]]]],
       caml_string_of_jsbytes("@[(%a *@ %a)@]")],
     _lk_=
      [0,
       [18,
        [1,[0,0,caml_string_of_jsbytes("")]],
        [12,
         40,
         [15,
          [11,
           caml_string_of_jsbytes(" /"),
           [17,[0,caml_string_of_jsbytes("@ "),1,0],[15,[12,41,[17,0,0]]]]]]]],
       caml_string_of_jsbytes("@[(%a /@ %a)@]")],
     _ll_=
      [0,
       [12,40,[15,[11,caml_string_of_jsbytes(" ^ "),[15,[12,41,0]]]]],
       caml_string_of_jsbytes("(%a ^ %a)")],
     _lm_=
      [0,
       [11,
        caml_string_of_jsbytes("sub2("),
        [15,[11,caml_string_of_jsbytes(", "),[15,[12,41,0]]]]],
       caml_string_of_jsbytes("sub2(%a, %a)")],
     _ln_=
      [0,
       [11,
        caml_string_of_jsbytes("abs_err("),
        [15,[11,caml_string_of_jsbytes(", "),[15,[12,41,0]]]]],
       caml_string_of_jsbytes("abs_err(%a, %a)")],
     _lq_=
      [0,
       [11,
        caml_string_of_jsbytes("ulp["),
        [4,
         0,
         0,
         0,
         [12,44,[4,0,0,0,[11,caml_string_of_jsbytes("]("),[15,[12,41,0]]]]]]],
       caml_string_of_jsbytes("ulp[%d,%d](%a)")],
     _lp_=
      [0,
       [11,
        caml_string_of_jsbytes("fma("),
        [15,
         [11,
          caml_string_of_jsbytes(", "),
          [15,[11,caml_string_of_jsbytes(", "),[15,[12,41,0]]]]]]],
       caml_string_of_jsbytes("fma(%a, %a, %a)")],
     _lo_=caml_string_of_jsbytes("Info: unknown general operation: "),
     _kR_=caml_string_of_jsbytes("_"),
     _kS_=caml_string_of_jsbytes("_"),
     _kQ_=caml_string_of_jsbytes("[^a-zA-Z0-9_]"),
     _n1_=
      [0,
       [11,caml_string_of_jsbytes("eval_const_expr: "),[2,0,0]],
       caml_string_of_jsbytes("eval_const_expr: %s")],
     _n2_=
      [0,
       [11,caml_string_of_jsbytes("result: "),[2,0,0]],
       caml_string_of_jsbytes("result: %s")],
     _n0_=caml_string_of_jsbytes("eval_interval_const_expr: Var "),
     _nY_=
      caml_string_of_jsbytes
       ("eval_interval_expr: Rounding is not supported: "),
     _nZ_=
      caml_string_of_jsbytes
       ("eval_interval_expr: Unsupported general operation: "),
     _nX_=caml_string_of_jsbytes("eval_num_const_expr: Var "),
     _nT_=caml_string_of_jsbytes("eval_num_expr: interval constant"),
     _nU_=
      caml_string_of_jsbytes("eval_num_expr: Unsupported unary operation: "),
     _nV_=
      caml_string_of_jsbytes("eval_num_expr: Unsupported binary operation: "),
     _nW_=
      caml_string_of_jsbytes("eval_num_expr: Unsupported general operation: "),
     _nS_=caml_string_of_jsbytes("eval_float_const_expr: Var "),
     _nQ_=
      caml_string_of_jsbytes("eval_float_expr: Rounding is not supported: "),
     _nR_=
      caml_string_of_jsbytes
       ("eval_float_expr: Unsupported general operation: "),
     _n6_=caml_string_of_jsbytes("^"),
     _n7_=caml_string_of_jsbytes("^"),
     _n8_=
      [0,
       [11,caml_string_of_jsbytes("Unknown identifier: '"),[2,0,[12,39,0]]],
       caml_string_of_jsbytes("Unknown identifier: '%s'")],
     _n9_=caml_string_of_jsbytes("cosh"),
     _oi_=caml_string_of_jsbytes("-"),
     _oj_=caml_string_of_jsbytes("abs"),
     _ok_=caml_string_of_jsbytes("acos"),
     _ol_=caml_string_of_jsbytes("acosh"),
     _om_=caml_string_of_jsbytes("asin"),
     _on_=caml_string_of_jsbytes("asinh"),
     _oo_=caml_string_of_jsbytes("atan"),
     _op_=caml_string_of_jsbytes("atanh"),
     _oq_=caml_string_of_jsbytes("cos"),
     _n__=caml_string_of_jsbytes("exp"),
     _n$_=caml_string_of_jsbytes("floor_power2"),
     _oa_=caml_string_of_jsbytes("inv"),
     _ob_=caml_string_of_jsbytes("log"),
     _oc_=caml_string_of_jsbytes("sin"),
     _od_=caml_string_of_jsbytes("sinh"),
     _oe_=caml_string_of_jsbytes("sqrt"),
     _of_=caml_string_of_jsbytes("tan"),
     _og_=caml_string_of_jsbytes("tanh"),
     _oh_=
      caml_string_of_jsbytes("transform_raw_expr: Unknown unary operation: "),
     _or_=caml_string_of_jsbytes("*"),
     _os_=caml_string_of_jsbytes("+"),
     _ot_=caml_string_of_jsbytes("-"),
     _ou_=caml_string_of_jsbytes("/"),
     _ov_=caml_string_of_jsbytes("^"),
     _ow_=caml_string_of_jsbytes("interval"),
     _ox_=caml_string_of_jsbytes("max"),
     _oy_=caml_string_of_jsbytes("min"),
     _oz_=caml_string_of_jsbytes("sub2"),
     _oA_=
      caml_string_of_jsbytes("transform_raw_expr: Unknown binary operation: "),
     _oB_=caml_string_of_jsbytes("fma"),
     _oC_=caml_string_of_jsbytes("transform_raw_expr: Unknown operation: "),
     _oL_=caml_string_of_jsbytes("Expression "),
     _oJ_=caml_string_of_jsbytes(" is already defined"),
     _oK_=caml_string_of_jsbytes("Definition "),
     _oI_=[1,[0,0]],
     _oF_=caml_string_of_jsbytes(" is already defined"),
     _oG_=caml_string_of_jsbytes("Variable "),
     _oH_=
      [0,
       [11,
        caml_string_of_jsbytes("Variable "),
        [2,0,[11,caml_string_of_jsbytes(" is a constant"),0]]],
       caml_string_of_jsbytes("Variable %s is a constant")],
     _oD_=caml_string_of_jsbytes(" is already defined"),
     _oE_=caml_string_of_jsbytes("Constant "),
     _n5_=
      [0,
       [11,caml_string_of_jsbytes("Resetting input_parser_env"),0],
       caml_string_of_jsbytes("Resetting input_parser_env")],
     _qR_=caml_string_of_jsbytes("parser"),
     _qv_=caml_string_of_jsbytes("default-var-type"),
     _p8_=caml_string_of_jsbytes("-"),
     _p5_=caml_string_of_jsbytes("ne"),
     _p0_=caml_string_of_jsbytes("default-rnd"),
     _pW_=caml_string_of_jsbytes("rnd32"),
     _pU_=caml_string_of_jsbytes("rnd64"),
     _pR_=caml_string_of_jsbytes("+"),
     _pP_=caml_string_of_jsbytes("-"),
     _pN_=caml_string_of_jsbytes("*"),
     _pL_=caml_string_of_jsbytes("/"),
     _pJ_=caml_string_of_jsbytes("-"),
     _pG_=caml_string_of_jsbytes("exp"),
     _pE_=caml_string_of_jsbytes("^"),
     _pC_=caml_string_of_jsbytes("^"),
     _pz_=caml_string_of_jsbytes("abs"),
     _px_=caml_string_of_jsbytes("inv"),
     _pv_=caml_string_of_jsbytes("fma"),
     _pt_=caml_string_of_jsbytes("sqrt"),
     _pr_=caml_string_of_jsbytes("exp"),
     _pp_=caml_string_of_jsbytes("log"),
     _pn_=caml_string_of_jsbytes("cos"),
     _pl_=caml_string_of_jsbytes("sin"),
     _pj_=caml_string_of_jsbytes("tan"),
     _ph_=caml_string_of_jsbytes("min"),
     _pf_=caml_string_of_jsbytes("max"),
     _pd_=caml_string_of_jsbytes("cosh"),
     _pb_=caml_string_of_jsbytes("sinh"),
     _o$_=caml_string_of_jsbytes("tanh"),
     _o9_=caml_string_of_jsbytes("acos"),
     _o7_=caml_string_of_jsbytes("asin"),
     _o5_=caml_string_of_jsbytes("atan"),
     _o3_=caml_string_of_jsbytes("acosh"),
     _o1_=caml_string_of_jsbytes("asinh"),
     _oZ_=caml_string_of_jsbytes("atanh"),
     _oW_=caml_string_of_jsbytes("sub2"),
     _oU_=caml_string_of_jsbytes("floor_power2"),
     _oS_=caml_string_of_jsbytes("interval"),
     _oM_=caml_string_of_jsbytes("Input_parser.TODO"),
     _oN_=
      [0,
       0,
       257,
       258,
       259,
       260,
       261,
       262,
       263,
       264,
       265,
       266,
       267,
       268,
       269,
       270,
       271,
       272,
       273,
       274,
       275,
       276,
       277,
       282,
       283,
       284,
       285,
       286,
       287,
       288,
       291,
       292,
       293,
       294,
       295,
       296,
       297,
       298,
       299,
       300,
       301,
       302,
       303,
       304,
       305,
       306,
       307,
       308,
       309,
       310,
       311,
       312,
       313,
       314,
       315,
       316,
       317,
       0],
     _oO_=[0,278,279,280,281,289,290,0],
     _qU_=caml_string_of_jsbytes("Unexpected char: "),
     _qS_=caml_string_of_jsbytes("Input_lexer.SyntaxError"),
     _qT_=
      caml_list_of_js_array
       ([[0,caml_string_of_jsbytes("Constants"),22],
         [0,caml_string_of_jsbytes("constants"),22],
         [0,caml_string_of_jsbytes("Variables"),23],
         [0,caml_string_of_jsbytes("variables"),23],
         [0,caml_string_of_jsbytes("Definitions"),24],
         [0,caml_string_of_jsbytes("definitions"),24],
         [0,caml_string_of_jsbytes("Constraints"),25],
         [0,caml_string_of_jsbytes("constraints"),25],
         [0,caml_string_of_jsbytes("Expressions"),26],
         [0,caml_string_of_jsbytes("expressions"),26],
         [0,caml_string_of_jsbytes("IN"),20],
         [0,caml_string_of_jsbytes("in"),20],
         [0,caml_string_of_jsbytes("int"),27],
         [0,caml_string_of_jsbytes("real"),28],
         [0,caml_string_of_jsbytes("float16"),[4,16]],
         [0,caml_string_of_jsbytes("float32"),[4,32]],
         [0,caml_string_of_jsbytes("float64"),[4,64]],
         [0,caml_string_of_jsbytes("float128"),[4,128]],
         [0,caml_string_of_jsbytes("rnd"),29],
         [0,caml_string_of_jsbytes("no_rnd"),30],
         [0,
          caml_string_of_jsbytes("rnd16_ne"),
          [5,[0,16,caml_string_of_jsbytes("ne")]]],
         [0,
          caml_string_of_jsbytes("rnd16"),
          [5,[0,16,caml_string_of_jsbytes("ne")]]],
         [0,
          caml_string_of_jsbytes("rnd16_0"),
          [5,[0,16,caml_string_of_jsbytes("zero")]]],
         [0,
          caml_string_of_jsbytes("rnd16_down"),
          [5,[0,16,caml_string_of_jsbytes("down")]]],
         [0,
          caml_string_of_jsbytes("rnd16_up"),
          [5,[0,16,caml_string_of_jsbytes("up")]]],
         [0,
          caml_string_of_jsbytes("rnd32_ne"),
          [5,[0,32,caml_string_of_jsbytes("ne")]]],
         [0,
          caml_string_of_jsbytes("rnd32"),
          [5,[0,32,caml_string_of_jsbytes("ne")]]],
         [0,
          caml_string_of_jsbytes("rnd32_0"),
          [5,[0,32,caml_string_of_jsbytes("zero")]]],
         [0,
          caml_string_of_jsbytes("rnd32_down"),
          [5,[0,32,caml_string_of_jsbytes("down")]]],
         [0,
          caml_string_of_jsbytes("rnd32_up"),
          [5,[0,32,caml_string_of_jsbytes("up")]]],
         [0,
          caml_string_of_jsbytes("rnd64_ne"),
          [5,[0,64,caml_string_of_jsbytes("ne")]]],
         [0,
          caml_string_of_jsbytes("rnd64"),
          [5,[0,64,caml_string_of_jsbytes("ne")]]],
         [0,
          caml_string_of_jsbytes("rnd64_0"),
          [5,[0,64,caml_string_of_jsbytes("zero")]]],
         [0,
          caml_string_of_jsbytes("rnd64_down"),
          [5,[0,64,caml_string_of_jsbytes("down")]]],
         [0,
          caml_string_of_jsbytes("rnd64_up"),
          [5,[0,64,caml_string_of_jsbytes("up")]]],
         [0,
          caml_string_of_jsbytes("rnd128_ne"),
          [5,[0,128,caml_string_of_jsbytes("ne")]]],
         [0,
          caml_string_of_jsbytes("rnd128"),
          [5,[0,128,caml_string_of_jsbytes("ne")]]],
         [0,
          caml_string_of_jsbytes("rnd128_0"),
          [5,[0,128,caml_string_of_jsbytes("zero")]]],
         [0,
          caml_string_of_jsbytes("rnd128_down"),
          [5,[0,128,caml_string_of_jsbytes("down")]]],
         [0,
          caml_string_of_jsbytes("rnd128_up"),
          [5,[0,128,caml_string_of_jsbytes("up")]]],
         [0,caml_string_of_jsbytes("inv"),33],
         [0,caml_string_of_jsbytes("abs"),32],
         [0,caml_string_of_jsbytes("fma"),35],
         [0,caml_string_of_jsbytes("sqrt"),34],
         [0,caml_string_of_jsbytes("min"),36],
         [0,caml_string_of_jsbytes("max"),37],
         [0,caml_string_of_jsbytes("exp"),38],
         [0,caml_string_of_jsbytes("log"),39],
         [0,caml_string_of_jsbytes("cos"),40],
         [0,caml_string_of_jsbytes("sin"),41],
         [0,caml_string_of_jsbytes("tan"),42],
         [0,caml_string_of_jsbytes("cosh"),43],
         [0,caml_string_of_jsbytes("sinh"),44],
         [0,caml_string_of_jsbytes("tanh"),45],
         [0,caml_string_of_jsbytes("acos"),46],
         [0,caml_string_of_jsbytes("asin"),47],
         [0,caml_string_of_jsbytes("atan"),48],
         [0,caml_string_of_jsbytes("atan2"),52],
         [0,caml_string_of_jsbytes("arccos"),46],
         [0,caml_string_of_jsbytes("arcsin"),47],
         [0,caml_string_of_jsbytes("arctan"),48],
         [0,caml_string_of_jsbytes("acosh"),49],
         [0,caml_string_of_jsbytes("asinh"),50],
         [0,caml_string_of_jsbytes("atanh"),51],
         [0,caml_string_of_jsbytes("arsinh"),50],
         [0,caml_string_of_jsbytes("arcosh"),49],
         [0,caml_string_of_jsbytes("artanh"),51],
         [0,caml_string_of_jsbytes("arcsinh"),50],
         [0,caml_string_of_jsbytes("arccosh"),49],
         [0,caml_string_of_jsbytes("arctanh"),51],
         [0,caml_string_of_jsbytes("argsinh"),50],
         [0,caml_string_of_jsbytes("argcosh"),49],
         [0,caml_string_of_jsbytes("argtanh"),51],
         [0,caml_string_of_jsbytes("sub2"),53],
         [0,caml_string_of_jsbytes("floor_power2"),54],
         [0,caml_string_of_jsbytes("interval"),55]]),
     _q2_=caml_string_of_jsbytes("\n"),
     _q1_=caml_string_of_jsbytes(""),
     _qZ_=
      [0,
       [15,[11,caml_string_of_jsbytes(": "),[2,0,0]]],
       caml_string_of_jsbytes("%a: %s")],
     _q0_=
      [0,
       [15,[11,caml_string_of_jsbytes(": syntax error"),0]],
       caml_string_of_jsbytes("%a: syntax error")],
     _qV_=caml_string_of_jsbytes(""),
     _qW_=caml_string_of_jsbytes(""),
     _qY_=caml_string_of_jsbytes(", "),
     _qX_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes("line "),
         [4,
          0,
          0,
          0,
          [11,
           caml_string_of_jsbytes(", characters "),
           [4,
            0,
            0,
            0,
            [12,
             45,
             [4,0,0,0,[11,caml_string_of_jsbytes(" ("),[2,0,[12,41,0]]]]]]]]]],
       caml_string_of_jsbytes("%sline %d, characters %d-%d (%s)")],
     _q$_=caml_string_of_jsbytes(")"),
     _ra_=caml_string_of_jsbytes("factor("),
     _q9_=
      [0,
       [11,caml_string_of_jsbytes("Simplification failed: "),[2,0,0]],
       caml_string_of_jsbytes("Simplification failed: %s")],
     _q__=
      [0,
       [11,caml_string_of_jsbytes("Simplification failed (unknown error)"),0],
       caml_string_of_jsbytes("Simplification failed (unknown error)")],
     _q6_=
      [0,
       [11,
        caml_string_of_jsbytes("Cannot parse Maxima output: '"),
        [2,0,[12,39,0]]],
       caml_string_of_jsbytes("Cannot parse Maxima output: '%s'")],
     _q7_=
      [0,
       [11,
        caml_string_of_jsbytes("Cannot parse Maxima output: '"),
        [2,0,[12,39,0]]],
       caml_string_of_jsbytes("Cannot parse Maxima output: '%s'")],
     _q8_=caml_string_of_jsbytes("parsing error"),
     _q3_=
      caml_string_of_jsbytes
       (";' | maxima | grep '^(%o3)' | sed -e 's/^(%o3) //' > "),
     _q4_=caml_string_of_jsbytes("echo 'linel:20000; display2d:false;"),
     _q5_=caml_string_of_jsbytes("maxima: "),
     _rc_=caml_string_of_jsbytes("opt-timeout"),
     _rd_=caml_string_of_jsbytes("opt-max-iters"),
     _re_=caml_string_of_jsbytes("opt-x-abs-tol"),
     _rf_=caml_string_of_jsbytes("opt-x-rel-tol"),
     _rg_=caml_string_of_jsbytes("opt-f-abs-tol"),
     _rh_=caml_string_of_jsbytes("opt-f-rel-tol"),
     _rb_=
      [0,
       [11,
        caml_string_of_jsbytes("Bad tolerance value: "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(" = "),
          [8,
           3,
           0,
           0,
           [11,caml_string_of_jsbytes(". Using default value: "),[8,3,0,0,0]]]]]],
       caml_string_of_jsbytes
        ("Bad tolerance value: %s = %e. Using default value: %e")],
     _rP_=caml_string_of_jsbytes('"'),
     _rQ_=caml_string_of_jsbytes('"'),
     _rM_=
      [0,
       [11,
        caml_string_of_jsbytes("bb_opt: x_abs_tol = "),
        [8,
         3,
         0,
         0,
         [11,
          caml_string_of_jsbytes(", f_rel_tol = "),
          [8,
           3,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", f_abs_tol = "),
            [8,3,0,0,[11,caml_string_of_jsbytes(", iters = "),[4,0,0,0,0]]]]]]]],
       caml_string_of_jsbytes
        ("bb_opt: x_abs_tol = %e, f_rel_tol = %e, f_abs_tol = %e, iters = %d")],
     _rN_=
      [0,
       [11,
        caml_string_of_jsbytes("bb_"),
        [4,0,0,0,[11,caml_string_of_jsbytes(".ml"),0]]],
       caml_string_of_jsbytes("bb_%d.ml")],
     _rO_=caml_string_of_jsbytes("bb"),
     _rR_=caml_string_of_jsbytes("bb-compile"),
     _rS_=caml_string_of_jsbytes("{base}"),
     _rT_=caml_string_of_jsbytes("{out}"),
     _rU_=caml_string_of_jsbytes("{input}"),
     _rV_=caml_string_of_jsbytes("min = "),
     _rW_=caml_string_of_jsbytes("max = "),
     _rX_=caml_string_of_jsbytes("iter_max = "),
     _rY_=[0,0.],
     _rZ_=caml_string_of_jsbytes("iter_min = "),
     _r0_=[0,0.],
     _r1_=caml_string_of_jsbytes("lower_max = "),
     _r2_=caml_string_of_jsbytes("lower_min = "),
     _r3_=
      [0,
       [11,
        caml_string_of_jsbytes("iterations(min = "),
        [4,
         0,
         0,
         0,
         [11,
          caml_string_of_jsbytes(", max = "),
          [4,0,0,0,[11,caml_string_of_jsbytes("): "),[4,0,0,0,0]]]]]],
       caml_string_of_jsbytes("iterations(min = %d, max = %d): %d")],
     _r4_=
      [0,
       [11,
        caml_string_of_jsbytes("min = "),
        [8,
         3,
         0,
         0,
         [11,caml_string_of_jsbytes(" (lower_min = "),[8,3,0,0,[12,41,0]]]]],
       caml_string_of_jsbytes("min = %e (lower_min = %e)")],
     _r5_=
      [0,
       [11,
        caml_string_of_jsbytes("max = "),
        [8,
         3,
         0,
         0,
         [11,caml_string_of_jsbytes(" (lower_max = "),[8,3,0,0,[12,41,0]]]]],
       caml_string_of_jsbytes("max = %e (lower_max = %e)")],
     _r6_=
      [0,
       [11,
        caml_string_of_jsbytes("subopt = "),
        [8,
         3,
         0,
         0,
         [11,caml_string_of_jsbytes(" ("),[8,0,0,[0,1],[12,37,[12,41,0]]]]]],
       caml_string_of_jsbytes("subopt = %e (%.1f%%)")],
     _rJ_=caml_string_of_jsbytes("bb-alg"),
     _rK_=caml_string_of_jsbytes("opt0"),
     _rL_=
      [0,
       [11,caml_string_of_jsbytes("Unknown bb algorithm: "),[2,0,0]],
       caml_string_of_jsbytes("Unknown bb algorithm: %s")],
     _rF_=
      [0,
       [11,
        caml_string_of_jsbytes("  let var_"),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(" = input_array.("),
          [4,0,0,0,[11,caml_string_of_jsbytes(") in"),0]]]]],
       caml_string_of_jsbytes("  let var_%s = input_array.(%d) in")],
     _rH_=
      [0,
       [11,
        caml_string_of_jsbytes("  let ref_"),
        [4,
         0,
         0,
         0,
         [11,
          caml_string_of_jsbytes(" = "),
          [15,[11,caml_string_of_jsbytes(" in"),[17,4,0]]]]]],
       caml_string_of_jsbytes("  let ref_%d = %a in@.")],
     _rI_=
      [0,
       [11,caml_string_of_jsbytes("  "),[15,[17,4,0]]],
       caml_string_of_jsbytes("  %a@.")],
     _rG_=caml_string_of_jsbytes("let f_X input_array = "),
     _rA_=
      [0,
       [11,
        caml_string_of_jsbytes("| "),
        [4,0,0,0,[11,caml_string_of_jsbytes(" -> "),[2,0,0]]]],
       caml_string_of_jsbytes("| %d -> %s")],
     _rB_=caml_string_of_jsbytes('| _ -> failwith "Out of boundaries"'),
     _rC_=
      [0,
       [11,
        caml_string_of_jsbytes("{low = "),
        [8,
         3,
         0,
         [0,20],
         [11,caml_string_of_jsbytes("; high = "),[8,3,0,[0,20],[12,125,0]]]]],
       caml_string_of_jsbytes("{low = %.20e; high = %.20e}")],
     _rD_=
      [0,
       [11,
        caml_string_of_jsbytes("let start_interval = Array.init "),
        [4,0,0,0,[11,caml_string_of_jsbytes(" (function"),0]]],
       caml_string_of_jsbytes("let start_interval = Array.init %d (function")],
     _rE_=caml_string_of_jsbytes(")"),
     _rl_=caml_string_of_jsbytes(""),
     _rm_=caml_string_of_jsbytes("let _ ="),
     _rn_=
      [0,
       [11,
        caml_string_of_jsbytes("  let x_tol = size_max_X start_interval *. "),
        [8,
         3,
         0,
         0,
         [11,
          caml_string_of_jsbytes(" +. "),
          [8,3,0,0,[11,caml_string_of_jsbytes(" in"),0]]]]],
       caml_string_of_jsbytes
        ("  let x_tol = size_max_X start_interval *. %e +. %e in")],
     _ro_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("  let upper_bound, lower_bound, c = Opt0.opt f_X start_interval x_tol ("),
        [8,
         3,
         0,
         0,
         [11,
          caml_string_of_jsbytes(") ("),
          [8,
           3,
           0,
           0,
           [11,
            caml_string_of_jsbytes(") ("),
            [4,0,0,0,[11,caml_string_of_jsbytes(") in"),0]]]]]]],
       caml_string_of_jsbytes
        ("  let upper_bound, lower_bound, c = Opt0.opt f_X start_interval x_tol (%e) (%e) (%d) in")],
     _rp_=
      caml_string_of_jsbytes
       ('  let () = Printf.printf "iter_max = %d\\n" c in'),
     _rq_=
      caml_string_of_jsbytes
       ('  let () = Printf.printf "max = %0.20e\\n" upper_bound in'),
     _rr_=
      caml_string_of_jsbytes
       ('  let () = Printf.printf "lower_max = %0.20e\\n" lower_bound in'),
     _rs_=
      caml_string_of_jsbytes('  let () = Printf.printf "iter_min = 0\\n" in'),
     _rt_=caml_string_of_jsbytes('  let () = Printf.printf "min = 0\\n" in'),
     _ru_=
      caml_string_of_jsbytes('  let () = Printf.printf "lower_min = 0\\n" in'),
     _rw_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("  let upper_bound, lower_bound, c = Opt0.opt (fun x -> ~-$ (f_X x)) start_interval x_tol ("),
        [8,
         3,
         0,
         0,
         [11,
          caml_string_of_jsbytes(") ("),
          [8,
           3,
           0,
           0,
           [11,
            caml_string_of_jsbytes(") ("),
            [4,0,0,0,[11,caml_string_of_jsbytes(") in"),0]]]]]]],
       caml_string_of_jsbytes
        ("  let upper_bound, lower_bound, c = Opt0.opt (fun x -> ~-$ (f_X x)) start_interval x_tol (%e) (%e) (%d) in")],
     _rx_=
      caml_string_of_jsbytes
       ('  let () = Printf.printf "iter_min = %d\\n" c in'),
     _ry_=
      caml_string_of_jsbytes
       ('  let () = Printf.printf "min = %0.20e\\n" (-. upper_bound) in'),
     _rz_=
      caml_string_of_jsbytes
       ('  let () = Printf.printf "lower_min = %0.20e\\n" (-. lower_bound) in'),
     _rv_=caml_string_of_jsbytes("  flush stdout"),
     _ri_=caml_string_of_jsbytes("open Interval"),
     _rj_=caml_string_of_jsbytes("open Opt_func"),
     _rk_=caml_string_of_jsbytes(""),
     _sj_=
      [0,
       [11,
        caml_string_of_jsbytes("gelpia_"),
        [4,0,0,0,[11,caml_string_of_jsbytes(".txt"),0]]],
       caml_string_of_jsbytes("gelpia_%d.txt")],
     _sk_=caml_string_of_jsbytes("max"),
     _sq_=caml_string_of_jsbytes("min-max"),
     _sl_=
      [0,
       [2,0,[11,caml_string_of_jsbytes(" --mode="),[2,0,[12,32,[2,0,0]]]]],
       caml_string_of_jsbytes("%s --mode=%s %s")],
     _sp_=caml_string_of_jsbytes("Minimum lower bound "),
     _so_=caml_string_of_jsbytes("Maximum upper bound "),
     _sm_=caml_string_of_jsbytes("\n"),
     _sn_=caml_string_of_jsbytes("GELPIA error: "),
     _si_=caml_string_of_jsbytes("GELPIA_PATH"),
     _sd_=caml_string_of_jsbytes("gelpia"),
     _se_=caml_string_of_jsbytes("gelpia"),
     _sf_=caml_string_of_jsbytes("bin"),
     _sg_=
      caml_string_of_jsbytes
       ("Set the GELPIA_PATH variable or copy GELPIA to the FPTaylor root directory."),
     _sh_=caml_string_of_jsbytes(" not found.\n"),
     _sc_=caml_string_of_jsbytes("var_"),
     _sa_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(" = ["),
         [8,
          3,
          0,
          [0,20],
          [11,
           caml_string_of_jsbytes(", "),
           [8,3,0,[0,20],[11,caml_string_of_jsbytes("];\n"),0]]]]]],
       caml_string_of_jsbytes("%s = [%.20e, %.20e];\n")],
     _sb_=caml_string_of_jsbytes(""),
     _r7_=
      [0,
       [11,caml_string_of_jsbytes("# --input-epsilon "),[8,3,0,0,0]],
       caml_string_of_jsbytes("# --input-epsilon %e")],
     _r8_=
      [0,
       [11,caml_string_of_jsbytes("# --output-epsilon "),[8,3,0,0,0]],
       caml_string_of_jsbytes("# --output-epsilon %e")],
     _r9_=
      [0,
       [11,caml_string_of_jsbytes("# --output-epsilon-relative "),[8,3,0,0,0]],
       caml_string_of_jsbytes("# --output-epsilon-relative %e")],
     _r__=
      [0,
       [11,caml_string_of_jsbytes("# --timeout "),[4,0,0,0,0]],
       caml_string_of_jsbytes("# --timeout %d")],
     _r$_=
      [0,
       [11,caml_string_of_jsbytes("# --max-iters "),[4,0,0,0,0]],
       caml_string_of_jsbytes("# --max-iters %d")],
     _s1_=
      [0,
       [11,
        caml_string_of_jsbytes("min_max_"),
        [4,0,0,0,[11,caml_string_of_jsbytes(".py"),0]]],
       caml_string_of_jsbytes("min_max_%d.py")],
     _ta_=caml_string_of_jsbytes("PYTHONPATH"),
     _s2_=caml_string_of_jsbytes(""),
     _s3_=caml_string_of_jsbytes("z3opt"),
     _s4_=caml_string_of_jsbytes("z3-python-lib"),
     _s$_=caml_string_of_jsbytes("LD_LIBRARY_PATH"),
     _s5_=caml_string_of_jsbytes(""),
     _s6_=caml_string_of_jsbytes("z3-bin"),
     _s7_=caml_string_of_jsbytes("z3-python-cmd"),
     _s8_=
      [0,
       [11,
        caml_string_of_jsbytes('LD_LIBRARY_PATH="'),
        [2,
         0,
         [11,
          caml_string_of_jsbytes('" PYTHONPATH="'),
          [2,
           0,
           [11,
            caml_string_of_jsbytes('" '),
            [2,0,[11,caml_string_of_jsbytes(' "'),[2,0,[12,34,0]]]]]]]]],
       caml_string_of_jsbytes('LD_LIBRARY_PATH="%s" PYTHONPATH="%s" %s "%s"')],
     _s9_=caml_string_of_jsbytes("min = "),
     _s__=caml_string_of_jsbytes("max = "),
     _s0_=caml_string_of_jsbytes("var_"),
     _sZ_=caml_string_of_jsbytes("f = "),
     _sS_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(" >= "),
         [2,
          0,
          [11,
           caml_string_of_jsbytes(", "),
           [2,0,[11,caml_string_of_jsbytes(" <= "),[2,0,0]]]]]]],
       caml_string_of_jsbytes("%s >= %s, %s <= %s")],
     _sT_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(" >= "),
         [2,
          0,
          [11,
           caml_string_of_jsbytes(", "),
           [2,0,[11,caml_string_of_jsbytes(" <= "),[2,0,0]]]]]]],
       caml_string_of_jsbytes("%s >= %s, %s <= %s")],
     _sR_=
      [0,
       [2,0,[11,caml_string_of_jsbytes(" = "),[2,0,0]]],
       caml_string_of_jsbytes("%s = %s")],
     _sQ_=caml_string_of_jsbytes("var_constraints = []"),
     _sU_=caml_string_of_jsbytes(", "),
     _sV_=
      [0,
       [12,
        91,
        [2,
         0,
         [11,
          caml_string_of_jsbytes("] = Reals('"),
          [2,0,[11,caml_string_of_jsbytes("')"),0]]]]],
       caml_string_of_jsbytes("[%s] = Reals('%s')")],
     _sW_=caml_string_of_jsbytes("\n"),
     _sX_=caml_string_of_jsbytes(", "),
     _sY_=
      [0,
       [11,caml_string_of_jsbytes("var_constraints = ["),[2,0,[12,93,0]]],
       caml_string_of_jsbytes("var_constraints = [%s]")],
     _sO_=caml_string_of_jsbytes(", "),
     _sM_=caml_string_of_jsbytes("constraints = []"),
     _sN_=caml_string_of_jsbytes("constraints = ["),
     _sP_=caml_string_of_jsbytes("]"),
     _sL_=
      caml_string_of_jsbytes
       ("z3opt: constraint_vars(): unsupported constraint"),
     _sJ_=caml_string_of_jsbytes(" < "),
     _sK_=
      caml_string_of_jsbytes
       ("z3opt: print_constraint(): unsupported constraint"),
     _sI_=caml_string_of_jsbytes("gen_z3py_opt_code: interval constant"),
     _sF_=caml_string_of_jsbytes(")"),
     _sG_=caml_string_of_jsbytes(","),
     _sH_=caml_string_of_jsbytes("Q("),
     _sv_=caml_string_of_jsbytes("True"),
     _sE_=caml_string_of_jsbytes("False"),
     _sw_=caml_string_of_jsbytes("z3-interval-bounds"),
     _sx_=caml_string_of_jsbytes(""),
     _sy_=
      [0,
       [12,
        40,
        [8,
         3,
         0,
         [0,20],
         [11,caml_string_of_jsbytes(", "),[8,3,0,[0,20],[12,41,0]]]]],
       caml_string_of_jsbytes("(%.20e, %.20e)")],
     _sD_=caml_string_of_jsbytes("None"),
     _sz_=caml_string_of_jsbytes(""),
     _sA_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("l, u = find_bounds(f, var_constraints + constraints, f_abs_tol="),
        [8,
         3,
         0,
         0,
         [11,
          caml_string_of_jsbytes(", f_rel_tol="),
          [8,
           3,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", timeout="),
            [4,
             0,
             0,
             0,
             [11,
              caml_string_of_jsbytes(", seed="),
              [4,
               0,
               0,
               0,
               [11,caml_string_of_jsbytes(", max_only="),[2,0,partial$0]]]]]]]]]],
       caml_string_of_jsbytes
        ("l, u = find_bounds(f, var_constraints + constraints, f_abs_tol=%e, f_rel_tol=%e, timeout=%d, seed=%d, max_only=%s, bounds=%s)")],
     _sB_=caml_string_of_jsbytes("print('min = {0:.20e}'.format(l))"),
     _sC_=caml_string_of_jsbytes("print('max = {0:.20e}'.format(u))"),
     _ss_=caml_string_of_jsbytes("from z3opt import *"),
     _st_=caml_string_of_jsbytes("from z3 import *"),
     _su_=caml_string_of_jsbytes(""),
     _sr_=caml_string_of_jsbytes("z3-seed"),
     _tV_=caml_string_of_jsbytes("nlopt-f.c"),
     _tW_=caml_string_of_jsbytes("nlopt-f"),
     _tX_=caml_string_of_jsbytes("nlopt-cc"),
     _tY_=caml_string_of_jsbytes("nlopt-lib"),
     _tZ_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(" -o "),
         [2,0,[12,32,[2,0,[12,32,[2,0,0]]]]]]],
       caml_string_of_jsbytes("%s -o %s %s %s")],
     _t4_=caml_string_of_jsbytes("\n"),
     _t5_=caml_string_of_jsbytes("Compilation ERROR: "),
     _t0_=caml_string_of_jsbytes("\n"),
     _t1_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _t2_=caml_string_of_jsbytes("min: "),
     _t3_=caml_string_of_jsbytes("max: "),
     _tB_=caml_string_of_jsbytes("int main() {"),
     _tC_=
      [0,
       [11,
        caml_string_of_jsbytes("  nlopt_opt opt = nlopt_create("),
        [4,
         0,
         0,
         0,
         [11,
          caml_string_of_jsbytes(", "),
          [4,0,0,0,[11,caml_string_of_jsbytes(");"),0]]]]],
       caml_string_of_jsbytes("  nlopt_opt opt = nlopt_create(%d, %d);")],
     _tD_=caml_string_of_jsbytes("  double f_min = 0.0, f_max = 0.0;"),
     _tE_=caml_string_of_jsbytes("  // min"),
     _tF_=caml_string_of_jsbytes("  nlopt_set_min_objective(opt, f, NULL);"),
     _tG_=
      caml_string_of_jsbytes
       ("  nlopt_result result_min = nlopt_optimize(opt, x_min, &f_min);"),
     _tH_=caml_string_of_jsbytes("  // max"),
     _tI_=caml_string_of_jsbytes("  nlopt_set_max_objective(opt, f, NULL);"),
     _tJ_=
      caml_string_of_jsbytes
       ("  nlopt_result result_max = nlopt_optimize(opt, x_max, &f_max);"),
     _tK_=caml_string_of_jsbytes('  printf("NLOpt results:\\n");'),
     _tL_=caml_string_of_jsbytes('  printf("result_min: %d\\n", result_min);'),
     _tM_=caml_string_of_jsbytes('  printf("result_max: %d\\n", result_max);'),
     _tN_=caml_string_of_jsbytes('  printf("min: %.20e\\n", f_min);'),
     _tO_=caml_string_of_jsbytes('  printf("max: %.20e\\n", f_max);'),
     _tP_=caml_string_of_jsbytes('  printf("x_min: ");'),
     _tQ_=
      caml_string_of_jsbytes
       ('  for (int i = 0; i < sizeof(x_min) / sizeof(double); i++) { printf("%.20e, ", x_min[i]); }'),
     _tR_=caml_string_of_jsbytes('  printf("\\nx_max: ");'),
     _tS_=
      caml_string_of_jsbytes
       ('  for (int i = 0; i < sizeof(x_max) / sizeof(double); i++) { printf("%.20e, ", x_max[i]); }'),
     _tT_=caml_string_of_jsbytes("  return 0;"),
     _tU_=caml_string_of_jsbytes("}"),
     _tq_=caml_string_of_jsbytes("  // Bounds"),
     _tr_=
      [0,
       [11,
        caml_string_of_jsbytes("  nlopt_set_lower_bounds(opt, (double[])"),
        [2,0,[11,caml_string_of_jsbytes(");"),0]]],
       caml_string_of_jsbytes("  nlopt_set_lower_bounds(opt, (double[])%s);")],
     _ts_=
      [0,
       [11,
        caml_string_of_jsbytes("  nlopt_set_upper_bounds(opt, (double[])"),
        [2,0,[11,caml_string_of_jsbytes(");"),0]]],
       caml_string_of_jsbytes("  nlopt_set_upper_bounds(opt, (double[])%s);")],
     _tt_=caml_string_of_jsbytes("  // Stopping criteria"),
     _tu_=
      [0,
       [11,
        caml_string_of_jsbytes("  nlopt_set_ftol_abs(opt, "),
        [8,0,0,0,[11,caml_string_of_jsbytes(");"),0]]],
       caml_string_of_jsbytes("  nlopt_set_ftol_abs(opt, %f);")],
     _tv_=
      [0,
       [11,
        caml_string_of_jsbytes("  nlopt_set_maxeval(opt, "),
        [4,0,0,0,[11,caml_string_of_jsbytes(");"),0]]],
       caml_string_of_jsbytes("  nlopt_set_maxeval(opt, %d);")],
     _tw_=caml_string_of_jsbytes("  // x0"),
     _tx_=caml_string_of_jsbytes(";"),
     _ty_=caml_string_of_jsbytes("  double x_min[] = "),
     _tz_=caml_string_of_jsbytes(";"),
     _tA_=caml_string_of_jsbytes("  double x_max[] = "),
     _tn_=caml_string_of_jsbytes("}"),
     _to_=caml_string_of_jsbytes(","),
     _tp_=caml_string_of_jsbytes("{"),
     _tf_=
      [0,
       [11,
        caml_string_of_jsbytes("  double var_"),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(" = _x["),
          [4,0,0,0,[11,caml_string_of_jsbytes("];"),0]]]]],
       caml_string_of_jsbytes("  double var_%s = _x[%d];")],
     _tg_=
      caml_string_of_jsbytes
       ("double f(unsigned _n, const double *_x, double *_grad, void *_f_data) {"),
     _th_=caml_string_of_jsbytes("  double _result = "),
     _ti_=caml_string_of_jsbytes(";"),
     _tj_=caml_string_of_jsbytes("  if (_grad) {"),
     _tk_=caml_string_of_jsbytes("  }"),
     _tl_=caml_string_of_jsbytes("  return _result;"),
     _tm_=caml_string_of_jsbytes("}"),
     _tb_=caml_string_of_jsbytes("#include <stdio.h>"),
     _tc_=caml_string_of_jsbytes("#include <math.h>"),
     _td_=caml_string_of_jsbytes("#include <nlopt.h>"),
     _te_=caml_string_of_jsbytes(""),
     _t8_=
      caml_string_of_jsbytes("eval_expr': Unsupported general operation: "),
     _t9_=caml_string_of_jsbytes("eval_expr'_list: empty list"),
     _t__=
      [0,
       [11,
        caml_string_of_jsbytes("bb-eval_opt: x_abs_tol = "),
        [8,
         3,
         0,
         0,
         [11,
          caml_string_of_jsbytes(", f_rel_tol = "),
          [8,
           3,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", f_abs_tol = "),
            [8,3,0,0,[11,caml_string_of_jsbytes(", iters = "),[4,0,0,0,0]]]]]]]],
       caml_string_of_jsbytes
        ("bb-eval_opt: x_abs_tol = %e, f_rel_tol = %e, f_abs_tol = %e, iters = %d")],
     _t6_=caml_string_of_jsbytes("Rounding is not supported"),
     _t7_=caml_string_of_jsbytes("expr'_of_expr: Op_nat_pow"),
     _ui_=
      [0,
       [11,
        caml_string_of_jsbytes("rmin(result = "),
        [8,
         3,
         0,
         0,
         [11,
          caml_string_of_jsbytes(", lower = "),
          [8,
           3,
           0,
           0,
           [11,
            caml_string_of_jsbytes("), rmax(result = "),
            [8,
             3,
             0,
             0,
             [11,caml_string_of_jsbytes(", lower = "),[8,3,0,0,[12,41,0]]]]]]]]],
       caml_string_of_jsbytes
        ("rmin(result = %e, lower = %e), rmax(result = %e, lower = %e)")],
     _t$_=caml_string_of_jsbytes("opt"),
     _ua_=caml_string_of_jsbytes("bb"),
     _ub_=caml_string_of_jsbytes("bb-eval"),
     _uc_=caml_string_of_jsbytes("gelpia"),
     _ud_=caml_string_of_jsbytes("nlopt"),
     _ue_=caml_string_of_jsbytes("z3"),
     _ug_=[0,[8,3,0,[0,5],0],caml_string_of_jsbytes("%.5e")],
     _uh_=
      [0,
       [11,caml_string_of_jsbytes("Interval bounds for Z3: "),[2,0,0]],
       caml_string_of_jsbytes("Interval bounds for Z3: %s")],
     _uf_=caml_string_of_jsbytes("Unsupported optimization backend: "),
     _un_=caml_string_of_jsbytes("rnd32"),
     _uo_=caml_string_of_jsbytes("rnd64"),
     _uq_=caml_string_of_jsbytes("Division by zero"),
     _ur_=caml_string_of_jsbytes("Sqrt of negative number"),
     _us_=caml_string_of_jsbytes("Arcsine of an invalid argument"),
     _ut_=caml_string_of_jsbytes("Arccosine of an invalid argument"),
     _uu_=caml_string_of_jsbytes("Log of non-positive number"),
     _uv_=caml_string_of_jsbytes("arcosh of x < 1.0"),
     _uw_=caml_string_of_jsbytes("artanh of an argument outside of (-1, 1)"),
     _ux_=caml_string_of_jsbytes("Division by zero"),
     _uy_=caml_string_of_jsbytes("check_expr: Unsupported binary operation: "),
     _uz_=
      caml_string_of_jsbytes("check_expr: Unsupported general operation: "),
     _up_=caml_string_of_jsbytes(""),
     _ul_=[0,0],
     _um_=[0,1],
     _uk_=[0,0],
     _uj_=caml_string_of_jsbytes("Rounding_simpl.Exceptional_operation"),
     _uS_=caml_string_of_jsbytes(" "),
     _uQ_=caml_string_of_jsbytes("real"),
     _uR_=caml_string_of_jsbytes("ne"),
     _uT_=
      [0,
       [11,caml_string_of_jsbytes("(FPCore ("),[15,[12,41,[17,4,0]]]],
       caml_string_of_jsbytes("(FPCore (%a)@.")],
     _uU_=
      [0,
       [11,caml_string_of_jsbytes('  :name "'),[2,0,[12,34,[17,4,0]]]],
       caml_string_of_jsbytes('  :name "%s"@.')],
     _uV_=
      [0,
       [11,
        caml_string_of_jsbytes('  :description "Generated by FPTaylor"'),
        [17,4,0]],
       caml_string_of_jsbytes('  :description "Generated by FPTaylor"@.')],
     _uW_=
      [0,
       [11,caml_string_of_jsbytes("  :precision "),[2,0,[17,4,0]]],
       caml_string_of_jsbytes("  :precision %s@.")],
     _uY_=
      [0,
       [11,caml_string_of_jsbytes("  :pre (and "),[15,[12,41,[17,4,0]]]],
       caml_string_of_jsbytes("  :pre (and %a)@.")],
     _uZ_=
      [0,
       [11,
        caml_string_of_jsbytes("  :pre (and "),
        [15,[12,32,[15,[12,41,[17,4,0]]]]]],
       caml_string_of_jsbytes("  :pre (and %a %a)@.")],
     _uX_=
      [0,
       [11,caml_string_of_jsbytes("  "),[15,[12,41,[17,4,[17,4,0]]]]],
       caml_string_of_jsbytes("  %a)@.@.")],
     _uP_=caml_string_of_jsbytes(" "),
     _uN_=
      [0,
       [11,
        caml_string_of_jsbytes("(<= "),
        [2,0,[12,32,[2,0,[12,32,[2,0,[12,41,0]]]]]]],
       caml_string_of_jsbytes("(<= %s %s %s)")],
     _uO_=caml_string_of_jsbytes(" "),
     _uM_=caml_string_of_jsbytes("ne"),
     _uD_=caml_string_of_jsbytes("rnd128"),
     _uE_=caml_string_of_jsbytes("rnd16"),
     _uF_=caml_string_of_jsbytes("rnd32"),
     _uG_=caml_string_of_jsbytes("rnd64"),
     _uI_=caml_string_of_jsbytes("binary64"),
     _uJ_=caml_string_of_jsbytes("binary32"),
     _uK_=caml_string_of_jsbytes("binary16"),
     _uL_=caml_string_of_jsbytes("binary128"),
     _uH_=caml_string_of_jsbytes("real"),
     _uA_=
      [0,
       [11,caml_string_of_jsbytes("(<= "),[15,[12,32,[15,[12,41,0]]]]],
       caml_string_of_jsbytes("(<= %a %a)")],
     _uB_=
      [0,
       [11,caml_string_of_jsbytes("(< "),[15,[12,32,[15,[12,41,0]]]]],
       caml_string_of_jsbytes("(< %a %a)")],
     _uC_=
      [0,
       [11,caml_string_of_jsbytes("(== "),[15,[12,32,[15,[12,41,0]]]]],
       caml_string_of_jsbytes("(== %a %a)")],
     _xu_=caml_string_of_jsbytes(""),
     _xv_=caml_string_of_jsbytes("f_high"),
     _xm_=[0,[8,3,0,[0,20],0],caml_string_of_jsbytes("%.20e")],
     _xl_=[0,[8,3,0,[0,20],0],caml_string_of_jsbytes("%.20e")],
     _xh_=caml_string_of_jsbytes("v_"),
     _xA_=[0,[254,1.,2.],0],
     _xi_=
      [0,
       [11,caml_string_of_jsbytes('#include "data_mpfi.h"'),[17,4,0]],
       caml_string_of_jsbytes('#include "data_mpfi.h"@.')],
     _xj_=
      [0,
       [11,caml_string_of_jsbytes('#include "func.h"'),[17,4,0]],
       caml_string_of_jsbytes('#include "func.h"@.')],
     _xk_=[0,1],
     _xn_=caml_string_of_jsbytes(", "),
     _xo_=
      [0,
       [11,
        caml_string_of_jsbytes("const double low[] = {"),
        [15,[11,caml_string_of_jsbytes("};"),[17,4,0]]]],
       caml_string_of_jsbytes("const double low[] = {%a};@.")],
     _xp_=caml_string_of_jsbytes(", "),
     _xq_=
      [0,
       [11,
        caml_string_of_jsbytes("const double high[] = {"),
        [15,[11,caml_string_of_jsbytes("};"),[17,4,0]]]],
       caml_string_of_jsbytes("const double high[] = {%a};@.")],
     _xr_=[0,[12,34,[2,0,[12,34,0]]],caml_string_of_jsbytes('"%s"')],
     _xs_=caml_string_of_jsbytes(", "),
     _xt_=
      [0,
       [11,
        caml_string_of_jsbytes("const char *f_names[] = {"),
        [15,[11,caml_string_of_jsbytes("};"),[17,4,0]]]],
       caml_string_of_jsbytes("const char *f_names[] = {%a};@.")],
     _xw_=
      [0,
       [11,
        caml_string_of_jsbytes("const int n_funcs = "),
        [4,0,0,0,[12,59,[17,4,0]]]],
       caml_string_of_jsbytes("const int n_funcs = %d;@.")],
     _xx_=caml_string_of_jsbytes(", "),
     _xy_=
      [0,
       [11,
        caml_string_of_jsbytes("const F_HIGH funcs[] = {"),
        [15,[11,caml_string_of_jsbytes("};"),[17,4,0]]]],
       caml_string_of_jsbytes("const F_HIGH funcs[] = {%a};@.")],
     _xz_=
      [0,
       [11,
        caml_string_of_jsbytes('const char *expression_string = "'),
        [2,0,[11,caml_string_of_jsbytes('";'),[17,4,0]]]],
       caml_string_of_jsbytes('const char *expression_string = "%s";@.')],
     _xa_=[0,[8,3,0,[0,20],0],caml_string_of_jsbytes("%.20e")],
     _w$_=[0,[8,3,0,[0,20],0],caml_string_of_jsbytes("%.20e")],
     _wZ_=caml_string_of_jsbytes("v_"),
     _xg_=[0,[254,1.,2.],0],
     _w0_=
      [0,
       [11,caml_string_of_jsbytes("#ifdef USE_MPFI"),[17,4,0]],
       caml_string_of_jsbytes("#ifdef USE_MPFI@.")],
     _w1_=
      [0,
       [17,4,[11,caml_string_of_jsbytes('#include "search_mpfi.h"'),[17,4,0]]],
       caml_string_of_jsbytes('@.#include "search_mpfi.h"@.')],
     _w2_=[0,1],
     _w3_=[0,1],
     _w4_=[0,1],
     _w5_=
      [0,
       [17,4,[11,caml_string_of_jsbytes("#else"),[17,4,0]]],
       caml_string_of_jsbytes("@.#else@.")],
     _w6_=
      [0,
       [17,4,[11,caml_string_of_jsbytes('#include "search_mpfr.h"'),[17,4,0]]],
       caml_string_of_jsbytes('@.#include "search_mpfr.h"@.')],
     _w7_=[0,0],
     _w8_=[0,1],
     _w9_=[0,1],
     _w__=
      [0,
       [17,4,[11,caml_string_of_jsbytes("#endif"),[17,4,0]]],
       caml_string_of_jsbytes("@.#endif@.")],
     _xb_=caml_string_of_jsbytes(", "),
     _xc_=
      [0,
       [11,
        caml_string_of_jsbytes("const double low[] = {"),
        [15,[11,caml_string_of_jsbytes("};"),[17,4,0]]]],
       caml_string_of_jsbytes("const double low[] = {%a};@.")],
     _xd_=caml_string_of_jsbytes(", "),
     _xe_=
      [0,
       [11,
        caml_string_of_jsbytes("const double high[] = {"),
        [15,[11,caml_string_of_jsbytes("};"),[17,4,0]]]],
       caml_string_of_jsbytes("const double high[] = {%a};@.")],
     _xf_=
      [0,
       [11,
        caml_string_of_jsbytes('const char *f_name = "'),
        [2,0,[11,caml_string_of_jsbytes('";'),[17,4,0]]]],
       caml_string_of_jsbytes('const char *f_name = "%s";@.')],
     _wY_=[0,[2,0,[17,4,0]],caml_string_of_jsbytes("%s@.")],
     _wU_=caml_string_of_jsbytes("float "),
     _wV_=caml_string_of_jsbytes(", "),
     _wW_=
      [0,
       [11,
        caml_string_of_jsbytes("float f_32("),
        [15,[12,41,[17,4,[12,123,[17,4,0]]]]]],
       caml_string_of_jsbytes("float f_32(%a)@.{@.")],
     _wX_=
      [0,
       [2,
        0,
        [17,
         4,
         [11,
          caml_string_of_jsbytes("  return "),
          [2,0,[12,59,[17,4,[12,125,[17,4,0]]]]]]]],
       caml_string_of_jsbytes("%s@.  return %s;@.}@.")],
     _wQ_=caml_string_of_jsbytes("double "),
     _wR_=caml_string_of_jsbytes(", "),
     _wS_=
      [0,
       [11,
        caml_string_of_jsbytes("double f_64("),
        [15,[12,41,[17,4,[12,123,[17,4,0]]]]]],
       caml_string_of_jsbytes("double f_64(%a)@.{@.")],
     _wT_=
      [0,
       [2,
        0,
        [17,
         4,
         [11,
          caml_string_of_jsbytes("  return "),
          [2,0,[12,59,[17,4,[12,125,[17,4,0]]]]]]]],
       caml_string_of_jsbytes("%s@.  return %s;@.}@.")],
     _wE_=caml_string_of_jsbytes("_srcptr "),
     _wC_=caml_string_of_jsbytes("r_op"),
     _wD_=caml_string_of_jsbytes("mpfi"),
     _wP_=caml_string_of_jsbytes("mpfr"),
     _wO_=caml_string_of_jsbytes(""),
     _wF_=caml_string_of_jsbytes("f_high"),
     _wG_=caml_string_of_jsbytes(", "),
     _wH_=caml_string_of_jsbytes("_ptr"),
     _wI_=
      [0,
       [11,
        caml_string_of_jsbytes("void "),
        [2,
         0,
         [12,
          40,
          [2,
           0,
           [11,
            caml_string_of_jsbytes(" r_op, "),
            [15,[12,41,[17,4,[12,123,[17,4,0]]]]]]]]]],
       caml_string_of_jsbytes("void %s(%s r_op, %a)@.{@.")],
     _wJ_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _wK_=caml_string_of_jsbytes("r_op"),
     _wL_=
      [0,
       [11,
        caml_string_of_jsbytes("  mpfi_set(r_op, "),
        [2,0,[11,caml_string_of_jsbytes(");"),[17,4,0]]]],
       caml_string_of_jsbytes("  mpfi_set(r_op, %s);@.")],
     _wN_=
      [0,
       [11,
        caml_string_of_jsbytes("  mpfr_set(r_op, "),
        [2,0,[11,caml_string_of_jsbytes(", MPFR_RNDN);"),[17,4,0]]]],
       caml_string_of_jsbytes("  mpfr_set(r_op, %s, MPFR_RNDN);@.")],
     _wM_=[0,[12,125,[17,4,0]],caml_string_of_jsbytes("}@.")],
     _wA_=
      [0,
       [11,
        caml_string_of_jsbytes("  "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes("_clear("),
          [2,0,[11,caml_string_of_jsbytes(");"),[17,4,0]]]]]],
       caml_string_of_jsbytes("  %s_clear(%s);@.")],
     _wz_=
      [0,
       [11,
        caml_string_of_jsbytes("  "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes("_clear("),
          [2,0,[11,caml_string_of_jsbytes(");"),[17,4,0]]]]]],
       caml_string_of_jsbytes("  %s_clear(%s);@.")],
     _ws_=
      [0,
       [11,caml_string_of_jsbytes("&c_"),[4,0,0,0,[12,102,0]]],
       caml_string_of_jsbytes("&c_%df")],
     _ww_=caml_string_of_jsbytes("NULL"),
     _wt_=
      [0,
       [11,caml_string_of_jsbytes("&c_"),[4,0,0,0,[12,100,0]]],
       caml_string_of_jsbytes("&c_%dd")],
     _wv_=caml_string_of_jsbytes("NULL"),
     _wu_=
      [0,
       [11,
        caml_string_of_jsbytes('  init_constants("'),
        [2,
         0,
         [11,
          caml_string_of_jsbytes('", MPFR_RNDN, '),
          [2,
           0,
           [11,
            caml_string_of_jsbytes(", "),
            [2,
             0,
             [11,
              caml_string_of_jsbytes(", c_"),
              [4,0,0,0,[11,caml_string_of_jsbytes(");"),[17,4,0]]]]]]]]]],
       caml_string_of_jsbytes
        ('  init_constants("%s", MPFR_RNDN, %s, %s, c_%d);@.')],
     _wr_=
      [0,
       [11,
        caml_string_of_jsbytes("  "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes("_init("),
          [2,0,[11,caml_string_of_jsbytes(");"),[17,4,0]]]]]],
       caml_string_of_jsbytes("  %s_init(%s);@.")],
     _wq_=
      [0,
       [11,
        caml_string_of_jsbytes("  "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes("_init("),
          [2,0,[11,caml_string_of_jsbytes(");"),[17,4,0]]]]]],
       caml_string_of_jsbytes("  %s_init(%s);@.")],
     _wg_=
      [0,
       [11,caml_string_of_jsbytes("t_"),[4,0,0,0,0]],
       caml_string_of_jsbytes("t_%d")],
     _wf_=
      [0,
       [11,caml_string_of_jsbytes("c_"),[4,0,0,0,[12,102,0]]],
       caml_string_of_jsbytes("c_%df")],
     _we_=
      [0,
       [11,caml_string_of_jsbytes("c_"),[4,0,0,0,[12,100,0]]],
       caml_string_of_jsbytes("c_%dd")],
     _wd_=
      [0,
       [11,caml_string_of_jsbytes("c_"),[4,0,0,0,0]],
       caml_string_of_jsbytes("c_%d")],
     _wb_=caml_string_of_jsbytes("mpfi"),
     _wc_=caml_string_of_jsbytes("mpfi_t"),
     _wh_=caml_string_of_jsbytes(", "),
     _wi_=
      [0,
       [11,
        caml_string_of_jsbytes("static "),
        [2,0,[12,32,[15,[12,59,[17,4,0]]]]]],
       caml_string_of_jsbytes("static %s %a;@.")],
     _wj_=caml_string_of_jsbytes(", "),
     _wk_=
      [0,
       [11,
        caml_string_of_jsbytes("static "),
        [2,0,[12,32,[15,[12,59,[17,4,0]]]]]],
       caml_string_of_jsbytes("static %s %a;@.")],
     _wl_=caml_string_of_jsbytes(", "),
     _wm_=
      [0,
       [11,caml_string_of_jsbytes("static double "),[15,[12,59,[17,4,0]]]],
       caml_string_of_jsbytes("static double %a;@.")],
     _wn_=caml_string_of_jsbytes(", "),
     _wo_=
      [0,
       [11,caml_string_of_jsbytes("static float "),[15,[12,59,[17,4,0]]]],
       caml_string_of_jsbytes("static float %a;@.")],
     _wp_=
      [0,
       [11,caml_string_of_jsbytes("void f_init()"),[17,4,[12,123,[17,4,0]]]],
       caml_string_of_jsbytes("void f_init()@.{@.")],
     _wx_=[0,[12,125,[17,4,0]],caml_string_of_jsbytes("}@.")],
     _wy_=
      [0,
       [11,caml_string_of_jsbytes("void f_clear()"),[17,4,[12,123,[17,4,0]]]],
       caml_string_of_jsbytes("void f_clear()@.{@.")],
     _wB_=[0,[12,125,[17,4,0]],caml_string_of_jsbytes("}@.")],
     _vV_=[0,caml_string_of_jsbytes("f")],
     _vW_=caml_string_of_jsbytes("translate_single: unsupported operation"),
     _vX_=
      [0,
       [11,
        caml_string_of_jsbytes("  float "),
        [2,0,[11,caml_string_of_jsbytes(" = -"),[2,0,[12,59,[17,4,0]]]]]],
       caml_string_of_jsbytes("  float %s = -%s;@.")],
     _vY_=
      [0,
       [11,
        caml_string_of_jsbytes("  float "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(" = fabsf("),
          [2,0,[11,caml_string_of_jsbytes(");"),[17,4,0]]]]]],
       caml_string_of_jsbytes("  float %s = fabsf(%s);@.")],
     _vZ_=
      [0,
       [11,
        caml_string_of_jsbytes("  float "),
        [2,0,[11,caml_string_of_jsbytes(" = 1.0f / "),[2,0,[12,59,[17,4,0]]]]]],
       caml_string_of_jsbytes("  float %s = 1.0f / %s;@.")],
     _v0_=
      [0,
       [11,
        caml_string_of_jsbytes("  float "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(" = sqrtf("),
          [2,0,[11,caml_string_of_jsbytes(");"),[17,4,0]]]]]],
       caml_string_of_jsbytes("  float %s = sqrtf(%s);@.")],
     _v1_=
      [0,
       [11,
        caml_string_of_jsbytes("  float "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(" = sinf("),
          [2,0,[11,caml_string_of_jsbytes(");"),[17,4,0]]]]]],
       caml_string_of_jsbytes("  float %s = sinf(%s);@.")],
     _v2_=
      [0,
       [11,
        caml_string_of_jsbytes("  float "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(" = cosf("),
          [2,0,[11,caml_string_of_jsbytes(");"),[17,4,0]]]]]],
       caml_string_of_jsbytes("  float %s = cosf(%s);@.")],
     _v4_=
      [0,
       [11,
        caml_string_of_jsbytes("  float "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(" = expf("),
          [2,0,[11,caml_string_of_jsbytes(");"),[17,4,0]]]]]],
       caml_string_of_jsbytes("  float %s = expf(%s);@.")],
     _v5_=
      [0,
       [11,
        caml_string_of_jsbytes("  float "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(" = logf("),
          [2,0,[11,caml_string_of_jsbytes(");"),[17,4,0]]]]]],
       caml_string_of_jsbytes("  float %s = logf(%s);@.")],
     _v3_=
      caml_string_of_jsbytes
       ("translate_single: unsupported unary operation: "),
     _v6_=
      [0,
       [11,
        caml_string_of_jsbytes("  float "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(" = fmaxf("),
          [2,
           0,
           [11,
            caml_string_of_jsbytes(", "),
            [2,0,[11,caml_string_of_jsbytes(");"),[17,4,0]]]]]]]],
       caml_string_of_jsbytes("  float %s = fmaxf(%s, %s);@.")],
     _v7_=
      [0,
       [11,
        caml_string_of_jsbytes("  float "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(" = fminf("),
          [2,
           0,
           [11,
            caml_string_of_jsbytes(", "),
            [2,0,[11,caml_string_of_jsbytes(");"),[17,4,0]]]]]]]],
       caml_string_of_jsbytes("  float %s = fminf(%s, %s);@.")],
     _v8_=
      [0,
       [11,
        caml_string_of_jsbytes("  float "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(" = "),
          [2,0,[11,caml_string_of_jsbytes(" + "),[2,0,[12,59,[17,4,0]]]]]]]],
       caml_string_of_jsbytes("  float %s = %s + %s;@.")],
     _v9_=
      [0,
       [11,
        caml_string_of_jsbytes("  float "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(" = "),
          [2,0,[11,caml_string_of_jsbytes(" - "),[2,0,[12,59,[17,4,0]]]]]]]],
       caml_string_of_jsbytes("  float %s = %s - %s;@.")],
     _v__=
      [0,
       [11,
        caml_string_of_jsbytes("  float "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(" = "),
          [2,0,[11,caml_string_of_jsbytes(" * "),[2,0,[12,59,[17,4,0]]]]]]]],
       caml_string_of_jsbytes("  float %s = %s * %s;@.")],
     _v$_=
      [0,
       [11,
        caml_string_of_jsbytes("  float "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(" = "),
          [2,0,[11,caml_string_of_jsbytes(" / "),[2,0,[12,59,[17,4,0]]]]]]]],
       caml_string_of_jsbytes("  float %s = %s / %s;@.")],
     _wa_=
      caml_string_of_jsbytes
       ("translate_single: unsupported binary operation: "),
     _vD_=[0,caml_string_of_jsbytes("d")],
     _vE_=caml_string_of_jsbytes("translate_double: unsupported operation"),
     _vF_=
      [0,
       [11,
        caml_string_of_jsbytes("  double "),
        [2,0,[11,caml_string_of_jsbytes(" = -"),[2,0,[12,59,[17,4,0]]]]]],
       caml_string_of_jsbytes("  double %s = -%s;@.")],
     _vG_=
      [0,
       [11,
        caml_string_of_jsbytes("  double "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(" = fabs("),
          [2,0,[11,caml_string_of_jsbytes(");"),[17,4,0]]]]]],
       caml_string_of_jsbytes("  double %s = fabs(%s);@.")],
     _vH_=
      [0,
       [11,
        caml_string_of_jsbytes("  double "),
        [2,0,[11,caml_string_of_jsbytes(" = 1.0 / "),[2,0,[12,59,[17,4,0]]]]]],
       caml_string_of_jsbytes("  double %s = 1.0 / %s;@.")],
     _vI_=
      [0,
       [11,
        caml_string_of_jsbytes("  double "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(" = sqrt("),
          [2,0,[11,caml_string_of_jsbytes(");"),[17,4,0]]]]]],
       caml_string_of_jsbytes("  double %s = sqrt(%s);@.")],
     _vJ_=
      [0,
       [11,
        caml_string_of_jsbytes("  double "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(" = sin("),
          [2,0,[11,caml_string_of_jsbytes(");"),[17,4,0]]]]]],
       caml_string_of_jsbytes("  double %s = sin(%s);@.")],
     _vK_=
      [0,
       [11,
        caml_string_of_jsbytes("  double "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(" = cos("),
          [2,0,[11,caml_string_of_jsbytes(");"),[17,4,0]]]]]],
       caml_string_of_jsbytes("  double %s = cos(%s);@.")],
     _vM_=
      [0,
       [11,
        caml_string_of_jsbytes("  double "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(" = exp("),
          [2,0,[11,caml_string_of_jsbytes(");"),[17,4,0]]]]]],
       caml_string_of_jsbytes("  double %s = exp(%s);@.")],
     _vN_=
      [0,
       [11,
        caml_string_of_jsbytes("  double "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(" = log("),
          [2,0,[11,caml_string_of_jsbytes(");"),[17,4,0]]]]]],
       caml_string_of_jsbytes("  double %s = log(%s);@.")],
     _vL_=
      caml_string_of_jsbytes
       ("translate_double: unsupported unary operation: "),
     _vO_=
      [0,
       [11,
        caml_string_of_jsbytes("  double "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(" = fmax("),
          [2,
           0,
           [11,
            caml_string_of_jsbytes(", "),
            [2,0,[11,caml_string_of_jsbytes(");"),[17,4,0]]]]]]]],
       caml_string_of_jsbytes("  double %s = fmax(%s, %s);@.")],
     _vP_=
      [0,
       [11,
        caml_string_of_jsbytes("  double "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(" = fmin("),
          [2,
           0,
           [11,
            caml_string_of_jsbytes(", "),
            [2,0,[11,caml_string_of_jsbytes(");"),[17,4,0]]]]]]]],
       caml_string_of_jsbytes("  double %s = fmin(%s, %s);@.")],
     _vQ_=
      [0,
       [11,
        caml_string_of_jsbytes("  double "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(" = "),
          [2,0,[11,caml_string_of_jsbytes(" + "),[2,0,[12,59,[17,4,0]]]]]]]],
       caml_string_of_jsbytes("  double %s = %s + %s;@.")],
     _vR_=
      [0,
       [11,
        caml_string_of_jsbytes("  double "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(" = "),
          [2,0,[11,caml_string_of_jsbytes(" - "),[2,0,[12,59,[17,4,0]]]]]]]],
       caml_string_of_jsbytes("  double %s = %s - %s;@.")],
     _vS_=
      [0,
       [11,
        caml_string_of_jsbytes("  double "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(" = "),
          [2,0,[11,caml_string_of_jsbytes(" * "),[2,0,[12,59,[17,4,0]]]]]]]],
       caml_string_of_jsbytes("  double %s = %s * %s;@.")],
     _vT_=
      [0,
       [11,
        caml_string_of_jsbytes("  double "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(" = "),
          [2,0,[11,caml_string_of_jsbytes(" / "),[2,0,[12,59,[17,4,0]]]]]]]],
       caml_string_of_jsbytes("  double %s = %s / %s;@.")],
     _vU_=
      caml_string_of_jsbytes
       ("translate_double: unsupported binary operation: "),
     _vj_=[0,caml_string_of_jsbytes("")],
     _vk_=
      [0,
       [11,
        caml_string_of_jsbytes("  mpfi_interv_d("),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(", "),
          [8,
           3,
           0,
           [0,20],
           [11,
            caml_string_of_jsbytes(", "),
            [8,3,0,[0,20],[11,caml_string_of_jsbytes(");"),[17,4,0]]]]]]]],
       caml_string_of_jsbytes("  mpfi_interv_d(%s, %.20e, %.20e);@.")],
     _vm_=
      [0,
       [11,
        caml_string_of_jsbytes("  mpfi_neg("),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(", "),
          [2,0,[11,caml_string_of_jsbytes(");"),[17,4,0]]]]]],
       caml_string_of_jsbytes("  mpfi_neg(%s, %s);@.")],
     _vn_=
      [0,
       [11,
        caml_string_of_jsbytes("  mpfi_abs("),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(", "),
          [2,0,[11,caml_string_of_jsbytes(");"),[17,4,0]]]]]],
       caml_string_of_jsbytes("  mpfi_abs(%s, %s);@.")],
     _vo_=
      [0,
       [11,
        caml_string_of_jsbytes("  mpfi_inv("),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(", "),
          [2,0,[11,caml_string_of_jsbytes(");"),[17,4,0]]]]]],
       caml_string_of_jsbytes("  mpfi_inv(%s, %s);@.")],
     _vp_=
      [0,
       [11,
        caml_string_of_jsbytes("  mpfi_sqrt("),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(", "),
          [2,0,[11,caml_string_of_jsbytes(");"),[17,4,0]]]]]],
       caml_string_of_jsbytes("  mpfi_sqrt(%s, %s);@.")],
     _vq_=
      [0,
       [11,
        caml_string_of_jsbytes("  mpfi_sin("),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(", "),
          [2,0,[11,caml_string_of_jsbytes(");"),[17,4,0]]]]]],
       caml_string_of_jsbytes("  mpfi_sin(%s, %s);@.")],
     _vr_=
      [0,
       [11,
        caml_string_of_jsbytes("  mpfi_cos("),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(", "),
          [2,0,[11,caml_string_of_jsbytes(");"),[17,4,0]]]]]],
       caml_string_of_jsbytes("  mpfi_cos(%s, %s);@.")],
     _vt_=
      [0,
       [11,
        caml_string_of_jsbytes("  mpfi_exp("),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(", "),
          [2,0,[11,caml_string_of_jsbytes(");"),[17,4,0]]]]]],
       caml_string_of_jsbytes("  mpfi_exp(%s, %s);@.")],
     _vu_=
      [0,
       [11,
        caml_string_of_jsbytes("  mpfi_log("),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(", "),
          [2,0,[11,caml_string_of_jsbytes(");"),[17,4,0]]]]]],
       caml_string_of_jsbytes("  mpfi_log(%s, %s);@.")],
     _vv_=
      [0,
       [11,
        caml_string_of_jsbytes("  mpfi_floor_power2("),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(", "),
          [2,0,[11,caml_string_of_jsbytes(");"),[17,4,0]]]]]],
       caml_string_of_jsbytes("  mpfi_floor_power2(%s, %s);@.")],
     _vs_=
      caml_string_of_jsbytes("translate_mpfi: unsupported unary operation: "),
     _vx_=
      [0,
       [11,
        caml_string_of_jsbytes("  mpfi_add("),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(", "),
          [2,
           0,
           [11,
            caml_string_of_jsbytes(", "),
            [2,0,[11,caml_string_of_jsbytes(");"),[17,4,0]]]]]]]],
       caml_string_of_jsbytes("  mpfi_add(%s, %s, %s);@.")],
     _vy_=
      [0,
       [11,
        caml_string_of_jsbytes("  mpfi_sub("),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(", "),
          [2,
           0,
           [11,
            caml_string_of_jsbytes(", "),
            [2,0,[11,caml_string_of_jsbytes(");"),[17,4,0]]]]]]]],
       caml_string_of_jsbytes("  mpfi_sub(%s, %s, %s);@.")],
     _vz_=
      [0,
       [11,
        caml_string_of_jsbytes("  mpfi_mul("),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(", "),
          [2,
           0,
           [11,
            caml_string_of_jsbytes(", "),
            [2,0,[11,caml_string_of_jsbytes(");"),[17,4,0]]]]]]]],
       caml_string_of_jsbytes("  mpfi_mul(%s, %s, %s);@.")],
     _vA_=
      [0,
       [11,
        caml_string_of_jsbytes("  mpfi_div("),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(", "),
          [2,
           0,
           [11,
            caml_string_of_jsbytes(", "),
            [2,0,[11,caml_string_of_jsbytes(");"),[17,4,0]]]]]]]],
       caml_string_of_jsbytes("  mpfi_div(%s, %s, %s);@.")],
     _vB_=
      [0,
       [11,
        caml_string_of_jsbytes("  mpfi_sub2("),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(", "),
          [2,
           0,
           [11,
            caml_string_of_jsbytes(", "),
            [2,0,[11,caml_string_of_jsbytes(");"),[17,4,0]]]]]]]],
       caml_string_of_jsbytes("  mpfi_sub2(%s, %s, %s);@.")],
     _vw_=
      caml_string_of_jsbytes("translate_mpfi: unsupported binary operation: "),
     _vC_=
      [0,
       [11,
        caml_string_of_jsbytes("  mpfi_goldberg_ulp("),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(", "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", "),
            [4,
             0,
             0,
             0,
             [11,
              caml_string_of_jsbytes(", "),
              [2,0,[11,caml_string_of_jsbytes(");"),[17,4,0]]]]]]]]]],
       caml_string_of_jsbytes("  mpfi_goldberg_ulp(%s, %d, %d, %s);@.")],
     _vl_=caml_string_of_jsbytes("translate_mpfi: unsupported operation"),
     _u3_=[0,caml_string_of_jsbytes("")],
     _u4_=caml_string_of_jsbytes("translate_mpfr: unsupported operation"),
     _u5_=
      [0,
       [11,
        caml_string_of_jsbytes("  mpfr_neg("),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(", "),
          [2,0,[11,caml_string_of_jsbytes(", MPFR_RNDN);"),[17,4,0]]]]]],
       caml_string_of_jsbytes("  mpfr_neg(%s, %s, MPFR_RNDN);@.")],
     _u6_=
      [0,
       [11,
        caml_string_of_jsbytes("  mpfr_abs("),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(", "),
          [2,0,[11,caml_string_of_jsbytes(", MPFR_RNDN);"),[17,4,0]]]]]],
       caml_string_of_jsbytes("  mpfr_abs(%s, %s, MPFR_RNDN);@.")],
     _u7_=
      [0,
       [11,
        caml_string_of_jsbytes("  mpfr_d_div("),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(", 1.0, "),
          [2,0,[11,caml_string_of_jsbytes(", MPFR_RNDN);"),[17,4,0]]]]]],
       caml_string_of_jsbytes("  mpfr_d_div(%s, 1.0, %s, MPFR_RNDN);@.")],
     _u8_=
      [0,
       [11,
        caml_string_of_jsbytes("  mpfr_sqrt("),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(", "),
          [2,0,[11,caml_string_of_jsbytes(", MPFR_RNDN);"),[17,4,0]]]]]],
       caml_string_of_jsbytes("  mpfr_sqrt(%s, %s, MPFR_RNDN);@.")],
     _u9_=
      [0,
       [11,
        caml_string_of_jsbytes("  mpfr_sin("),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(", "),
          [2,0,[11,caml_string_of_jsbytes(", MPFR_RNDN);"),[17,4,0]]]]]],
       caml_string_of_jsbytes("  mpfr_sin(%s, %s, MPFR_RNDN);@.")],
     _u__=
      [0,
       [11,
        caml_string_of_jsbytes("  mpfr_cos("),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(", "),
          [2,0,[11,caml_string_of_jsbytes(", MPFR_RNDN);"),[17,4,0]]]]]],
       caml_string_of_jsbytes("  mpfr_cos(%s, %s, MPFR_RNDN);@.")],
     _va_=
      [0,
       [11,
        caml_string_of_jsbytes("  mpfr_exp("),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(", "),
          [2,0,[11,caml_string_of_jsbytes(", MPFR_RNDN);"),[17,4,0]]]]]],
       caml_string_of_jsbytes("  mpfr_exp(%s, %s, MPFR_RNDN);@.")],
     _vb_=
      [0,
       [11,
        caml_string_of_jsbytes("  mpfr_log("),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(", "),
          [2,0,[11,caml_string_of_jsbytes(", MPFR_RNDN);"),[17,4,0]]]]]],
       caml_string_of_jsbytes("  mpfr_log(%s, %s, MPFR_RNDN);@.")],
     _u$_=
      caml_string_of_jsbytes("translate_mpfr: unsupported unary operation: "),
     _vc_=
      [0,
       [11,
        caml_string_of_jsbytes("  mpfr_max("),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(", "),
          [2,
           0,
           [11,
            caml_string_of_jsbytes(", "),
            [2,0,[11,caml_string_of_jsbytes(", MPFR_RNDN);"),[17,4,0]]]]]]]],
       caml_string_of_jsbytes("  mpfr_max(%s, %s, %s, MPFR_RNDN);@.")],
     _vd_=
      [0,
       [11,
        caml_string_of_jsbytes("  mpfr_min("),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(", "),
          [2,
           0,
           [11,
            caml_string_of_jsbytes(", "),
            [2,0,[11,caml_string_of_jsbytes(", MPFR_RNDN);"),[17,4,0]]]]]]]],
       caml_string_of_jsbytes("  mpfr_min(%s, %s, %s, MPFR_RNDN);@.")],
     _ve_=
      [0,
       [11,
        caml_string_of_jsbytes("  mpfr_add("),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(", "),
          [2,
           0,
           [11,
            caml_string_of_jsbytes(", "),
            [2,0,[11,caml_string_of_jsbytes(", MPFR_RNDN);"),[17,4,0]]]]]]]],
       caml_string_of_jsbytes("  mpfr_add(%s, %s, %s, MPFR_RNDN);@.")],
     _vf_=
      [0,
       [11,
        caml_string_of_jsbytes("  mpfr_sub("),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(", "),
          [2,
           0,
           [11,
            caml_string_of_jsbytes(", "),
            [2,0,[11,caml_string_of_jsbytes(", MPFR_RNDN);"),[17,4,0]]]]]]]],
       caml_string_of_jsbytes("  mpfr_sub(%s, %s, %s, MPFR_RNDN);@.")],
     _vg_=
      [0,
       [11,
        caml_string_of_jsbytes("  mpfr_mul("),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(", "),
          [2,
           0,
           [11,
            caml_string_of_jsbytes(", "),
            [2,0,[11,caml_string_of_jsbytes(", MPFR_RNDN);"),[17,4,0]]]]]]]],
       caml_string_of_jsbytes("  mpfr_mul(%s, %s, %s, MPFR_RNDN);@.")],
     _vh_=
      [0,
       [11,
        caml_string_of_jsbytes("  mpfr_div("),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(", "),
          [2,
           0,
           [11,
            caml_string_of_jsbytes(", "),
            [2,0,[11,caml_string_of_jsbytes(", MPFR_RNDN);"),[17,4,0]]]]]]]],
       caml_string_of_jsbytes("  mpfr_div(%s, %s, %s, MPFR_RNDN);@.")],
     _vi_=
      caml_string_of_jsbytes("translate_mpfr: unsupported binary operation: "),
     _u2_=caml_string_of_jsbytes(""),
     _u0_=
      [0,
       [11,caml_string_of_jsbytes("c_"),[4,0,0,0,[2,0,0]]],
       caml_string_of_jsbytes("c_%d%s")],
     _u1_=
      [0,
       [11,caml_string_of_jsbytes("t_"),[4,0,0,0,[2,0,0]]],
       caml_string_of_jsbytes("t_%d%s")],
     _yA_=caml_string_of_jsbytes("fp-power2-model"),
     _yB_=caml_string_of_jsbytes("develop"),
     _yy_=caml_string_of_jsbytes("fp-power2-model"),
     _yz_=caml_string_of_jsbytes("develop"),
     _yC_=caml_string_of_jsbytes("build_form: unsupported unary operation "),
     _yD_=caml_string_of_jsbytes("build_form: unsupported binary operation "),
     _yE_=caml_string_of_jsbytes("build_form: unsupported general operation "),
     _yx_=
      [0,
       [11,caml_string_of_jsbytes("min_form"),0],
       caml_string_of_jsbytes("min_form")],
     _yw_=
      [0,
       [11,caml_string_of_jsbytes("max_form"),0],
       caml_string_of_jsbytes("max_form")],
     _yv_=
      [0,
       [11,caml_string_of_jsbytes("abs_form"),0],
       caml_string_of_jsbytes("abs_form")],
     _yu_=
      [0,
       [11,caml_string_of_jsbytes("atanh_form"),0],
       caml_string_of_jsbytes("atanh_form")],
     _yt_=
      [0,
       [11,caml_string_of_jsbytes("acosh_form"),0],
       caml_string_of_jsbytes("acosh_form")],
     _ys_=
      [0,
       [11,caml_string_of_jsbytes("asinh_form"),0],
       caml_string_of_jsbytes("asinh_form")],
     _yr_=
      [0,
       [11,caml_string_of_jsbytes("tanh_form"),0],
       caml_string_of_jsbytes("tanh_form")],
     _yq_=
      [0,
       [11,caml_string_of_jsbytes("cosh_form"),0],
       caml_string_of_jsbytes("cosh_form")],
     _yp_=
      [0,
       [11,caml_string_of_jsbytes("sinh_form"),0],
       caml_string_of_jsbytes("sinh_form")],
     _yo_=
      [0,
       [11,caml_string_of_jsbytes("log_form"),0],
       caml_string_of_jsbytes("log_form")],
     _yn_=
      [0,
       [11,caml_string_of_jsbytes("exp_form"),0],
       caml_string_of_jsbytes("exp_form")],
     _ym_=
      [0,
       [11,caml_string_of_jsbytes("atan_form"),0],
       caml_string_of_jsbytes("atan_form")],
     _yl_=
      [0,
       [11,caml_string_of_jsbytes("acos_form"),0],
       caml_string_of_jsbytes("acos_form")],
     _yk_=
      [0,
       [11,caml_string_of_jsbytes("asin_form"),0],
       caml_string_of_jsbytes("asin_form")],
     _yj_=
      [0,
       [11,caml_string_of_jsbytes("tan_form"),0],
       caml_string_of_jsbytes("tan_form")],
     _yi_=
      [0,
       [11,caml_string_of_jsbytes("cos_form"),0],
       caml_string_of_jsbytes("cos_form")],
     _yh_=
      [0,
       [11,caml_string_of_jsbytes("sin_form"),0],
       caml_string_of_jsbytes("sin_form")],
     _yg_=
      [0,
       [11,caml_string_of_jsbytes("sqrt_form"),0],
       caml_string_of_jsbytes("sqrt_form")],
     _yf_=
      [0,
       [11,caml_string_of_jsbytes("div_form"),0],
       caml_string_of_jsbytes("div_form")],
     _ye_=
      [0,
       [11,caml_string_of_jsbytes("inv_form"),0],
       caml_string_of_jsbytes("inv_form")],
     _yd_=
      [0,
       [11,caml_string_of_jsbytes("mul_form"),0],
       caml_string_of_jsbytes("mul_form")],
     _yc_=
      [0,
       [11,caml_string_of_jsbytes("rounded_add_form"),0],
       caml_string_of_jsbytes("rounded_add_form")],
     _yb_=
      [0,
       [11,caml_string_of_jsbytes("rounded_sub_form"),0],
       caml_string_of_jsbytes("rounded_sub_form")],
     _ya_=
      [0,
       [11,caml_string_of_jsbytes("sub_form"),0],
       caml_string_of_jsbytes("sub_form")],
     _x$_=
      [0,
       [11,caml_string_of_jsbytes("add_form"),0],
       caml_string_of_jsbytes("add_form")],
     _x__=
      [0,
       [11,caml_string_of_jsbytes("neg_form"),0],
       caml_string_of_jsbytes("neg_form")],
     _x8_=
      [0,
       [11,caml_string_of_jsbytes("rounded_form"),0],
       caml_string_of_jsbytes("rounded_form")],
     _x9_=caml_string_of_jsbytes("fp-power2-model"),
     _x3_=
      [0,
       [11,caml_string_of_jsbytes("var_rnd_form"),0],
       caml_string_of_jsbytes("var_rnd_form")],
     _x4_=caml_string_of_jsbytes("var_rnd_form: not a variable"),
     _x5_=caml_string_of_jsbytes("uncertainty"),
     _x6_=caml_string_of_jsbytes("const-approx-real-vars"),
     _x7_=caml_string_of_jsbytes("fp-power2-model"),
     _x0_=
      [0,
       [11,caml_string_of_jsbytes("var_form"),0],
       caml_string_of_jsbytes("var_form")],
     _x1_=caml_string_of_jsbytes("var_form: not a variable"),
     _x2_=caml_string_of_jsbytes("uncertainty"),
     _xY_=[0,0],
     _xZ_=caml_string_of_jsbytes("$uncertainty"),
     _xT_=
      [0,
       [11,caml_string_of_jsbytes("const_rnd_form"),0],
       caml_string_of_jsbytes("const_rnd_form")],
     _xU_=caml_string_of_jsbytes("fp-power2-model"),
     _xX_=caml_string_of_jsbytes("const_rnd_form: not a constant: "),
     _xW_=[0,caml_string_of_jsbytes("taylor_form.ml"),248,6],
     _xV_=
      [0,
       [11,
        caml_string_of_jsbytes("Inexact constant: "),
        [2,0,[11,caml_string_of_jsbytes("; err = "),[2,0,0]]]],
       caml_string_of_jsbytes("Inexact constant: %s; err = %s")],
     _xN_=
      [0,
       [11,caml_string_of_jsbytes("precise_const_rnd_form"),0],
       caml_string_of_jsbytes("precise_const_rnd_form")],
     _xS_=caml_string_of_jsbytes("precise_const_rnd_form: not a constant: "),
     _xR_=[0,caml_string_of_jsbytes("taylor_form.ml"),214,4],
     _xO_=[0,0],
     _xP_=[0,2],
     _xQ_=
      [0,
       [11,
        caml_string_of_jsbytes("Inexact constant: "),
        [2,0,[11,caml_string_of_jsbytes("; err = "),[2,0,0]]]],
       caml_string_of_jsbytes("Inexact constant: %s; err = %s")],
     _xJ_=
      [0,
       [11,caml_string_of_jsbytes("const_form"),0],
       caml_string_of_jsbytes("const_form")],
     _xM_=caml_string_of_jsbytes("const_form: not a constant"),
     _xK_=
      [0,
       [11,caml_string_of_jsbytes("const_form: interval constant"),0],
       caml_string_of_jsbytes("const_form: interval constant")],
     _xL_=[0,0],
     _xI_=caml_string_of_jsbytes("unique-indices"),
     _xH_=[0,caml_string_of_jsbytes("taylor_form.ml"),164,16],
     _xG_=[0,0.,0],
     _xF_=[0,0.,0],
     _xE_=[0,0.,0],
     _xB_=caml_string_of_jsbytes("intermediate-opt"),
     _xC_=
      [0,
       [11,caml_string_of_jsbytes("Estimating: "),[2,0,0]],
       caml_string_of_jsbytes("Estimating: %s")],
     _xD_=
      [0,
       [11,
        caml_string_of_jsbytes("Estimation result: ["),
        [8,0,0,0,[11,caml_string_of_jsbytes(", "),[8,0,0,0,[12,93,0]]]]],
       caml_string_of_jsbytes("Estimation result: [%f, %f]")],
     _zd_=[0,0,0],
     _A7_=caml_string_of_jsbytes("fpcore-out"),
     _A8_=caml_string_of_jsbytes("fpcore-out"),
     _A9_=caml_string_of_jsbytes("fpcore-out"),
     _A__=caml_string_of_jsbytes("export-options"),
     _A$_=caml_string_of_jsbytes("export-options"),
     _Ba_=caml_string_of_jsbytes(""),
     _Bb_=
      [0,
       [11,caml_string_of_jsbytes("Exporting options into: "),[2,0,0]],
       caml_string_of_jsbytes("Exporting options into: %s")],
     _Bc_=caml_string_of_jsbytes("config-out"),
     _Bd_=caml_string_of_jsbytes("config-out"),
     _Be_=caml_string_of_jsbytes("config-out"),
     _Bf_=[0,0,caml_string_of_jsbytes("")],
     _AQ_=
      [0,
       [11,caml_string_of_jsbytes("Loading: "),[2,0,0]],
       caml_string_of_jsbytes("Loading: %s")],
     _AR_=
      [0,
       [4,
        0,
        0,
        0,
        [12,
         45,
         [4,
          0,
          [0,2,2],
          0,
          [12,
           45,
           [4,
            0,
            [0,2,2],
            0,
            [12,45,[4,0,[0,2,2],0,[4,0,[0,2,2],0,[4,0,[0,2,2],0,0]]]]]]]]],
       caml_string_of_jsbytes("%d-%02d-%02d-%02d%02d%02d")],
     _AS_=caml_string_of_jsbytes("log-base-dir"),
     _AT_=caml_string_of_jsbytes("log-append-date"),
     _AU_=caml_string_of_jsbytes("end"),
     _AV_=caml_string_of_jsbytes("start"),
     _A5_=caml_string_of_jsbytes("_"),
     _A6_=caml_string_of_jsbytes("_"),
     _AW_=caml_string_of_jsbytes(".log"),
     _AX_=caml_string_of_jsbytes("tmp-base-dir"),
     _AY_=caml_string_of_jsbytes("tmp-date"),
     _AZ_=
      [0,
       [11,caml_string_of_jsbytes("|tasks| = "),[4,0,0,0,0]],
       caml_string_of_jsbytes("|tasks| = %d")],
     _A0_=caml_string_of_jsbytes("fpcore-out"),
     _A1_=
      [0,
       [11,caml_string_of_jsbytes("Exporting to the FPCore format"),0],
       caml_string_of_jsbytes("Exporting to the FPCore format")],
     _A2_=caml_string_of_jsbytes("fpcore-out"),
     _A4_=
      [0,
       [11,
        caml_string_of_jsbytes("*************************************\n"),
        0],
       caml_string_of_jsbytes("*************************************\n")],
     _A3_=[0,0,caml_string_of_jsbytes("")],
     _AA_=
      [0,
       [11,caml_string_of_jsbytes("Processing: "),[2,0,0]],
       caml_string_of_jsbytes("Processing: %s")],
     _AP_=
      [0,
       [11,
        caml_string_of_jsbytes("\n****** Approximating constraints *******\n"),
        0],
       caml_string_of_jsbytes("\n****** Approximating constraints *******\n")],
     _AB_=caml_string_of_jsbytes("export-error-bounds-data"),
     _AC_=caml_string_of_jsbytes(""),
     _AD_=caml_string_of_jsbytes("{task}"),
     _AE_=
      [0,
       [11,caml_string_of_jsbytes("Data (ErrorBounds) export: "),[2,0,0]],
       caml_string_of_jsbytes("Data (ErrorBounds) export: %s")],
     _AF_=caml_string_of_jsbytes("data"),
     _AG_=caml_string_of_jsbytes("export-error-bounds"),
     _AH_=caml_string_of_jsbytes(""),
     _AI_=caml_string_of_jsbytes("{task}"),
     _AJ_=
      [0,
       [11,caml_string_of_jsbytes("ErrorBounds export: "),[2,0,0]],
       caml_string_of_jsbytes("ErrorBounds export: %s")],
     _AK_=caml_string_of_jsbytes("error-bounds"),
     _AL_=caml_string_of_jsbytes("error-bounds"),
     _AM_=caml_string_of_jsbytes("error-bounds"),
     _AN_=caml_string_of_jsbytes("racket"),
     _AO_=caml_string_of_jsbytes("data"),
     _Az_=
      caml_string_of_jsbytes("approximate_constraint: Eq is not supported"),
     _Ax_=
      [0,
       [11,caml_string_of_jsbytes("Constraint form"),0],
       caml_string_of_jsbytes("Constraint form")],
     _Ay_=
      [0,
       [12,
        10,
        [2,0,[11,caml_string_of_jsbytes(" error: "),[8,3,0,0,[12,10,0]]]]],
       caml_string_of_jsbytes("\n%s error: %e\n")],
     _Aj_=
      [0,
       [11,
        caml_string_of_jsbytes("\n*************************************"),
        0],
       caml_string_of_jsbytes("\n*************************************")],
     _Ak_=
      [0,
       [11,caml_string_of_jsbytes("Taylor form for: "),[2,0,0]],
       caml_string_of_jsbytes("Taylor form for: %s")],
     _Ap_=[0,[8,0,0,0,0],caml_string_of_jsbytes("%f")],
     _Aq_=
      [0,
       [11,caml_string_of_jsbytes("\nConservative bound: "),[2,0,0]],
       caml_string_of_jsbytes("\nConservative bound: %s")],
     _Ar_=
      [0,
       [11,caml_string_of_jsbytes("\nSimplified rounding: "),[2,0,0]],
       caml_string_of_jsbytes("\nSimplified rounding: %s")],
     _As_=
      [0,
       [11,caml_string_of_jsbytes("Building Taylor forms..."),0],
       caml_string_of_jsbytes("Building Taylor forms...")],
     _At_=
      [0,
       [11,caml_string_of_jsbytes("Simplifying Taylor forms..."),0],
       caml_string_of_jsbytes("Simplifying Taylor forms...")],
     _Au_=
      [0,
       [11,caml_string_of_jsbytes("success"),0],
       caml_string_of_jsbytes("success")],
     _Av_=caml_string_of_jsbytes("maxima-simplification"),
     _Aw_=[0,0,caml_string_of_jsbytes("")],
     _Al_=
      [0,
       [11,caml_string_of_jsbytes("Elapsed time: "),[8,0,0,[0,5],0]],
       caml_string_of_jsbytes("Elapsed time: %.5f")],
     _Am_=caml_string_of_jsbytes("proof-dir"),
     _An_=
      [0,
       [11,
        caml_string_of_jsbytes("Saving a proof certificate for "),
        [2,0,[11,caml_string_of_jsbytes(" (in "),[2,0,[12,41,0]]]]],
       caml_string_of_jsbytes("Saving a proof certificate for %s (in %s)")],
     _Ao_=caml_string_of_jsbytes(".proof"),
     _Ai_=
      [0,
       [11,
        caml_string_of_jsbytes("\nPotential exception detected: "),
        [2,0,[11,caml_string_of_jsbytes(" at:\n"),[2,0,0]]]],
       caml_string_of_jsbytes("\nPotential exception detected: %s at:\n%s")],
     _z__=caml_string_of_jsbytes("rel-error"),
     _Ag_=caml_string_of_jsbytes("ulp-error"),
     _Ah_=caml_string_of_jsbytes("find-bounds"),
     _z$_=
      [0,
       [11,
        caml_string_of_jsbytes("bounds: ["),
        [8,3,0,0,[11,caml_string_of_jsbytes(", "),[8,3,0,0,[12,93,0]]]]],
       caml_string_of_jsbytes("bounds: [%e, %e]")],
     _Aa_=caml_string_of_jsbytes("opt-approx"),
     _Af_=caml_string_of_jsbytes("opt-exact"),
     _Ab_=caml_string_of_jsbytes("abs-error"),
     _Ac_=caml_string_of_jsbytes("rel-error"),
     _Ad_=caml_string_of_jsbytes("ulp-error"),
     _Ae_=[0,0,caml_string_of_jsbytes("")],
     _zR_=
      [0,
       [11,caml_string_of_jsbytes("\nComputing ULP errors"),0],
       caml_string_of_jsbytes("\nComputing ULP errors")],
     _zS_=
      [0,
       [11,caml_string_of_jsbytes("Bad precision: "),[4,0,0,0,0]],
       caml_string_of_jsbytes("Bad precision: %d")],
     _zT_=
      [0,
       [11,
        caml_string_of_jsbytes("\nprec = "),
        [4,0,0,0,[11,caml_string_of_jsbytes(", e_min = "),[4,0,0,0,0]]]],
       caml_string_of_jsbytes("\nprec = %d, e_min = %d")],
     _zU_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("\nCannot compute the ULP error: values of the function are close to zero"),
        0],
       caml_string_of_jsbytes
        ("\nCannot compute the ULP error: values of the function are close to zero")],
     _zV_=[0,0,0],
     _zW_=caml_string_of_jsbytes("opt-approx"),
     _zX_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("\nSolving the approximate optimization probelm"),
        0],
       caml_string_of_jsbytes
        ("\nSolving the approximate optimization probelm")],
     _zY_=
      [0,
       [11,caml_string_of_jsbytes("\nULP errors:"),0],
       caml_string_of_jsbytes("\nULP errors:")],
     _zZ_=
      [0,
       [11,caml_string_of_jsbytes("ulp-total1: "),[2,0,0]],
       caml_string_of_jsbytes("ulp-total1: %s")],
     _z0_=
      [0,
       [11,caml_string_of_jsbytes("ulp-total2: "),[2,0,0]],
       caml_string_of_jsbytes("ulp-total2: %s")],
     _z1_=
      [0,
       [11,caml_string_of_jsbytes("ulp-total: "),[2,0,0]],
       caml_string_of_jsbytes("ulp-total: %s")],
     _z2_=caml_string_of_jsbytes("opt-exact"),
     _z3_=
      [0,
       [11,
        caml_string_of_jsbytes("\nSolving the exact optimization problem"),
        0],
       caml_string_of_jsbytes("\nSolving the exact optimization problem")],
     _z7_=caml_string_of_jsbytes("-opt-bound"),
     _z8_=caml_string_of_jsbytes("-total2"),
     _z9_=caml_string_of_jsbytes("data"),
     _z4_=
      [0,
       [11,
        caml_string_of_jsbytes("exact bound-ulp (exp = "),
        [4,0,0,0,[11,caml_string_of_jsbytes("): "),[2,0,0]]]],
       caml_string_of_jsbytes("exact bound-ulp (exp = %d): %s")],
     _z5_=
      [0,
       [11,caml_string_of_jsbytes("total2: "),[2,0,0]],
       caml_string_of_jsbytes("total2: %s")],
     _z6_=
      [0,
       [11,caml_string_of_jsbytes("exact total-ulp: "),[2,0,0]],
       caml_string_of_jsbytes("exact total-ulp: %s")],
     _zx_=
      [0,
       [11,caml_string_of_jsbytes("\nComputing relative errors"),0],
       caml_string_of_jsbytes("\nComputing relative errors")],
     _zy_=caml_string_of_jsbytes("rel-error-threshold"),
     _zz_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("\nCannot compute the relative error: values of the function are close to zero"),
        0],
       caml_string_of_jsbytes
        ("\nCannot compute the relative error: values of the function are close to zero")],
     _zA_=[0,0,0],
     _zB_=caml_string_of_jsbytes("opt-approx"),
     _zC_=caml_string_of_jsbytes("maxima-simplification"),
     _zD_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("\nSolving the approximate optimization probelm"),
        0],
       caml_string_of_jsbytes
        ("\nSolving the approximate optimization probelm")],
     _zE_=
      [0,
       [11,caml_string_of_jsbytes("\nRelative errors:"),0],
       caml_string_of_jsbytes("\nRelative errors:")],
     _zF_=
      [0,
       [11,caml_string_of_jsbytes("rel-total1: "),[2,0,0]],
       caml_string_of_jsbytes("rel-total1: %s")],
     _zG_=
      [0,
       [11,caml_string_of_jsbytes("rel-total2: "),[2,0,0]],
       caml_string_of_jsbytes("rel-total2: %s")],
     _zH_=
      [0,
       [11,caml_string_of_jsbytes("rel-total: "),[2,0,0]],
       caml_string_of_jsbytes("rel-total: %s")],
     _zI_=caml_string_of_jsbytes("opt-exact"),
     _zJ_=
      [0,
       [11,
        caml_string_of_jsbytes("\nSolving the exact optimization problem"),
        0],
       caml_string_of_jsbytes("\nSolving the exact optimization problem")],
     _zK_=caml_string_of_jsbytes("maxima-simplification"),
     _zO_=caml_string_of_jsbytes("-opt-bound"),
     _zP_=caml_string_of_jsbytes("-total2"),
     _zQ_=caml_string_of_jsbytes("data"),
     _zL_=
      [0,
       [11,
        caml_string_of_jsbytes("exact bound-rel (exp = "),
        [4,0,0,0,[11,caml_string_of_jsbytes("): "),[2,0,0]]]],
       caml_string_of_jsbytes("exact bound-rel (exp = %d): %s")],
     _zM_=
      [0,
       [11,caml_string_of_jsbytes("total2: "),[2,0,0]],
       caml_string_of_jsbytes("total2: %s")],
     _zN_=
      [0,
       [11,caml_string_of_jsbytes("exact total-rel: "),[2,0,0]],
       caml_string_of_jsbytes("exact total-rel: %s")],
     _zh_=
      [0,
       [11,caml_string_of_jsbytes("\nComputing absolute errors"),0],
       caml_string_of_jsbytes("\nComputing absolute errors")],
     _zi_=caml_string_of_jsbytes("opt-approx"),
     _zj_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("\nSolving the approximate optimization problem"),
        0],
       caml_string_of_jsbytes
        ("\nSolving the approximate optimization problem")],
     _zk_=
      [0,
       [11,caml_string_of_jsbytes("\nAbsolute errors:"),0],
       caml_string_of_jsbytes("\nAbsolute errors:")],
     _zl_=
      [0,
       [11,caml_string_of_jsbytes("total1: "),[2,0,0]],
       caml_string_of_jsbytes("total1: %s")],
     _zm_=
      [0,
       [11,caml_string_of_jsbytes("total2: "),[2,0,0]],
       caml_string_of_jsbytes("total2: %s")],
     _zn_=
      [0,
       [11,caml_string_of_jsbytes("total: "),[2,0,0]],
       caml_string_of_jsbytes("total: %s")],
     _zo_=caml_string_of_jsbytes("opt-exact"),
     _zp_=
      [0,
       [11,
        caml_string_of_jsbytes("\nSolving the exact optimization problem"),
        0],
       caml_string_of_jsbytes("\nSolving the exact optimization problem")],
     _zq_=caml_string_of_jsbytes("maxima-simplification"),
     _zu_=caml_string_of_jsbytes("-opt-bound"),
     _zv_=caml_string_of_jsbytes("-total2"),
     _zw_=caml_string_of_jsbytes("data"),
     _zr_=
      [0,
       [11,
        caml_string_of_jsbytes("exact bound (exp = "),
        [4,0,0,0,[11,caml_string_of_jsbytes("): "),[2,0,0]]]],
       caml_string_of_jsbytes("exact bound (exp = %d): %s")],
     _zs_=
      [0,
       [11,caml_string_of_jsbytes("total2: "),[2,0,0]],
       caml_string_of_jsbytes("total2: %s")],
     _zt_=
      [0,
       [11,caml_string_of_jsbytes("exact total: "),[2,0,0]],
       caml_string_of_jsbytes("exact total: %s")],
     _zf_=
      [0,
       [11,
        caml_string_of_jsbytes("Large second-order error: "),
        [8,
         3,
         0,
         0,
         [11,caml_string_of_jsbytes(" (first-order = "),[8,3,0,0,[12,41,0]]]]],
       caml_string_of_jsbytes
        ("Large second-order error: %e (first-order = %e)")],
     _zg_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("Try intermediate-opt = true or manually split intervals of input variables."),
        0],
       caml_string_of_jsbytes
        ("Try intermediate-opt = true or manually split intervals of input variables.")],
     _ze_=[0,caml_string_of_jsbytes("fptaylor.ml"),230,2],
     _zc_=
      [0,
       [4,
        0,
        0,
        0,
        [11,
         caml_string_of_jsbytes(": exp = "),
         [4,0,0,0,[11,caml_string_of_jsbytes(": "),[2,0,0]]]]],
       caml_string_of_jsbytes("%d: exp = %d: %s")],
     _za_=
      [0,
       [8,
        3,
        0,
        0,
        [11,
         caml_string_of_jsbytes(" (low = "),
         [8,
          3,
          0,
          0,
          [11,
           caml_string_of_jsbytes(", subopt = "),
           [8,0,0,[0,1],[12,37,[12,41,0]]]]]]],
       caml_string_of_jsbytes("%e (low = %e, subopt = %.1f%%)")],
     _zb_=
      [0,
       [8,3,0,0,[11,caml_string_of_jsbytes(" (low = "),[8,3,0,0,[12,41,0]]]],
       caml_string_of_jsbytes("%e (low = %e)")],
     _y$_=
      [0,
       [4,0,0,0,[11,caml_string_of_jsbytes(": "),[2,0,0]]],
       caml_string_of_jsbytes("%d: %s")],
     _y9_=
      [0,
       [4,
        0,
        0,
        0,
        [11,
         caml_string_of_jsbytes(" ("),
         [4,
          0,
          0,
          0,
          [11,
           caml_string_of_jsbytes("): exp = "),
           [4,0,0,0,[11,caml_string_of_jsbytes(": "),[2,0,0]]]]]]],
       caml_string_of_jsbytes("%d (%d): exp = %d: %s")],
     _y8_=
      [0,
       [11,caml_string_of_jsbytes("v0 = "),[2,0,0]],
       caml_string_of_jsbytes("v0 = %s")],
     _y__=
      [0,
       [11,
        caml_string_of_jsbytes("\nCorresponding original subexpressions:"),
        0],
       caml_string_of_jsbytes("\nCorresponding original subexpressions:")],
     _yZ_=[0,caml_string_of_jsbytes("fptaylor.ml"),111,8],
     _yY_=
      [0,
       [11,caml_string_of_jsbytes("Bounds (floating-point): "),[2,0,0]],
       caml_string_of_jsbytes("Bounds (floating-point): %s")],
     _yX_=
      [0,
       [12,91,[2,0,[11,caml_string_of_jsbytes(", "),[2,0,[12,93,0]]]]],
       caml_string_of_jsbytes("[%s, %s]")],
     _yT_=
      [0,
       [2,
        [1,0],
        [12,
         32,
         [2,
          0,
          [11,
           caml_string_of_jsbytes(" ("),
           [8,
            16,
            0,
            0,
            [11,
             caml_string_of_jsbytes(") (suboptimality = "),
             [8,0,0,[0,1],[12,37,[12,41,0]]]]]]]]],
       caml_string_of_jsbytes("%-*s %s (%h) (suboptimality = %.1f%%)")],
     _yU_=
      [0,
       [2,
        [1,0],
        [12,
         32,
         [2,
          0,
          [11,
           caml_string_of_jsbytes(" (suboptimality = "),
           [8,0,0,[0,1],[12,37,[12,41,0]]]]]]],
       caml_string_of_jsbytes("%-*s %s (suboptimality = %.1f%%)")],
     _yV_=
      [0,
       [2,
        [1,0],
        [12,32,[2,0,[11,caml_string_of_jsbytes(" ("),[8,16,0,0,[12,41,0]]]]]],
       caml_string_of_jsbytes("%-*s %s (%h)")],
     _yW_=[0,[2,[1,0],[12,32,[2,0,0]]],caml_string_of_jsbytes("%-*s %s")],
     _yR_=
      [0,
       [2,
        [1,0],
        [12,32,[2,0,[11,caml_string_of_jsbytes(" ("),[8,16,0,0,[12,41,0]]]]]],
       caml_string_of_jsbytes("%-*s %s (%h)")],
     _yS_=[0,[2,[1,0],[12,32,[2,0,0]]],caml_string_of_jsbytes("%-*s %s")],
     _yP_=caml_string_of_jsbytes("print-hex-floats"),
     _yQ_=caml_string_of_jsbytes("print-precision"),
     _y0_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("-------------------------------------------------------------------------------"),
        0],
       caml_string_of_jsbytes
        ("-------------------------------------------------------------------------------")],
     _y1_=
      [0,
       [11,caml_string_of_jsbytes("Problem: "),[2,0,[12,10,0]]],
       caml_string_of_jsbytes("Problem: %s\n")],
     _y2_=caml_string_of_jsbytes("print-opt-lower-bounds"),
     _y3_=
      [0,
       [11,
        caml_string_of_jsbytes("Optimization lower bounds for error models:"),
        0],
       caml_string_of_jsbytes("Optimization lower bounds for error models:")],
     _y4_=[0,0,caml_string_of_jsbytes("")],
     _y5_=
      [0,
       [11,caml_string_of_jsbytes("Bounds (without rounding): "),[2,0,0]],
       caml_string_of_jsbytes("Bounds (without rounding): %s")],
     _y6_=[0,0,caml_string_of_jsbytes("")],
     _y7_=
      [0,
       [11,caml_string_of_jsbytes("\nElapsed time: "),[8,0,0,[0,2],[12,10,0]]],
       caml_string_of_jsbytes("\nElapsed time: %.2f\n")],
     _yO_=caml_string_of_jsbytes("File with the same id is already open: "),
     _yN_=caml_string_of_jsbytes("NONE"),
     _Bw_=caml_string_of_jsbytes("input.txt"),
     _Bx_=caml_string_of_jsbytes("user.cfg"),
     _By_=caml_string_of_jsbytes("print-precision"),
     _Bq_=
      [0,
       [11,caml_string_of_jsbytes("FPTaylor, version "),[2,0,0]],
       caml_string_of_jsbytes("FPTaylor, version %s")],
     _Br_=[0,caml_string_of_jsbytes("input.txt"),0],
     _Bo_=caml_string_of_jsbytes("Parsing error"),
     _Bp_=caml_string_of_jsbytes("Unknown error"),
     _Bi_=caml_string_of_jsbytes("./default.cfg"),
     _Bj_=caml_string_of_jsbytes("verbosity = 1"),
     _Bk_=caml_string_of_jsbytes("user.cfg"),
     _Bl_=caml_string_of_jsbytes(""),
     _Bm_=caml_string_of_jsbytes("input.txt");
    function erase_rel(param)
     {if(typeof param === "number")
       return 0;
      else
       switch(param[0])
        {case 0:var rest=param[1];return [0,erase_rel(rest)];
         case 1:var rest$0=param[1];return [1,erase_rel(rest$0)];
         case 2:var rest$1=param[1];return [2,erase_rel(rest$1)];
         case 3:var rest$2=param[1];return [3,erase_rel(rest$2)];
         case 4:var rest$3=param[1];return [4,erase_rel(rest$3)];
         case 5:var rest$4=param[1];return [5,erase_rel(rest$4)];
         case 6:var rest$5=param[1];return [6,erase_rel(rest$5)];
         case 7:var rest$6=param[1];return [7,erase_rel(rest$6)];
         case 8:
          var rest$7=param[2],ty=param[1];return [8,ty,erase_rel(rest$7)];
         case 9:
          var rest$8=param[3],ty1=param[1];
          return [9,ty1,ty1,erase_rel(rest$8)];
         case 10:var rest$9=param[1];return [10,erase_rel(rest$9)];
         case 11:var rest$10=param[1];return [11,erase_rel(rest$10)];
         case 12:var rest$11=param[1];return [12,erase_rel(rest$11)];
         case 13:var rest$12=param[1];return [13,erase_rel(rest$12)];
         default:var rest$13=param[1];return [14,erase_rel(rest$13)]}}
    function concat_fmtty(fmtty1,fmtty2)
     {if(typeof fmtty1 === "number")
       return fmtty2;
      else
       switch(fmtty1[0])
        {case 0:var rest=fmtty1[1];return [0,concat_fmtty(rest,fmtty2)];
         case 1:var rest$0=fmtty1[1];return [1,concat_fmtty(rest$0,fmtty2)];
         case 2:var rest$1=fmtty1[1];return [2,concat_fmtty(rest$1,fmtty2)];
         case 3:var rest$2=fmtty1[1];return [3,concat_fmtty(rest$2,fmtty2)];
         case 4:var rest$3=fmtty1[1];return [4,concat_fmtty(rest$3,fmtty2)];
         case 5:var rest$4=fmtty1[1];return [5,concat_fmtty(rest$4,fmtty2)];
         case 6:var rest$5=fmtty1[1];return [6,concat_fmtty(rest$5,fmtty2)];
         case 7:var rest$6=fmtty1[1];return [7,concat_fmtty(rest$6,fmtty2)];
         case 8:
          var rest$7=fmtty1[2],ty=fmtty1[1];
          return [8,ty,concat_fmtty(rest$7,fmtty2)];
         case 9:
          var rest$8=fmtty1[3],ty2=fmtty1[2],ty1=fmtty1[1];
          return [9,ty1,ty2,concat_fmtty(rest$8,fmtty2)];
         case 10:var rest$9=fmtty1[1];return [10,concat_fmtty(rest$9,fmtty2)];
         case 11:
          var rest$10=fmtty1[1];return [11,concat_fmtty(rest$10,fmtty2)];
         case 12:
          var rest$11=fmtty1[1];return [12,concat_fmtty(rest$11,fmtty2)];
         case 13:
          var rest$12=fmtty1[1];return [13,concat_fmtty(rest$12,fmtty2)];
         default:
          var rest$13=fmtty1[1];return [14,concat_fmtty(rest$13,fmtty2)]}}
    function concat_fmt(fmt1,fmt2)
     {if(typeof fmt1 === "number")
       return fmt2;
      else
       switch(fmt1[0])
        {case 0:var rest=fmt1[1];return [0,concat_fmt(rest,fmt2)];
         case 1:var rest$0=fmt1[1];return [1,concat_fmt(rest$0,fmt2)];
         case 2:
          var rest$1=fmt1[2],pad=fmt1[1];
          return [2,pad,concat_fmt(rest$1,fmt2)];
         case 3:
          var rest$2=fmt1[2],pad$0=fmt1[1];
          return [3,pad$0,concat_fmt(rest$2,fmt2)];
         case 4:
          var rest$3=fmt1[4],prec=fmt1[3],pad$1=fmt1[2],iconv=fmt1[1];
          return [4,iconv,pad$1,prec,concat_fmt(rest$3,fmt2)];
         case 5:
          var rest$4=fmt1[4],prec$0=fmt1[3],pad$2=fmt1[2],iconv$0=fmt1[1];
          return [5,iconv$0,pad$2,prec$0,concat_fmt(rest$4,fmt2)];
         case 6:
          var rest$5=fmt1[4],prec$1=fmt1[3],pad$3=fmt1[2],iconv$1=fmt1[1];
          return [6,iconv$1,pad$3,prec$1,concat_fmt(rest$5,fmt2)];
         case 7:
          var rest$6=fmt1[4],prec$2=fmt1[3],pad$4=fmt1[2],iconv$2=fmt1[1];
          return [7,iconv$2,pad$4,prec$2,concat_fmt(rest$6,fmt2)];
         case 8:
          var rest$7=fmt1[4],prec$3=fmt1[3],pad$5=fmt1[2],fconv=fmt1[1];
          return [8,fconv,pad$5,prec$3,concat_fmt(rest$7,fmt2)];
         case 9:
          var rest$8=fmt1[2],pad$6=fmt1[1];
          return [9,pad$6,concat_fmt(rest$8,fmt2)];
         case 10:var rest$9=fmt1[1];return [10,concat_fmt(rest$9,fmt2)];
         case 11:
          var rest$10=fmt1[2],str=fmt1[1];
          return [11,str,concat_fmt(rest$10,fmt2)];
         case 12:
          var rest$11=fmt1[2],chr=fmt1[1];
          return [12,chr,concat_fmt(rest$11,fmt2)];
         case 13:
          var rest$12=fmt1[3],fmtty=fmt1[2],pad$7=fmt1[1];
          return [13,pad$7,fmtty,concat_fmt(rest$12,fmt2)];
         case 14:
          var rest$13=fmt1[3],fmtty$0=fmt1[2],pad$8=fmt1[1];
          return [14,pad$8,fmtty$0,concat_fmt(rest$13,fmt2)];
         case 15:var rest$14=fmt1[1];return [15,concat_fmt(rest$14,fmt2)];
         case 16:var rest$15=fmt1[1];return [16,concat_fmt(rest$15,fmt2)];
         case 17:
          var rest$16=fmt1[2],fmting_lit=fmt1[1];
          return [17,fmting_lit,concat_fmt(rest$16,fmt2)];
         case 18:
          var rest$17=fmt1[2],fmting_gen=fmt1[1];
          return [18,fmting_gen,concat_fmt(rest$17,fmt2)];
         case 19:var rest$18=fmt1[1];return [19,concat_fmt(rest$18,fmt2)];
         case 20:
          var rest$19=fmt1[3],char_set=fmt1[2],width_opt=fmt1[1];
          return [20,width_opt,char_set,concat_fmt(rest$19,fmt2)];
         case 21:
          var rest$20=fmt1[2],counter=fmt1[1];
          return [21,counter,concat_fmt(rest$20,fmt2)];
         case 22:var rest$21=fmt1[1];return [22,concat_fmt(rest$21,fmt2)];
         case 23:
          var rest$22=fmt1[2],ign=fmt1[1];
          return [23,ign,concat_fmt(rest$22,fmt2)];
         default:
          var rest$23=fmt1[3],f=fmt1[2],arity=fmt1[1];
          return [24,arity,f,concat_fmt(rest$23,fmt2)]}}
    function failwith(s){throw [0,Failure,s]}
    function invalid_arg(s){throw [0,Invalid_argument,s]}
    var Exit=[248,_a_,caml_fresh_oo_id(0)];
    function min(x,y){return caml_lessequal(x,y)?x:y}
    function max(x,y){return caml_greaterequal(x,y)?x:y}
    function abs(x){return 0 <= x?x:- x | 0}
    var
     f_max=caml_int64_float_of_bits(_b_),
     upper_bound=caml_int64_float_of_bits(_c_),
     nan=caml_int64_float_of_bits(_d_),
     max_float=caml_int64_float_of_bits(_e_),
     min_float=caml_int64_float_of_bits(_f_),
     max_int=2147483647;
    function symbol(s1,s2)
     {var
       l1=caml_ml_string_length(s1),
       l2=caml_ml_string_length(s2),
       s=caml_create_bytes(l1 + l2 | 0);
      caml_blit_string(s1,0,s,0,l1);
      caml_blit_string(s2,0,s,l1,l2);
      return caml_string_of_bytes(s)}
    function string_of_bool(b){return b?_g_:_h_}
    function bool_of_string(param)
     {return caml_string_notequal(param,_i_)
              ?caml_string_notequal(param,_j_)?invalid_arg(_k_):1
              :0}
    function string_of_float(f)
     {var s=caml_format_float(_m_,f),l=caml_ml_string_length(s),i=0;
      for(;;)
       {if(l <= i)return symbol(s,_l_);
        var match=caml_string_get(s,i),switch$0=0;
        if(48 <= match)
         {if(! (58 <= match))switch$0 = 1}
        else
         if(45 === match)switch$0 = 1;
        if(switch$0){var i$0=i + 1 | 0,i=i$0;continue}
        return s}}
    function append(l1,l2)
     {if(l1){var tl=l1[2],hd=l1[1];return [0,hd,append(tl,l2)]}return l2}
    caml_ml_open_descriptor_in(0);
    var
     stdout=caml_ml_open_descriptor_out(1),
     stderr=caml_ml_open_descriptor_out(2);
    function open_out_gen(mode,perm,name)
     {var c=caml_ml_open_descriptor_out(caml_sys_open(name,mode,perm));
      caml_ml_set_channel_name(c,name);
      return c}
    function open_out(name){return open_out_gen(_n_,438,name)}
    function flush_all(param)
     {function iter(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var l=param$0[2],a=param$0[1];
            try
             {caml_ml_flush(a)}
            catch(_$K_)
             {_$K_ = caml_wrap_exception(_$K_);
              if(_$K_[1] !== Sys_error)throw _$K_;
              var _$J_=_$K_}
            var param$0=l;
            continue}
          return 0}}
      return iter(caml_ml_out_channels_list(0))}
    function output_string(oc,s)
     {return caml_ml_output(oc,s,0,caml_ml_string_length(s))}
    function output_substring(oc,s,ofs,len)
     {if
       (0
        <=
        ofs
        &&
        0
        <=
        len
        &&
        !
        ((caml_ml_string_length(s) - len | 0) < ofs))
       return caml_ml_output(oc,s,ofs,len);
      return invalid_arg(_p_)}
    function close_out(oc){caml_ml_flush(oc);return caml_ml_close_channel(oc)}
    function open_in(name)
     {var c=caml_ml_open_descriptor_in(caml_sys_open(name,mode,0));
      caml_ml_set_channel_name(c,name);
      return c}
    function input_line(chan)
     {function build_result(buf,pos,param)
       {var pos$0=pos,param$0=param;
        for(;;)
         {if(param$0)
           {var param$1=param$0[2],hd=param$0[1],len=caml_ml_bytes_length(hd);
            caml_blit_bytes(hd,0,buf,pos$0 - len | 0,len);
            var pos$1=pos$0 - len | 0,pos$0=pos$1,param$0=param$1;
            continue}
          return buf}}
      var accu=0,len=0;
      for(;;)
       {var n=caml_ml_input_scan_line(chan);
        if(0 === n)
         {if(! accu)throw End_of_file;
          var _$I_=build_result(caml_create_bytes(len),len,accu)}
        else
         {if(! (0 < n))
           {var beg=caml_create_bytes(- n | 0);
            caml_ml_input(chan,beg,0,- n | 0);
            var len$1=len - n | 0,accu$0=[0,beg,accu],accu=accu$0,len=len$1;
            continue}
          var res=caml_create_bytes(n - 1 | 0);
          caml_ml_input(chan,res,0,n - 1 | 0);
          caml_ml_input_char(chan);
          if(accu)
           var
            len$0=(len + n | 0) - 1 | 0,
            _$I_=build_result(caml_create_bytes(len$0),len$0,[0,res,accu]);
          else
           var _$I_=res}
        return caml_string_of_bytes(_$I_)}}
    var exit_function=[0,flush_all];
    function at_exit(f)
     {var g=exit_function[1],f_already_ran=[0,0];
      exit_function[1]
      =
      function(param)
       {if(1 - f_already_ran[1]){f_already_ran[1] = 1;caml_call1(f,0)}
        return caml_call1(g,0)};
      return 0}
    function do_at_exit(param){return caml_call1(exit_function[1],0)}
    function exit(retcode){do_at_exit(0);return caml_sys_exit(retcode)}
    function map(f,seq,param)
     {var match=caml_call1(seq,0);
      if(match)
       {var
         next=match[2],
         x=match[1],
         _$G_=function(_$H_){return map(f,next,_$H_)};
        return [0,caml_call1(f,x),_$G_]}
      return 0}
    function iter(f,seq)
     {var seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var seq$1=match[2],x=match[1];
          caml_call1(f,x);
          var seq$0=seq$1;
          continue}
        return 0}}
    function chr(n){if(0 <= n && ! (255 < n))return n;return invalid_arg(_q_)}
    function lowercase(c)
     {var switch$0=0;
      if(! (65 <= c) || 90 < c)switch$0 = 1;
      if(switch$0)
       {var switch$1=0;
        if(! (192 <= c) || 214 < c)switch$1 = 1;
        if(switch$1)
         {var switch$2=0;
          if(! (216 <= c) || 222 < c)switch$2 = 1;
          if(switch$2)return c}}
      return c + 32 | 0}
    function lowercase_ascii(c)
     {if(65 <= c && ! (90 < c))return c + 32 | 0;return c}
    function uppercase_ascii(c)
     {if(97 <= c && ! (122 < c))return c - 32 | 0;return c}
    var
     match=caml_sys_get_argv(0),
     argv=match[2],
     executable_name=match[1],
     match$0=caml_sys_get_config(0),
     os_type=match$0[1],
     match$1=caml_sys_const_backend_type(0),
     max_array_length=caml_sys_const_max_wosize(0),
     max_string_length=(4 * max_array_length | 0) - 1 | 0;
    caml_fresh_oo_id(0);
    function length(l)
     {var len=0,param=l;
      for(;;)
       {if(param)
         {var param$0=param[2],len$0=len + 1 | 0,len=len$0,param=param$0;
          continue}
        return len}}
    function hd(param){if(param){var a=param[1];return a}return failwith(_x_)}
    function rev_append(l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {var l1$1=l1$0[2],a=l1$0[1],l2$1=[0,a,l2$0],l1$0=l1$1,l2$0=l2$1;
          continue}
        return l2$0}}
    function rev(l){return rev_append(l,0)}
    typeof match$1 === "number";
    function map$0(f,param)
     {if(param)
       {var l=param[2],a=param[1],r=caml_call1(f,a);return [0,r,map$0(f,l)]}
      return 0}
    function _y_(i,f,param)
     {if(param)
       {var l=param[2],a=param[1],r=caml_call2(f,i,a);
        return [0,r,_y_(i + 1 | 0,f,l)]}
      return 0}
    function iter$0(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var param$1=param$0[2],a=param$0[1];
          caml_call1(f,a);
          var param$0=param$1;
          continue}
        return 0}}
    function iteri(f,l)
     {var i=0,param=l;
      for(;;)
       {if(param)
         {var param$0=param[2],a=param[1];
          caml_call2(f,i,a);
          var i$0=i + 1 | 0,i=i$0,param=param$0;
          continue}
        return 0}}
    function fold_left(f,accu,l)
     {var accu$0=accu,l$0=l;
      for(;;)
       {if(l$0)
         {var
           l$1=l$0[2],
           a=l$0[1],
           accu$1=caml_call2(f,accu$0,a),
           accu$0=accu$1,
           l$0=l$1;
          continue}
        return accu$0}}
    function map2(f,l1,l2)
     {if(l1)
       {if(l2)
         {var l2$0=l2[2],a2=l2[1],l1$0=l1[2],a1=l1[1],r=caml_call2(f,a1,a2);
          return [0,r,map2(f,l1$0,l2$0)]}}
      else
       if(! l2)return 0;
      return invalid_arg(_z_)}
    function mem(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_$F_=0 === caml_compare(a,x)?1:0;
          if(_$F_)return _$F_;
          var param$0=l;
          continue}
        return 0}}
    function chop(k,l)
     {var k$0=k,l$0=l;
      for(;;)
       {if(0 === k$0)return l$0;
        if(l$0){var l$1=l$0[2],k$1=k$0 - 1 | 0,k$0=k$1,l$0=l$1;continue}
        throw [0,Assert_failure,_A_]}}
    function stable_sort(cmp,l)
     {function rev_sort(n,l)
       {if(2 === n)
         {if(l)
           {var _$C_=l[2];
            if(_$C_)
             {var x2=_$C_[1],x1=l[1];
              return 0 < caml_call2(cmp,x1,x2)?[0,x1,[0,x2,0]]:[0,x2,[0,x1,0]]}}}
        else
         if(3 === n && l)
          {var _$D_=l[2];
           if(_$D_)
            {var _$E_=_$D_[2];
             if(_$E_)
              {var x3=_$E_[1],x2$0=_$D_[1],x1$0=l[1];
               return 0 < caml_call2(cmp,x1$0,x2$0)
                       ?0 < caml_call2(cmp,x2$0,x3)
                         ?[0,x1$0,[0,x2$0,[0,x3,0]]]
                         :0 < caml_call2(cmp,x1$0,x3)
                           ?[0,x1$0,[0,x3,[0,x2$0,0]]]
                           :[0,x3,[0,x1$0,[0,x2$0,0]]]
                       :0 < caml_call2(cmp,x1$0,x3)
                         ?[0,x2$0,[0,x1$0,[0,x3,0]]]
                         :0 < caml_call2(cmp,x2$0,x3)
                           ?[0,x2$0,[0,x3,[0,x1$0,0]]]
                           :[0,x3,[0,x2$0,[0,x1$0,0]]]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         l2$0=chop(n1,l),
         l1$0=sort(n1,l),
         l2$1=sort(n2,l2$0),
         l1=l1$0,
         l2=l2$1,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1];
              if(0 < caml_call2(cmp,h1,h2))
               {var accu$0=[0,h2,accu],l2=t2,accu=accu$0;continue}
              var accu$1=[0,h1,accu],l1=t1,accu=accu$1;
              continue}
            return rev_append(l1,accu)}
          return rev_append(l2,accu)}}
      function sort(n,l)
       {if(2 === n)
         {if(l)
           {var _$z_=l[2];
            if(_$z_)
             {var x2=_$z_[1],x1=l[1];
              return 0 < caml_call2(cmp,x1,x2)?[0,x2,[0,x1,0]]:[0,x1,[0,x2,0]]}}}
        else
         if(3 === n && l)
          {var _$A_=l[2];
           if(_$A_)
            {var _$B_=_$A_[2];
             if(_$B_)
              {var x3=_$B_[1],x2$0=_$A_[1],x1$0=l[1];
               return 0 < caml_call2(cmp,x1$0,x2$0)
                       ?0 < caml_call2(cmp,x1$0,x3)
                         ?0 < caml_call2(cmp,x2$0,x3)
                           ?[0,x3,[0,x2$0,[0,x1$0,0]]]
                           :[0,x2$0,[0,x3,[0,x1$0,0]]]
                         :[0,x2$0,[0,x1$0,[0,x3,0]]]
                       :0 < caml_call2(cmp,x2$0,x3)
                         ?0 < caml_call2(cmp,x1$0,x3)
                           ?[0,x3,[0,x1$0,[0,x2$0,0]]]
                           :[0,x1$0,[0,x3,[0,x2$0,0]]]
                         :[0,x1$0,[0,x2$0,[0,x3,0]]]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         l2$0=chop(n1,l),
         l1$0=rev_sort(n1,l),
         l2$1=rev_sort(n2,l2$0),
         l1=l1$0,
         l2=l2$1,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1];
              if(0 < caml_call2(cmp,h1,h2))
               {var accu$0=[0,h1,accu],l1=t1,accu=accu$0;continue}
              var accu$1=[0,h2,accu],l2=t2,accu=accu$1;
              continue}
            return rev_append(l1,accu)}
          return rev_append(l2,accu)}}
      var len=length(l);
      return 2 <= len?sort(len,l):l}
    function make(n,c)
     {var s=caml_create_bytes(n);caml_fill_bytes(s,0,n,c);return s}
    var empty=caml_create_bytes(0);
    function copy(s)
     {var len=caml_ml_bytes_length(s),r=caml_create_bytes(len);
      caml_blit_bytes(s,0,r,0,len);
      return r}
    function to_string(b){return caml_string_of_bytes(copy(b))}
    function sub(s,ofs,len)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       {var r=caml_create_bytes(len);caml_blit_bytes(s,ofs,r,0,len);return r}
      return invalid_arg(_B_)}
    function sub_string(b,ofs,len)
     {return caml_string_of_bytes(sub(b,ofs,len))}
    function blit(s1,ofs1,s2,ofs2,len)
     {if
       (0
        <=
        len
        &&
        0
        <=
        ofs1
        &&
        !
        ((caml_ml_bytes_length(s1) - len | 0) < ofs1)
        &&
        0
        <=
        ofs2
        &&
        !
        ((caml_ml_bytes_length(s2) - len | 0) < ofs2))
       return caml_blit_bytes(s1,ofs1,s2,ofs2,len);
      return invalid_arg(_C_)}
    function blit$0(s1,ofs1,s2,ofs2,len)
     {if
       (0
        <=
        len
        &&
        0
        <=
        ofs1
        &&
        !
        ((caml_ml_string_length(s1) - len | 0) < ofs1)
        &&
        0
        <=
        ofs2
        &&
        !
        ((caml_ml_bytes_length(s2) - len | 0) < ofs2))
       return caml_blit_string(s1,ofs1,s2,ofs2,len);
      return invalid_arg(_D_)}
    function is_space(param)
     {var _$y_=param - 9 | 0,switch$0=0;
      if(4 < _$y_ >>> 0)
       {if(23 === _$y_)switch$0 = 1}
      else
       if(2 !== _$y_)switch$0 = 1;
      return switch$0?1:0}
    function map$1(f,s)
     {var l=caml_ml_bytes_length(s);
      if(0 === l)return s;
      var r=caml_create_bytes(l),_$w_=l - 1 | 0,_$v_=0;
      if(! (_$w_ < 0))
       {var i=_$v_;
        for(;;)
         {caml_bytes_unsafe_set(r,i,caml_call1(f,caml_bytes_unsafe_get(s,i)));
          var _$x_=i + 1 | 0;
          if(_$w_ !== i){var i=_$x_;continue}
          break}}
      return r}
    function make$0(n,c){return caml_string_of_bytes(make(n,c))}
    function sub$0(s,ofs,len)
     {return caml_string_of_bytes(sub(caml_bytes_of_string(s),ofs,len))}
    function concat(sep,l)
     {if(l)
       {var seplen=caml_ml_string_length(sep),acc=0,param=l,pos$1=0;
        for(;;)
         {if(param)
           {var _$q_=param[2],_$r_=param[1];
            if(_$q_)
             {var
               x=(caml_ml_string_length(_$r_) + seplen | 0) + acc | 0,
               acc$0=acc <= x?x:invalid_arg(_E_),
               acc=acc$0,
               param=_$q_;
              continue}
            var _$u_=caml_ml_string_length(_$r_) + acc | 0}
          else
           var _$u_=acc;
          var dst=caml_create_bytes(_$u_),pos=pos$1,param$0=l;
          for(;;)
           {if(param$0)
             {var _$s_=param$0[2],_$t_=param$0[1];
              if(_$s_)
               {caml_blit_string(_$t_,0,dst,pos,caml_ml_string_length(_$t_));
                caml_blit_string
                 (sep,0,dst,pos + caml_ml_string_length(_$t_) | 0,seplen);
                var
                 pos$0=(pos + caml_ml_string_length(_$t_) | 0) + seplen | 0,
                 pos=pos$0,
                 param$0=_$s_;
                continue}
              caml_blit_string(_$t_,0,dst,pos,caml_ml_string_length(_$t_))}
            return caml_string_of_bytes(dst)}}}
      return _F_}
    function is_space$0(param)
     {var _$p_=param - 9 | 0,switch$0=0;
      if(4 < _$p_ >>> 0)
       {if(23 === _$p_)switch$0 = 1}
      else
       if(2 !== _$p_)switch$0 = 1;
      return switch$0?1:0}
    function trim(s)
     {if(caml_string_equal(s,_G_))return s;
      if
       (!
        is_space$0(caml_string_unsafe_get(s,0))
        &&
        !
        is_space$0(caml_string_unsafe_get(s,caml_ml_string_length(s) - 1 | 0)))
       return s;
      var s$0=caml_bytes_of_string(s),len=caml_ml_bytes_length(s$0),i=[0,0];
      for(;;)
       {if(i[1] < len && is_space(caml_bytes_unsafe_get(s$0,i[1])))
         {i[1]++;continue}
        var j=[0,len - 1 | 0];
        for(;;)
         {if(i[1] <= j[1] && is_space(caml_bytes_unsafe_get(s$0,j[1])))
           {j[1] += -1;continue}
          var _$o_=i[1] <= j[1]?sub(s$0,i[1],(j[1] - i[1] | 0) + 1 | 0):empty;
          return caml_string_of_bytes(_$o_)}}}
    function escaped(s$0)
     {var n$0=caml_ml_string_length(s$0),i$1=0;
      for(;;)
       {if(n$0 <= i$1)return s$0;
        var
         match$0=caml_string_unsafe_get(s$0,i$1),
         _$m_=match$0 - 32 | 0,
         switch$0=0;
        if(59 < _$m_ >>> 0)
         {if(33 < (_$m_ - 61 | 0) >>> 0)switch$0 = 1}
        else
         if(2 === _$m_)switch$0 = 1;
        if(switch$0)
         {var
           s$1=caml_bytes_of_string(s$0),
           n=[0,0],
           _$f_=caml_ml_bytes_length(s$1) - 1 | 0,
           _$e_=0;
          if(! (_$f_ < 0))
           {var i$0=_$e_;
            for(;;)
             {var match=caml_bytes_unsafe_get(s$1,i$0),switch$1=0;
              if(32 <= match)
               {var _$j_=match - 34 | 0,switch$2=0;
                if(58 < _$j_ >>> 0)
                 {if(93 <= _$j_)switch$2 = 1}
                else
                 if(56 < (_$j_ - 1 | 0) >>> 0){switch$1 = 1;switch$2 = 1}
                if(! switch$2){var _$k_=1;switch$1 = 2}}
              else
               if(11 <= match)
                {if(13 === match)switch$1 = 1}
               else
                if(8 <= match)switch$1 = 1;
              switch(switch$1)
               {case 0:var _$k_=4;break;case 1:var _$k_=2;break}
              n[1] = n[1] + _$k_ | 0;
              var _$l_=i$0 + 1 | 0;
              if(_$f_ !== i$0){var i$0=_$l_;continue}
              break}}
          if(n[1] === caml_ml_bytes_length(s$1))
           var _$n_=copy(s$1);
          else
           {var s=caml_create_bytes(n[1]);
            n[1] = 0;
            var _$h_=caml_ml_bytes_length(s$1) - 1 | 0,_$g_=0;
            if(! (_$h_ < 0))
             {var i=_$g_;
              for(;;)
               {var c=caml_bytes_unsafe_get(s$1,i),switch$3=0;
                if(35 <= c)
                 if(92 === c)
                  switch$3 = 2;
                 else
                  if(127 <= c)switch$3 = 1;else switch$3 = 3;
                else
                 if(32 <= c)
                  if(34 <= c)switch$3 = 2;else switch$3 = 3;
                 else
                  if(14 <= c)
                   switch$3 = 1;
                  else
                   switch(c)
                    {case 8:
                      caml_bytes_unsafe_set(s,n[1],92);
                      n[1]++;
                      caml_bytes_unsafe_set(s,n[1],98);
                      break;
                     case 9:
                      caml_bytes_unsafe_set(s,n[1],92);
                      n[1]++;
                      caml_bytes_unsafe_set(s,n[1],116);
                      break;
                     case 10:
                      caml_bytes_unsafe_set(s,n[1],92);
                      n[1]++;
                      caml_bytes_unsafe_set(s,n[1],110);
                      break;
                     case 13:
                      caml_bytes_unsafe_set(s,n[1],92);
                      n[1]++;
                      caml_bytes_unsafe_set(s,n[1],114);
                      break;
                     default:switch$3 = 1}
                switch(switch$3)
                 {case 1:
                   caml_bytes_unsafe_set(s,n[1],92);
                   n[1]++;
                   caml_bytes_unsafe_set(s,n[1],48 + (c / 100 | 0) | 0);
                   n[1]++;
                   caml_bytes_unsafe_set
                    (s,n[1],48 + ((c / 10 | 0) % 10 | 0) | 0);
                   n[1]++;
                   caml_bytes_unsafe_set(s,n[1],48 + (c % 10 | 0) | 0);
                   break;
                  case 2:
                   caml_bytes_unsafe_set(s,n[1],92);
                   n[1]++;
                   caml_bytes_unsafe_set(s,n[1],c);
                   break;
                  case 3:caml_bytes_unsafe_set(s,n[1],c);break
                  }
                n[1]++;
                var _$i_=i + 1 | 0;
                if(_$h_ !== i){var i=_$i_;continue}
                break}}
            var _$n_=s}
          return caml_string_of_bytes(_$n_)}
        var i$2=i$1 + 1 | 0,i$1=i$2;
        continue}}
    function index_rec(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)throw Not_found;
        if(caml_string_unsafe_get(s,i$0) === c)return i$0;
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index(s,c){return index_rec(s,caml_ml_string_length(s),0,c)}
    function contains_from(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i && ! (l < i))
       try
        {index_rec(s,l,i,c);var _$c_=1;return _$c_}
       catch(_$d_)
        {_$d_ = caml_wrap_exception(_$d_);
         if(_$d_ === Not_found)return 0;
         throw _$d_}
      return invalid_arg(_H_)}
    function contains(s,c){return contains_from(s,0,c)}
    function lowercase_ascii$0(s)
     {var s$0=caml_bytes_of_string(s);
      return caml_string_of_bytes(map$1(lowercase_ascii,s$0))}
    function copy$0(a)
     {var l=a.length - 1;return 0 === l?[0]:caml_array_sub(a,0,l)}
    function sub$1(a,ofs,len)
     {if(0 <= ofs && 0 <= len && ! ((a.length - 1 - len | 0) < ofs))
       return caml_array_sub(a,ofs,len);
      return invalid_arg(_I_)}
    function blit$1(a1,ofs1,a2,ofs2,len)
     {if
       (0
        <=
        len
        &&
        0
        <=
        ofs1
        &&
        !
        ((a1.length - 1 - len | 0) < ofs1)
        &&
        0
        <=
        ofs2
        &&
        !
        ((a2.length - 1 - len | 0) < ofs2))
       return caml_array_blit(a1,ofs1,a2,ofs2,len);
      return invalid_arg(_J_)}
    function map$2(f,a)
     {var l=a.length - 1;
      if(0 === l)return [0];
      var r=caml_make_vect(l,caml_call1(f,a[1])),_$a_=l - 1 | 0,__$_=1;
      if(! (_$a_ < 1))
       {var i=__$_;
        for(;;)
         {r[1 + i] = caml_call1(f,a[1 + i]);
          var _$b_=i + 1 | 0;
          if(_$a_ !== i){var i=_$b_;continue}
          break}}
      return r}
    function of_list(l)
     {if(l)
       {var tl=l[2],hd=l[1],accu=0,param=l;
        for(;;)
         {if(param)
           {var
             param$0=param[2],
             accu$0=accu + 1 | 0,
             accu=accu$0,
             param=param$0;
            continue}
          var a=caml_make_vect(accu,hd),i=1,param$1=tl;
          for(;;)
           {if(param$1)
             {var param$2=param$1[2],hd$0=param$1[1];
              a[1 + i] = hd$0;
              var i$0=i + 1 | 0,i=i$0,param$1=param$2;
              continue}
            return a}}}
      return [0]}
    function fold_left$0(f,x,a)
     {var r=[0,x],__9_=a.length - 1 - 1 | 0,__8_=0;
      if(! (__9_ < 0))
       {var i=__8_;
        for(;;)
         {r[1] = caml_call2(f,r[1],a[1 + i]);
          var ____=i + 1 | 0;
          if(__9_ !== i){var i=____;continue}
          break}}
      return r[1]}
    var Bottom=[248,_K_,caml_fresh_oo_id(0)];
    function succ(n){return caml_int64_add(n,_M_)}
    function pred(n){return caml_int64_sub(n,_N_)}
    function from_string(s)
     {var
       __0_=[0],
       __1_=1,
       __2_=0,
       __3_=0,
       __4_=0,
       __5_=0,
       __6_=0,
       __7_=caml_ml_string_length(s),
       __Z_=copy(caml_bytes_of_string(s));
      return [0,
              function(lexbuf){lexbuf[9] = 1;return 0},
              __Z_,
              __7_,
              __6_,
              __5_,
              __4_,
              __3_,
              __2_,
              __1_,
              __0_,
              zero_pos,
              zero_pos]}
    function lexeme(lexbuf)
     {var len=lexbuf[6] - lexbuf[5] | 0;
      return sub_string(lexbuf[2],lexbuf[5],len)}
    function sub_lexeme(lexbuf,i1,i2)
     {var len=i2 - i1 | 0;return sub_string(lexbuf[2],i1,len)}
    var
     YYexit=[248,_O_,caml_fresh_oo_id(0)],
     Parse_error=[248,_P_,caml_fresh_oo_id(0)],
     env=
      [0,
       caml_make_vect(100,0),
       caml_make_vect(100,0),
       caml_make_vect(100,dummy_pos),
       caml_make_vect(100,dummy_pos),
       100,
       0,
       0,
       0,
       dummy_pos,
       dummy_pos,
       0,
       0,
       0,
       0,
       0,
       0];
    function grow_stacks(param)
     {var
       oldsize=env[5],
       newsize=oldsize * 2 | 0,
       new_s=caml_make_vect(newsize,0),
       new_v=caml_make_vect(newsize,0),
       new_start=caml_make_vect(newsize,dummy_pos),
       new_end=caml_make_vect(newsize,dummy_pos);
      blit$1(env[1],0,new_s,0,oldsize);
      env[1] = new_s;
      blit$1(env[2],0,new_v,0,oldsize);
      env[2] = new_v;
      blit$1(env[3],0,new_start,0,oldsize);
      env[3] = new_start;
      blit$1(env[4],0,new_end,0,oldsize);
      env[4] = new_end;
      env[5] = newsize;
      return 0}
    var current_lookahead_fun=[0,function(param){return 0}];
    function yyparse(tables,start,lexer,lexbuf)
     {var
       init_asp=env[11],
       init_sp=env[14],
       init_stackbase=env[6],
       init_state=env[15],
       init_curr_char=env[7],
       init_lval=env[8],
       init_errflag=env[16];
      env[6] = env[14] + 1 | 0;
      env[7] = start;
      env[10] = lexbuf[12];
      try
       {var cmd=0,arg=0;
        for(;;)
         {var match=caml_parse_engine(tables,env,cmd,arg);
          switch(match)
           {case 0:
             var arg$0=caml_call1(lexer,lexbuf);
             env[9] = lexbuf[11];
             env[10] = lexbuf[12];
             var cmd=1,arg=arg$0;
             continue;
            case 1:throw Parse_error;
            case 2:grow_stacks(0);var cmd=2,arg=0;continue;
            case 3:grow_stacks(0);var cmd=3,arg=0;continue;
            case 4:
             try
              {var
                __T_=env[13],
                __U_=
                 caml_call1(caml_check_bound(tables[1],__T_)[1 + __T_],env),
                __V_=4,
                cmd$0=__V_,
                arg$1=__U_}
             catch(__Y_)
              {__Y_ = caml_wrap_exception(__Y_);
               if(__Y_ !== Parse_error)throw __Y_;
               var cmd$0=5,arg$1=0,__W_=__Y_}
             var cmd=cmd$0,arg=arg$1;
             continue;
            default:caml_call1(tables[14],_Q_);var cmd=5,arg=0;continue}}}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        var curr_char=env[7];
        env[11] = init_asp;
        env[14] = init_sp;
        env[6] = init_stackbase;
        env[15] = init_state;
        env[7] = init_curr_char;
        env[8] = init_lval;
        env[16] = init_errflag;
        if(exn[1] === YYexit){var v=exn[2];return v}
        current_lookahead_fun[1]
        =
        function(tok)
         {if(1 - (typeof tok === "number"?1:0))
           {var __X_=caml_obj_tag(tok);
            return caml_check_bound(tables[3],__X_)[1 + __X_] === curr_char
                    ?1
                    :0}
          return caml_check_bound(tables[2],tok)[1 + tok] === curr_char?1:0};
        throw exn}}
    function peek_val(env,n)
     {var __S_=env[11] - n | 0;return caml_check_bound(env[2],__S_)[1 + __S_]}
    function parse_error(param){return 0}
    function _Z_(Ord)
     {function height(param){if(param){var h=param[5];return h}return 0}
      function create(l,x,d,r)
       {var hl=height(l),hr=height(r),__R_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
        return [0,l,x,d,r,__R_]}
      function singleton(x,d){return [0,0,x,d,0,1]}
      function bal(l,x,d,r)
       {if(l)var h=l[5],hl=h;else var hl=0;
        if(r)var h$0=r[5],hr=h$0;else var hr=0;
        if((hr + 2 | 0) < hl)
         {if(l)
           {var lr=l[4],ld=l[3],lv=l[2],ll=l[1],__M_=height(lr);
            if(__M_ <= height(ll))return create(ll,lv,ld,create(lr,x,d,r));
            if(lr)
             {var
               lrr=lr[4],
               lrd=lr[3],
               lrv=lr[2],
               lrl=lr[1],
               __N_=create(lrr,x,d,r);
              return create(create(ll,lv,ld,lrl),lrv,lrd,__N_)}
            return invalid_arg(_R_)}
          return invalid_arg(_S_)}
        if((hl + 2 | 0) < hr)
         {if(r)
           {var rr=r[4],rd=r[3],rv=r[2],rl=r[1],__O_=height(rl);
            if(__O_ <= height(rr))return create(create(l,x,d,rl),rv,rd,rr);
            if(rl)
             {var
               rlr=rl[4],
               rld=rl[3],
               rlv=rl[2],
               rll=rl[1],
               __P_=create(rlr,rv,rd,rr);
              return create(create(l,x,d,rll),rlv,rld,__P_)}
            return invalid_arg(_T_)}
          return invalid_arg(_U_)}
        var __Q_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
        return [0,l,x,d,r,__Q_]}
      var empty=0;
      function is_empty(param){return param?0:1}
      function add(x,data,m)
       {if(m)
         {var h=m[5],r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
          if(0 === c)return d === data?m:[0,l,x,data,r,h];
          if(0 <= c){var rr=add(x,data,r);return r === rr?m:bal(l,v,d,rr)}
          var ll=add(x,data,l);
          return l === ll?m:bal(ll,v,d,r)}
        return [0,0,x,data,0,1]}
      function find(x,param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var
             r=param$0[4],
             d=param$0[3],
             v=param$0[2],
             l=param$0[1],
             c=caml_call2(Ord[1],x,v);
            if(0 === c)return d;
            var param$1=0 <= c?r:l,param$0=param$1;
            continue}
          throw Not_found}}
      function find_first(f,param$0)
       {var param$1=param$0;
        for(;;)
         {if(param$1)
           {var r$0=param$1[4],d$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
            if(caml_call1(f,v$0))
             {var v0=v$0,d0=d$0,param=l$0;
              for(;;)
               {if(param)
                 {var r=param[4],d=param[3],v=param[2],l=param[1];
                  if(caml_call1(f,v)){var v0=v,d0=d,param=l;continue}
                  var param=r;
                  continue}
                return [0,v0,d0]}}
            var param$1=r$0;
            continue}
          throw Not_found}}
      function find_first_opt(f,param$0)
       {var param$1=param$0;
        for(;;)
         {if(param$1)
           {var r$0=param$1[4],d$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
            if(caml_call1(f,v$0))
             {var v0=v$0,d0=d$0,param=l$0;
              for(;;)
               {if(param)
                 {var r=param[4],d=param[3],v=param[2],l=param[1];
                  if(caml_call1(f,v)){var v0=v,d0=d,param=l;continue}
                  var param=r;
                  continue}
                return [0,[0,v0,d0]]}}
            var param$1=r$0;
            continue}
          return 0}}
      function find_last(f,param$0)
       {var param$1=param$0;
        for(;;)
         {if(param$1)
           {var r$0=param$1[4],d$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
            if(caml_call1(f,v$0))
             {var v0=v$0,d0=d$0,param=r$0;
              for(;;)
               {if(param)
                 {var r=param[4],d=param[3],v=param[2],l=param[1];
                  if(caml_call1(f,v)){var v0=v,d0=d,param=r;continue}
                  var param=l;
                  continue}
                return [0,v0,d0]}}
            var param$1=l$0;
            continue}
          throw Not_found}}
      function find_last_opt(f,param$0)
       {var param$1=param$0;
        for(;;)
         {if(param$1)
           {var r$0=param$1[4],d$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
            if(caml_call1(f,v$0))
             {var v0=v$0,d0=d$0,param=r$0;
              for(;;)
               {if(param)
                 {var r=param[4],d=param[3],v=param[2],l=param[1];
                  if(caml_call1(f,v)){var v0=v,d0=d,param=r;continue}
                  var param=l;
                  continue}
                return [0,[0,v0,d0]]}}
            var param$1=l$0;
            continue}
          return 0}}
      function find_opt(x,param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var
             r=param$0[4],
             d=param$0[3],
             v=param$0[2],
             l=param$0[1],
             c=caml_call2(Ord[1],x,v);
            if(0 === c)return [0,d];
            var param$1=0 <= c?r:l,param$0=param$1;
            continue}
          return 0}}
      function mem(x,param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var
             r=param$0[4],
             v=param$0[2],
             l=param$0[1],
             c=caml_call2(Ord[1],x,v),
             __L_=0 === c?1:0;
            if(__L_)return __L_;
            var param$1=0 <= c?r:l,param$0=param$1;
            continue}
          return 0}}
      function min_binding(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var __K_=param$0[1];
            if(__K_){var param$0=__K_;continue}
            var d=param$0[3],v=param$0[2];
            return [0,v,d]}
          throw Not_found}}
      function min_binding_opt(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var __J_=param$0[1];
            if(__J_){var param$0=__J_;continue}
            var d=param$0[3],v=param$0[2];
            return [0,[0,v,d]]}
          return 0}}
      function max_binding(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var __G_=param$0[4],__H_=param$0[3],__I_=param$0[2];
            if(__G_){var param$0=__G_;continue}
            return [0,__I_,__H_]}
          throw Not_found}}
      function max_binding_opt(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var __D_=param$0[4],__E_=param$0[3],__F_=param$0[2];
            if(__D_){var param$0=__D_;continue}
            return [0,[0,__F_,__E_]]}
          return 0}}
      function remove_min_binding(param)
       {if(param)
         {var __C_=param[1];
          if(__C_)
           {var r=param[4],d=param[3],v=param[2];
            return bal(remove_min_binding(__C_),v,d,r)}
          var r$0=param[4];
          return r$0}
        return invalid_arg(_V_)}
      function __f_(t,match)
       {if(t)
         {if(match)
           {var match$0=min_binding(match),d=match$0[2],x=match$0[1];
            return bal(t,x,d,remove_min_binding(match))}
          return t}
        return match}
      function remove(x,m)
       {if(m)
         {var r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
          if(0 === c)return __f_(l,r);
          if(0 <= c){var rr=remove(x,r);return r === rr?m:bal(l,v,d,rr)}
          var ll=remove(x,l);
          return l === ll?m:bal(ll,v,d,r)}
        return 0}
      function update(x,f,m)
       {if(m)
         {var h=m[5],r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
          if(0 === c)
           {var match=caml_call1(f,[0,d]);
            if(match){var data=match[1];return d === data?m:[0,l,x,data,r,h]}
            return __f_(l,r)}
          if(0 <= c){var rr=update(x,f,r);return r === rr?m:bal(l,v,d,rr)}
          var ll=update(x,f,l);
          return l === ll?m:bal(ll,v,d,r)}
        var match$0=caml_call1(f,0);
        if(match$0){var data$0=match$0[1];return [0,0,x,data$0,0,1]}
        return 0}
      function iter(f,param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var param$1=param$0[4],d=param$0[3],v=param$0[2],l=param$0[1];
            iter(f,l);
            caml_call2(f,v,d);
            var param$0=param$1;
            continue}
          return 0}}
      function map(f,param)
       {if(param)
         {var
           h=param[5],
           r=param[4],
           d=param[3],
           v=param[2],
           l=param[1],
           l$0=map(f,l),
           d$0=caml_call1(f,d),
           r$0=map(f,r);
          return [0,l$0,v,d$0,r$0,h]}
        return 0}
      function mapi(f,param)
       {if(param)
         {var
           h=param[5],
           r=param[4],
           d=param[3],
           v=param[2],
           l=param[1],
           l$0=mapi(f,l),
           d$0=caml_call2(f,v,d),
           r$0=mapi(f,r);
          return [0,l$0,v,d$0,r$0,h]}
        return 0}
      function fold(f,m,accu)
       {var m$0=m,accu$0=accu;
        for(;;)
         {if(m$0)
           {var
             m$1=m$0[4],
             d=m$0[3],
             v=m$0[2],
             l=m$0[1],
             accu$1=caml_call3(f,v,d,fold(f,l,accu$0)),
             m$0=m$1,
             accu$0=accu$1;
            continue}
          return accu$0}}
      function for_all(p,param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var
             r=param$0[4],
             d=param$0[3],
             v=param$0[2],
             l=param$0[1],
             __z_=caml_call2(p,v,d);
            if(__z_)
             {var __A_=for_all(p,l);
              if(__A_){var param$0=r;continue}
              var __B_=__A_}
            else
             var __B_=__z_;
            return __B_}
          return 1}}
      function exists(p,param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var
             r=param$0[4],
             d=param$0[3],
             v=param$0[2],
             l=param$0[1],
             __w_=caml_call2(p,v,d);
            if(__w_)
             var __x_=__w_;
            else
             {var __y_=exists(p,l);
              if(! __y_){var param$0=r;continue}
              var __x_=__y_}
            return __x_}
          return 0}}
      function add_min_binding(k,x,param)
       {if(param)
         {var r=param[4],d=param[3],v=param[2],l=param[1];
          return bal(add_min_binding(k,x,l),v,d,r)}
        return singleton(k,x)}
      function add_max_binding(k,x,param)
       {if(param)
         {var r=param[4],d=param[3],v=param[2],l=param[1];
          return bal(l,v,d,add_max_binding(k,x,r))}
        return singleton(k,x)}
      function join(l,v,d,r)
       {if(l)
         {if(r)
           {var
             rh=r[5],
             rr=r[4],
             rd=r[3],
             rv=r[2],
             rl=r[1],
             lh=l[5],
             lr=l[4],
             ld=l[3],
             lv=l[2],
             ll=l[1];
            return (rh + 2 | 0) < lh
                    ?bal(ll,lv,ld,join(lr,v,d,r))
                    :(lh + 2 | 0) < rh
                      ?bal(join(l,v,d,rl),rv,rd,rr)
                      :create(l,v,d,r)}
          return add_max_binding(v,d,l)}
        return add_min_binding(v,d,r)}
      function concat(t,match)
       {if(t)
         {if(match)
           {var match$0=min_binding(match),d=match$0[2],x=match$0[1];
            return join(t,x,d,remove_min_binding(match))}
          return t}
        return match}
      function concat_or_join(t1,v,d,t2)
       {if(d){var d$0=d[1];return join(t1,v,d$0,t2)}return concat(t1,t2)}
      function split(x,param)
       {if(param)
         {var
           r=param[4],
           d=param[3],
           v=param[2],
           l=param[1],
           c=caml_call2(Ord[1],x,v);
          if(0 === c)return [0,l,[0,d],r];
          if(0 <= c)
           {var match=split(x,r),rr=match[3],pres=match[2],lr=match[1];
            return [0,join(l,v,d,lr),pres,rr]}
          var
           match$0=split(x,l),
           rl=match$0[3],
           pres$0=match$0[2],
           ll=match$0[1];
          return [0,ll,pres$0,join(rl,v,d,r)]}
        return _W_}
      function merge(f,s1,s2)
       {if(s1)
         {var h1=s1[5],r1=s1[4],d1=s1[3],v1=s1[2],l1=s1[1];
          if(height(s2) <= h1)
           {var
             match=split(v1,s2),
             r2=match[3],
             d2=match[2],
             l2=match[1],
             __s_=merge(f,r1,r2),
             __t_=caml_call3(f,v1,[0,d1],d2);
            return concat_or_join(merge(f,l1,l2),v1,__t_,__s_)}}
        else
         if(! s2)return 0;
        if(s2)
         {var
           r2$0=s2[4],
           d2$0=s2[3],
           v2=s2[2],
           l2$0=s2[1],
           match$0=split(v2,s1),
           r1$0=match$0[3],
           d1$0=match$0[2],
           l1$0=match$0[1],
           __u_=merge(f,r1$0,r2$0),
           __v_=caml_call3(f,v2,d1$0,[0,d2$0]);
          return concat_or_join(merge(f,l1$0,l2$0),v2,__v_,__u_)}
        throw [0,Assert_failure,_X_]}
      function union(f,s1,s2)
       {if(s1)
         {if(s2)
           {var
             h2=s2[5],
             r2=s2[4],
             d2=s2[3],
             v2=s2[2],
             l2=s2[1],
             h1=s1[5],
             r1=s1[4],
             d1=s1[3],
             v1=s1[2],
             l1=s1[1];
            if(h2 <= h1)
             {var
               match=split(v1,s2),
               r2$0=match[3],
               d2$0=match[2],
               l2$0=match[1],
               l=union(f,l1,l2$0),
               r=union(f,r1,r2$0);
              if(d2$0)
               {var d2$1=d2$0[1];
                return concat_or_join(l,v1,caml_call3(f,v1,d1,d2$1),r)}
              return join(l,v1,d1,r)}
            var
             match$0=split(v2,s1),
             r1$0=match$0[3],
             d1$0=match$0[2],
             l1$0=match$0[1],
             l$0=union(f,l1$0,l2),
             r$0=union(f,r1$0,r2);
            if(d1$0)
             {var d1$1=d1$0[1];
              return concat_or_join(l$0,v2,caml_call3(f,v2,d1$1,d2),r$0)}
            return join(l$0,v2,d2,r$0)}
          var s=s1}
        else
         var s=s2;
        return s}
      function filter(p,m)
       {if(m)
         {var
           r=m[4],
           d=m[3],
           v=m[2],
           l=m[1],
           l$0=filter(p,l),
           pvd=caml_call2(p,v,d),
           r$0=filter(p,r);
          if(pvd){if(l === l$0 && r === r$0)return m;return join(l$0,v,d,r$0)}
          return concat(l$0,r$0)}
        return 0}
      function partition(p,param)
       {if(param)
         {var
           r=param[4],
           d=param[3],
           v=param[2],
           l=param[1],
           match=partition(p,l),
           lf=match[2],
           lt=match[1],
           pvd=caml_call2(p,v,d),
           match$0=partition(p,r),
           rf=match$0[2],
           rt=match$0[1];
          if(pvd){var __q_=concat(lf,rf);return [0,join(lt,v,d,rt),__q_]}
          var __r_=join(lf,v,d,rf);
          return [0,concat(lt,rt),__r_]}
        return _Y_}
      function cons_enum(m,e)
       {var m$0=m,e$0=e;
        for(;;)
         {if(m$0)
           {var
             r=m$0[4],
             d=m$0[3],
             v=m$0[2],
             m$1=m$0[1],
             e$1=[0,v,d,r,e$0],
             m$0=m$1,
             e$0=e$1;
            continue}
          return e$0}}
      function compare(cmp,m1,m2)
       {var e2$2=cons_enum(m2,0),e1$2=cons_enum(m1,0),e1=e1$2,e2=e2$2;
        for(;;)
         {if(e1)
           {if(e2)
             {var
               e2$0=e2[4],
               r2=e2[3],
               d2=e2[2],
               v2=e2[1],
               e1$0=e1[4],
               r1=e1[3],
               d1=e1[2],
               v1=e1[1],
               c=caml_call2(Ord[1],v1,v2);
              if(0 === c)
               {var c$0=caml_call2(cmp,d1,d2);
                if(0 === c$0)
                 {var
                   e2$1=cons_enum(r2,e2$0),
                   e1$1=cons_enum(r1,e1$0),
                   e1=e1$1,
                   e2=e2$1;
                  continue}
                return c$0}
              return c}
            return 1}
          return e2?-1:0}}
      function equal(cmp,m1,m2)
       {var e2$2=cons_enum(m2,0),e1$2=cons_enum(m1,0),e1=e1$2,e2=e2$2;
        for(;;)
         {if(e1)
           {if(e2)
             {var
               e2$0=e2[4],
               r2=e2[3],
               d2=e2[2],
               v2=e2[1],
               e1$0=e1[4],
               r1=e1[3],
               d1=e1[2],
               v1=e1[1],
               __n_=0 === caml_call2(Ord[1],v1,v2)?1:0;
              if(__n_)
               {var __o_=caml_call2(cmp,d1,d2);
                if(__o_)
                 {var
                   e2$1=cons_enum(r2,e2$0),
                   e1$1=cons_enum(r1,e1$0),
                   e1=e1$1,
                   e2=e2$1;
                  continue}
                var __p_=__o_}
              else
               var __p_=__n_;
              return __p_}
            return 0}
          return e2?0:1}}
      function cardinal(param)
       {if(param)
         {var r=param[4],l=param[1],__m_=cardinal(r);
          return (cardinal(l) + 1 | 0) + __m_ | 0}
        return 0}
      function bindings_aux(accu,param)
       {var accu$0=accu,param$0=param;
        for(;;)
         {if(param$0)
           {var
             r=param$0[4],
             d=param$0[3],
             v=param$0[2],
             param$1=param$0[1],
             accu$1=[0,[0,v,d],bindings_aux(accu$0,r)],
             accu$0=accu$1,
             param$0=param$1;
            continue}
          return accu$0}}
      function bindings(s){return bindings_aux(0,s)}
      function add_seq(i,m)
       {var acc=m,seq=i;
        for(;;)
         {var match=caml_call1(seq,0);
          if(match)
           {var
             seq$0=match[2],
             x=match[1],
             v=x[2],
             k=x[1],
             acc$0=add(k,v,acc),
             acc=acc$0,
             seq=seq$0;
            continue}
          return acc}}
      function of_seq(i){return add_seq(i,empty)}
      function seq_of_enum(c,param)
       {if(c)
         {var rest=c[4],t=c[3],v=c[2],k=c[1],__k_=cons_enum(t,rest);
          return [0,[0,k,v],function(__l_){return seq_of_enum(__k_,__l_)}]}
        return 0}
      function to_seq(m)
       {var __i_=cons_enum(m,0);
        return function(__j_){return seq_of_enum(__i_,__j_)}}
      function to_seq_from(low,m)
       {var m$0=m,c=0;
        for(;;)
         {if(m$0)
           {var
             r=m$0[4],
             d=m$0[3],
             v=m$0[2],
             l=m$0[1],
             n=caml_call2(Ord[1],v,low);
            if(0 !== n)
             {if(0 <= n){var c$0=[0,v,d,r,c],m$0=l,c=c$0;continue}
              var m$0=r;
              continue}
            var __g_=[0,v,d,r,c]}
          else
           var __g_=c;
          return function(__h_){return seq_of_enum(__g_,__h_)}}}
      return [0,
              empty,
              is_empty,
              mem,
              add,
              update,
              singleton,
              remove,
              merge,
              union,
              compare,
              equal,
              iter,
              fold,
              for_all,
              exists,
              filter,
              partition,
              cardinal,
              bindings,
              min_binding,
              min_binding_opt,
              max_binding,
              max_binding_opt,
              min_binding,
              min_binding_opt,
              split,
              find,
              find_opt,
              find_first,
              find_first_opt,
              find_last,
              find_last_opt,
              map,
              mapi,
              to_seq,
              to_seq_from,
              add_seq,
              of_seq]}
    var Undefined=[248,___,caml_fresh_oo_id(0)];
    function raise_undefined(param){throw Undefined}
    function force_lazy_block(blk)
     {var closure=blk[1];
      blk[1] = raise_undefined;
      try
       {var result=caml_call1(closure,0);
        blk[1] = result;
        caml_obj_set_tag(blk,250);
        return result}
      catch(e)
       {e = caml_wrap_exception(e);blk[1] = function(param){throw e};throw e}}
    function create(n)
     {var
       n$0=1 <= n?n:1,
       n$1=max_string_length < n$0?max_string_length:n$0,
       s=caml_create_bytes(n$1);
      return [0,s,0,n$1,s]}
    function contents(b){return sub_string(b[1],0,b[2])}
    function resize(b,more)
     {var len=b[3],new_len=[0,len];
      for(;;)
       {if(new_len[1] < (b[2] + more | 0))
         {new_len[1] = 2 * new_len[1] | 0;continue}
        if(max_string_length < new_len[1])
         if((b[2] + more | 0) <= max_string_length)
          new_len[1] = max_string_length;
         else
          failwith(_aa_);
        var new_buffer=caml_create_bytes(new_len[1]);
        blit(b[1],0,new_buffer,0,b[2]);
        b[1] = new_buffer;
        b[3] = new_len[1];
        return 0}}
    function add_char(b,c)
     {var pos=b[2];
      if(b[3] <= pos)resize(b,1);
      caml_bytes_unsafe_set(b[1],pos,c);
      b[2] = pos + 1 | 0;
      return 0}
    function add_string(b,s)
     {var len=caml_ml_string_length(s),new_position=b[2] + len | 0;
      if(b[3] < new_position)resize(b,len);
      blit$0(s,0,b[1],b[2],len);
      b[2] = new_position;
      return 0}
    var default_float_precision=-6;
    function buffer_create(init_size)
     {return [0,0,caml_create_bytes(init_size)]}
    function buffer_check_size(buf,overhead)
     {var
       len=caml_ml_bytes_length(buf[2]),
       min_len=buf[1] + overhead | 0,
       __d_=len < min_len?1:0;
      if(__d_)
       {var
         new_len=max(len * 2 | 0,min_len),
         new_str=caml_create_bytes(new_len);
        blit(buf[2],0,new_str,0,len);
        buf[2] = new_str;
        var __e_=0}
      else
       var __e_=__d_;
      return __e_}
    function buffer_add_char(buf,c)
     {buffer_check_size(buf,1);
      caml_bytes_set(buf[2],buf[1],c);
      buf[1] = buf[1] + 1 | 0;
      return 0}
    function buffer_add_string(buf,s)
     {var str_len=caml_ml_string_length(s);
      buffer_check_size(buf,str_len);
      blit$0(s,0,buf[2],buf[1],str_len);
      buf[1] = buf[1] + str_len | 0;
      return 0}
    function buffer_contents(buf){return sub_string(buf[2],0,buf[1])}
    function string_of_formatting_lit(formatting_lit)
     {if(typeof formatting_lit === "number")
       switch(formatting_lit)
        {case 0:return _ac_;
         case 1:return _ad_;
         case 2:return _ae_;
         case 3:return _af_;
         case 4:return _ag_;
         case 5:return _ah_;
         default:return _ai_}
      else
       switch(formatting_lit[0])
        {case 0:var str=formatting_lit[1];return str;
         case 1:var str$0=formatting_lit[1];return str$0;
         default:var c=formatting_lit[1];return symbol(_aj_,make$0(1,c))}}
    function bprint_fmtty(buf,fmtty)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        return 0;
       else
        switch(fmtty$0[0])
         {case 0:
           var fmtty$1=fmtty$0[1];
           buffer_add_string(buf,_ak_);
           var fmtty$0=fmtty$1;
           continue;
          case 1:
           var fmtty$2=fmtty$0[1];
           buffer_add_string(buf,_al_);
           var fmtty$0=fmtty$2;
           continue;
          case 2:
           var fmtty$3=fmtty$0[1];
           buffer_add_string(buf,_am_);
           var fmtty$0=fmtty$3;
           continue;
          case 3:
           var fmtty$4=fmtty$0[1];
           buffer_add_string(buf,_an_);
           var fmtty$0=fmtty$4;
           continue;
          case 4:
           var fmtty$5=fmtty$0[1];
           buffer_add_string(buf,_ao_);
           var fmtty$0=fmtty$5;
           continue;
          case 5:
           var fmtty$6=fmtty$0[1];
           buffer_add_string(buf,_ap_);
           var fmtty$0=fmtty$6;
           continue;
          case 6:
           var fmtty$7=fmtty$0[1];
           buffer_add_string(buf,_aq_);
           var fmtty$0=fmtty$7;
           continue;
          case 7:
           var fmtty$8=fmtty$0[1];
           buffer_add_string(buf,_ar_);
           var fmtty$0=fmtty$8;
           continue;
          case 8:
           var fmtty$9=fmtty$0[2],sub_fmtty=fmtty$0[1];
           buffer_add_string(buf,_as_);
           bprint_fmtty(buf,sub_fmtty);
           buffer_add_string(buf,_at_);
           var fmtty$0=fmtty$9;
           continue;
          case 9:
           var fmtty$10=fmtty$0[3],sub_fmtty$0=fmtty$0[1];
           buffer_add_string(buf,_au_);
           bprint_fmtty(buf,sub_fmtty$0);
           buffer_add_string(buf,_av_);
           var fmtty$0=fmtty$10;
           continue;
          case 10:
           var fmtty$11=fmtty$0[1];
           buffer_add_string(buf,_aw_);
           var fmtty$0=fmtty$11;
           continue;
          case 11:
           var fmtty$12=fmtty$0[1];
           buffer_add_string(buf,_ax_);
           var fmtty$0=fmtty$12;
           continue;
          case 12:
           var fmtty$13=fmtty$0[1];
           buffer_add_string(buf,_ay_);
           var fmtty$0=fmtty$13;
           continue;
          case 13:
           var fmtty$14=fmtty$0[1];
           buffer_add_string(buf,_az_);
           var fmtty$0=fmtty$14;
           continue;
          default:
           var fmtty$15=fmtty$0[1];
           buffer_add_string(buf,_aA_);
           var fmtty$0=fmtty$15;
           continue}}
    function symm(param)
     {if(typeof param === "number")
       return 0;
      else
       switch(param[0])
        {case 0:var rest=param[1];return [0,symm(rest)];
         case 1:var rest$0=param[1];return [1,symm(rest$0)];
         case 2:var rest$1=param[1];return [2,symm(rest$1)];
         case 3:var rest$2=param[1];return [3,symm(rest$2)];
         case 4:var rest$3=param[1];return [4,symm(rest$3)];
         case 5:var rest$4=param[1];return [5,symm(rest$4)];
         case 6:var rest$5=param[1];return [6,symm(rest$5)];
         case 7:var rest$6=param[1];return [7,symm(rest$6)];
         case 8:var rest$7=param[2],ty=param[1];return [8,ty,symm(rest$7)];
         case 9:
          var rest$8=param[3],ty2=param[2],ty1=param[1];
          return [9,ty2,ty1,symm(rest$8)];
         case 10:var rest$9=param[1];return [10,symm(rest$9)];
         case 11:var rest$10=param[1];return [11,symm(rest$10)];
         case 12:var rest$11=param[1];return [12,symm(rest$11)];
         case 13:var rest$12=param[1];return [13,symm(rest$12)];
         default:var rest$13=param[1];return [14,symm(rest$13)]}}
    function fmtty_rel_det(param)
     {if(typeof param === "number")
       {var
         _ZR_=function(param){return 0},
         _ZS_=function(param){return 0},
         _ZT_=function(param){return 0};
        return [0,function(param){return 0},_ZT_,_ZS_,_ZR_]}
      else
       switch(param[0])
        {case 0:
          var
           rest=param[1],
           match=fmtty_rel_det(rest),
           de=match[4],
           ed=match[3],
           af=match[2],
           fa=match[1],
           _ZU_=function(param){caml_call1(af,0);return 0};
          return [0,function(param){caml_call1(fa,0);return 0},_ZU_,ed,de];
         case 1:
          var
           rest$0=param[1],
           match$0=fmtty_rel_det(rest$0),
           de$0=match$0[4],
           ed$0=match$0[3],
           af$0=match$0[2],
           fa$0=match$0[1],
           _ZV_=function(param){caml_call1(af$0,0);return 0};
          return [0,
                  function(param){caml_call1(fa$0,0);return 0},
                  _ZV_,
                  ed$0,
                  de$0];
         case 2:
          var
           rest$1=param[1],
           match$1=fmtty_rel_det(rest$1),
           de$1=match$1[4],
           ed$1=match$1[3],
           af$1=match$1[2],
           fa$1=match$1[1],
           _ZW_=function(param){caml_call1(af$1,0);return 0};
          return [0,
                  function(param){caml_call1(fa$1,0);return 0},
                  _ZW_,
                  ed$1,
                  de$1];
         case 3:
          var
           rest$2=param[1],
           match$2=fmtty_rel_det(rest$2),
           de$2=match$2[4],
           ed$2=match$2[3],
           af$2=match$2[2],
           fa$2=match$2[1],
           _ZX_=function(param){caml_call1(af$2,0);return 0};
          return [0,
                  function(param){caml_call1(fa$2,0);return 0},
                  _ZX_,
                  ed$2,
                  de$2];
         case 4:
          var
           rest$3=param[1],
           match$3=fmtty_rel_det(rest$3),
           de$3=match$3[4],
           ed$3=match$3[3],
           af$3=match$3[2],
           fa$3=match$3[1],
           _ZY_=function(param){caml_call1(af$3,0);return 0};
          return [0,
                  function(param){caml_call1(fa$3,0);return 0},
                  _ZY_,
                  ed$3,
                  de$3];
         case 5:
          var
           rest$4=param[1],
           match$4=fmtty_rel_det(rest$4),
           de$4=match$4[4],
           ed$4=match$4[3],
           af$4=match$4[2],
           fa$4=match$4[1],
           _ZZ_=function(param){caml_call1(af$4,0);return 0};
          return [0,
                  function(param){caml_call1(fa$4,0);return 0},
                  _ZZ_,
                  ed$4,
                  de$4];
         case 6:
          var
           rest$5=param[1],
           match$5=fmtty_rel_det(rest$5),
           de$5=match$5[4],
           ed$5=match$5[3],
           af$5=match$5[2],
           fa$5=match$5[1],
           _Z0_=function(param){caml_call1(af$5,0);return 0};
          return [0,
                  function(param){caml_call1(fa$5,0);return 0},
                  _Z0_,
                  ed$5,
                  de$5];
         case 7:
          var
           rest$6=param[1],
           match$6=fmtty_rel_det(rest$6),
           de$6=match$6[4],
           ed$6=match$6[3],
           af$6=match$6[2],
           fa$6=match$6[1],
           _Z1_=function(param){caml_call1(af$6,0);return 0};
          return [0,
                  function(param){caml_call1(fa$6,0);return 0},
                  _Z1_,
                  ed$6,
                  de$6];
         case 8:
          var
           rest$7=param[2],
           match$7=fmtty_rel_det(rest$7),
           de$7=match$7[4],
           ed$7=match$7[3],
           af$7=match$7[2],
           fa$7=match$7[1],
           _Z2_=function(param){caml_call1(af$7,0);return 0};
          return [0,
                  function(param){caml_call1(fa$7,0);return 0},
                  _Z2_,
                  ed$7,
                  de$7];
         case 9:
          var
           rest$8=param[3],
           ty2=param[2],
           ty1=param[1],
           match$8=fmtty_rel_det(rest$8),
           de$8=match$8[4],
           ed$8=match$8[3],
           af$8=match$8[2],
           fa$8=match$8[1],
           ty=trans(symm(ty1),ty2),
           match$9=fmtty_rel_det(ty),
           jd=match$9[4],
           dj=match$9[3],
           ga=match$9[2],
           ag=match$9[1],
           _Z3_=function(param){caml_call1(jd,0);caml_call1(de$8,0);return 0},
           _Z4_=function(param){caml_call1(ed$8,0);caml_call1(dj,0);return 0},
           _Z5_=function(param){caml_call1(ga,0);caml_call1(af$8,0);return 0};
          return [0,
                  function(param)
                   {caml_call1(fa$8,0);caml_call1(ag,0);return 0},
                  _Z5_,
                  _Z4_,
                  _Z3_];
         case 10:
          var
           rest$9=param[1],
           match$10=fmtty_rel_det(rest$9),
           de$9=match$10[4],
           ed$9=match$10[3],
           af$9=match$10[2],
           fa$9=match$10[1],
           _Z6_=function(param){caml_call1(af$9,0);return 0};
          return [0,
                  function(param){caml_call1(fa$9,0);return 0},
                  _Z6_,
                  ed$9,
                  de$9];
         case 11:
          var
           rest$10=param[1],
           match$11=fmtty_rel_det(rest$10),
           de$10=match$11[4],
           ed$10=match$11[3],
           af$10=match$11[2],
           fa$10=match$11[1],
           _Z7_=function(param){caml_call1(af$10,0);return 0};
          return [0,
                  function(param){caml_call1(fa$10,0);return 0},
                  _Z7_,
                  ed$10,
                  de$10];
         case 12:
          var
           rest$11=param[1],
           match$12=fmtty_rel_det(rest$11),
           de$11=match$12[4],
           ed$11=match$12[3],
           af$11=match$12[2],
           fa$11=match$12[1],
           _Z8_=function(param){caml_call1(af$11,0);return 0};
          return [0,
                  function(param){caml_call1(fa$11,0);return 0},
                  _Z8_,
                  ed$11,
                  de$11];
         case 13:
          var
           rest$12=param[1],
           match$13=fmtty_rel_det(rest$12),
           de$12=match$13[4],
           ed$12=match$13[3],
           af$12=match$13[2],
           fa$12=match$13[1],
           _Z9_=function(param){caml_call1(de$12,0);return 0},
           _Z__=function(param){caml_call1(ed$12,0);return 0},
           _Z$_=function(param){caml_call1(af$12,0);return 0};
          return [0,
                  function(param){caml_call1(fa$12,0);return 0},
                  _Z$_,
                  _Z__,
                  _Z9_];
         default:
          var
           rest$13=param[1],
           match$14=fmtty_rel_det(rest$13),
           de$13=match$14[4],
           ed$13=match$14[3],
           af$13=match$14[2],
           fa$13=match$14[1],
           __a_=function(param){caml_call1(de$13,0);return 0},
           __b_=function(param){caml_call1(ed$13,0);return 0},
           __c_=function(param){caml_call1(af$13,0);return 0};
          return [0,
                  function(param){caml_call1(fa$13,0);return 0},
                  __c_,
                  __b_,
                  __a_]}}
    function trans(ty1,match)
     {var switch$0=0;
      if(typeof ty1 === "number")
       if(typeof match === "number")
        return 0;
       else
        switch(match[0])
         {case 10:break;
          case 11:switch$0 = 1;break;
          case 12:switch$0 = 2;break;
          case 13:switch$0 = 3;break;
          case 14:switch$0 = 4;break;
          case 8:switch$0 = 5;break;
          case 9:switch$0 = 6;break;
          default:throw [0,Assert_failure,_aB_]}
      else
       switch(ty1[0])
        {case 0:
          var switch$1=0,_Zy_=ty1[1];
          if(typeof match !== "number")
           switch(match[0])
            {case 0:var rest2=match[1];return [0,trans(_Zy_,rest2)];
             case 8:switch$0 = 5;switch$1 = 1;break;
             case 9:switch$0 = 6;switch$1 = 1;break;
             case 10:switch$1 = 1;break;
             case 11:switch$0 = 1;switch$1 = 1;break;
             case 12:switch$0 = 2;switch$1 = 1;break;
             case 13:switch$0 = 3;switch$1 = 1;break;
             case 14:switch$0 = 4;switch$1 = 1;break
             }
          if(! switch$1)switch$0 = 7;
          break;
         case 1:
          var switch$2=0,_Zz_=ty1[1];
          if(typeof match !== "number")
           switch(match[0])
            {case 1:var rest2$0=match[1];return [1,trans(_Zz_,rest2$0)];
             case 8:switch$0 = 5;switch$2 = 1;break;
             case 9:switch$0 = 6;switch$2 = 1;break;
             case 10:switch$2 = 1;break;
             case 11:switch$0 = 1;switch$2 = 1;break;
             case 12:switch$0 = 2;switch$2 = 1;break;
             case 13:switch$0 = 3;switch$2 = 1;break;
             case 14:switch$0 = 4;switch$2 = 1;break
             }
          if(! switch$2)switch$0 = 7;
          break;
         case 2:
          var switch$3=0,_ZA_=ty1[1];
          if(typeof match === "number")
           switch$3 = 1;
          else
           switch(match[0])
            {case 2:var rest2$1=match[1];return [2,trans(_ZA_,rest2$1)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$3 = 1}
          if(switch$3)switch$0 = 7;
          break;
         case 3:
          var switch$4=0,_ZB_=ty1[1];
          if(typeof match === "number")
           switch$4 = 1;
          else
           switch(match[0])
            {case 3:var rest2$2=match[1];return [3,trans(_ZB_,rest2$2)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$4 = 1}
          if(switch$4)switch$0 = 7;
          break;
         case 4:
          var switch$5=0,_ZC_=ty1[1];
          if(typeof match === "number")
           switch$5 = 1;
          else
           switch(match[0])
            {case 4:var rest2$3=match[1];return [4,trans(_ZC_,rest2$3)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$5 = 1}
          if(switch$5)switch$0 = 7;
          break;
         case 5:
          var switch$6=0,_ZD_=ty1[1];
          if(typeof match === "number")
           switch$6 = 1;
          else
           switch(match[0])
            {case 5:var rest2$4=match[1];return [5,trans(_ZD_,rest2$4)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$6 = 1}
          if(switch$6)switch$0 = 7;
          break;
         case 6:
          var switch$7=0,_ZE_=ty1[1];
          if(typeof match === "number")
           switch$7 = 1;
          else
           switch(match[0])
            {case 6:var rest2$5=match[1];return [6,trans(_ZE_,rest2$5)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$7 = 1}
          if(switch$7)switch$0 = 7;
          break;
         case 7:
          var switch$8=0,_ZF_=ty1[1];
          if(typeof match === "number")
           switch$8 = 1;
          else
           switch(match[0])
            {case 7:var rest2$6=match[1];return [7,trans(_ZF_,rest2$6)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$8 = 1}
          if(switch$8)switch$0 = 7;
          break;
         case 8:
          var switch$9=0,_ZG_=ty1[2],_ZH_=ty1[1];
          if(typeof match === "number")
           switch$9 = 1;
          else
           switch(match[0])
            {case 8:
              var rest2$7=match[2],ty2=match[1],_ZI_=trans(_ZG_,rest2$7);
              return [8,trans(_ZH_,ty2),_ZI_];
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$9 = 1}
          if(switch$9)throw [0,Assert_failure,_aK_];
          break;
         case 9:
          var switch$10=0,_ZJ_=ty1[3],_ZK_=ty1[2],_ZL_=ty1[1];
          if(typeof match === "number")
           switch$10 = 1;
          else
           switch(match[0])
            {case 8:switch$0 = 5;break;
             case 9:
              var
               rest2$8=match[3],
               ty22=match[2],
               ty21=match[1],
               ty=trans(symm(_ZK_),ty21),
               match$0=fmtty_rel_det(ty),
               f4=match$0[4],
               f2=match$0[2];
              caml_call1(f2,0);
              caml_call1(f4,0);
              return [9,_ZL_,ty22,trans(_ZJ_,rest2$8)];
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$10 = 1}
          if(switch$10)throw [0,Assert_failure,_aL_];
          break;
         case 10:
          var _ZM_=ty1[1];
          if(typeof match !== "number" && 10 === match[0])
           {var rest2$9=match[1];return [10,trans(_ZM_,rest2$9)]}
          throw [0,Assert_failure,_aM_];
         case 11:
          var switch$11=0,_ZN_=ty1[1];
          if(typeof match === "number")
           switch$11 = 1;
          else
           switch(match[0])
            {case 10:break;
             case 11:var rest2$10=match[1];return [11,trans(_ZN_,rest2$10)];
             default:switch$11 = 1}
          if(switch$11)throw [0,Assert_failure,_aN_];
          break;
         case 12:
          var switch$12=0,_ZO_=ty1[1];
          if(typeof match === "number")
           switch$12 = 1;
          else
           switch(match[0])
            {case 10:break;
             case 11:switch$0 = 1;break;
             case 12:var rest2$11=match[1];return [12,trans(_ZO_,rest2$11)];
             default:switch$12 = 1}
          if(switch$12)throw [0,Assert_failure,_aO_];
          break;
         case 13:
          var switch$13=0,_ZP_=ty1[1];
          if(typeof match === "number")
           switch$13 = 1;
          else
           switch(match[0])
            {case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:var rest2$12=match[1];return [13,trans(_ZP_,rest2$12)];
             default:switch$13 = 1}
          if(switch$13)throw [0,Assert_failure,_aP_];
          break;
         default:
          var switch$14=0,_ZQ_=ty1[1];
          if(typeof match === "number")
           switch$14 = 1;
          else
           switch(match[0])
            {case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:var rest2$13=match[1];return [14,trans(_ZQ_,rest2$13)];
             default:switch$14 = 1}
          if(switch$14)throw [0,Assert_failure,_aQ_]}
      switch(switch$0)
       {case 0:throw [0,Assert_failure,_aE_];
        case 1:throw [0,Assert_failure,_aF_];
        case 2:throw [0,Assert_failure,_aG_];
        case 3:throw [0,Assert_failure,_aH_];
        case 4:throw [0,Assert_failure,_aI_];
        case 5:throw [0,Assert_failure,_aC_];
        case 6:throw [0,Assert_failure,_aD_];
        default:throw [0,Assert_failure,_aJ_]}}
    var Type_mismatch=[248,_aR_,caml_fresh_oo_id(0)];
    function type_padding(pad,match)
     {if(typeof pad === "number")
       return [0,0,match];
      else
       {if(0 === pad[0])
         {var w=pad[2],padty=pad[1];return [0,[0,padty,w],match]}
        if(typeof match !== "number" && 2 === match[0])
         {var rest=match[1],padty$0=pad[1];return [0,[1,padty$0],rest]}
        throw Type_mismatch}}
    function type_padprec(pad,prec,fmtty)
     {var match=type_padding(pad,fmtty);
      if(typeof prec === "number")
       {if(0 === prec)
         {var rest=match[2],pad$0=match[1];return [0,pad$0,0,rest]}
        var _Zx_=match[2];
        if(typeof _Zx_ !== "number" && 2 === _Zx_[0])
         {var rest$0=_Zx_[1],pad$1=match[1];return [0,pad$1,1,rest$0]}
        throw Type_mismatch}
      var rest$1=match[2],pad$2=match[1],p=prec[1];
      return [0,pad$2,[0,p],rest$1]}
    function type_ignored_format_substituti(sub_fmtty,fmt,match)
     {if(typeof sub_fmtty === "number")
       return [0,0,type_format_gen(fmt,match)];
      else
       switch(sub_fmtty[0])
        {case 0:
          if(typeof match !== "number" && 0 === match[0])
           {var
             fmtty_rest=match[1],
             sub_fmtty_rest=sub_fmtty[1],
             match$0=
              type_ignored_format_substituti(sub_fmtty_rest,fmt,fmtty_rest),
             fmt$0=match$0[2],
             sub_fmtty_rest$0=match$0[1];
            return [0,[0,sub_fmtty_rest$0],fmt$0]}
          break;
         case 1:
          if(typeof match !== "number" && 1 === match[0])
           {var
             fmtty_rest$0=match[1],
             sub_fmtty_rest$1=sub_fmtty[1],
             match$1=
              type_ignored_format_substituti
               (sub_fmtty_rest$1,fmt,fmtty_rest$0),
             fmt$1=match$1[2],
             sub_fmtty_rest$2=match$1[1];
            return [0,[1,sub_fmtty_rest$2],fmt$1]}
          break;
         case 2:
          if(typeof match !== "number" && 2 === match[0])
           {var
             fmtty_rest$1=match[1],
             sub_fmtty_rest$3=sub_fmtty[1],
             match$2=
              type_ignored_format_substituti
               (sub_fmtty_rest$3,fmt,fmtty_rest$1),
             fmt$2=match$2[2],
             sub_fmtty_rest$4=match$2[1];
            return [0,[2,sub_fmtty_rest$4],fmt$2]}
          break;
         case 3:
          if(typeof match !== "number" && 3 === match[0])
           {var
             fmtty_rest$2=match[1],
             sub_fmtty_rest$5=sub_fmtty[1],
             match$3=
              type_ignored_format_substituti
               (sub_fmtty_rest$5,fmt,fmtty_rest$2),
             fmt$3=match$3[2],
             sub_fmtty_rest$6=match$3[1];
            return [0,[3,sub_fmtty_rest$6],fmt$3]}
          break;
         case 4:
          if(typeof match !== "number" && 4 === match[0])
           {var
             fmtty_rest$3=match[1],
             sub_fmtty_rest$7=sub_fmtty[1],
             match$4=
              type_ignored_format_substituti
               (sub_fmtty_rest$7,fmt,fmtty_rest$3),
             fmt$4=match$4[2],
             sub_fmtty_rest$8=match$4[1];
            return [0,[4,sub_fmtty_rest$8],fmt$4]}
          break;
         case 5:
          if(typeof match !== "number" && 5 === match[0])
           {var
             fmtty_rest$4=match[1],
             sub_fmtty_rest$9=sub_fmtty[1],
             match$5=
              type_ignored_format_substituti
               (sub_fmtty_rest$9,fmt,fmtty_rest$4),
             fmt$5=match$5[2],
             sub_fmtty_rest$10=match$5[1];
            return [0,[5,sub_fmtty_rest$10],fmt$5]}
          break;
         case 6:
          if(typeof match !== "number" && 6 === match[0])
           {var
             fmtty_rest$5=match[1],
             sub_fmtty_rest$11=sub_fmtty[1],
             match$6=
              type_ignored_format_substituti
               (sub_fmtty_rest$11,fmt,fmtty_rest$5),
             fmt$6=match$6[2],
             sub_fmtty_rest$12=match$6[1];
            return [0,[6,sub_fmtty_rest$12],fmt$6]}
          break;
         case 7:
          if(typeof match !== "number" && 7 === match[0])
           {var
             fmtty_rest$6=match[1],
             sub_fmtty_rest$13=sub_fmtty[1],
             match$7=
              type_ignored_format_substituti
               (sub_fmtty_rest$13,fmt,fmtty_rest$6),
             fmt$7=match$7[2],
             sub_fmtty_rest$14=match$7[1];
            return [0,[7,sub_fmtty_rest$14],fmt$7]}
          break;
         case 8:
          if(typeof match !== "number" && 8 === match[0])
           {var
             fmtty_rest$7=match[2],
             sub2_fmtty=match[1],
             sub_fmtty_rest$15=sub_fmtty[2],
             sub2_fmtty$0=sub_fmtty[1];
            if(caml_notequal([0,sub2_fmtty$0],[0,sub2_fmtty]))
             throw Type_mismatch;
            var
             match$8=
              type_ignored_format_substituti
               (sub_fmtty_rest$15,fmt,fmtty_rest$7),
             fmt$8=match$8[2],
             sub_fmtty_rest$16=match$8[1];
            return [0,[8,sub2_fmtty,sub_fmtty_rest$16],fmt$8]}
          break;
         case 9:
          if(typeof match !== "number" && 9 === match[0])
           {var
             fmtty_rest$8=match[3],
             sub2_fmtty$1=match[2],
             sub1_fmtty=match[1],
             sub_fmtty_rest$17=sub_fmtty[3],
             sub2_fmtty$2=sub_fmtty[2],
             sub1_fmtty$0=sub_fmtty[1],
             _Zv_=[0,erase_rel(sub1_fmtty)];
            if(caml_notequal([0,erase_rel(sub1_fmtty$0)],_Zv_))
             throw Type_mismatch;
            var _Zw_=[0,erase_rel(sub2_fmtty$1)];
            if(caml_notequal([0,erase_rel(sub2_fmtty$2)],_Zw_))
             throw Type_mismatch;
            var
             sub_fmtty$0=trans(symm(sub1_fmtty),sub2_fmtty$1),
             match$9=fmtty_rel_det(sub_fmtty$0),
             f4=match$9[4],
             f2=match$9[2];
            caml_call1(f2,0);
            caml_call1(f4,0);
            var
             match$10=
              type_ignored_format_substituti
               (erase_rel(sub_fmtty_rest$17),fmt,fmtty_rest$8),
             fmt$9=match$10[2],
             sub_fmtty_rest$18=match$10[1];
            return [0,
                    [9,sub1_fmtty,sub2_fmtty$1,symm(sub_fmtty_rest$18)],
                    fmt$9]}
          break;
         case 10:
          if(typeof match !== "number" && 10 === match[0])
           {var
             fmtty_rest$9=match[1],
             sub_fmtty_rest$19=sub_fmtty[1],
             match$11=
              type_ignored_format_substituti
               (sub_fmtty_rest$19,fmt,fmtty_rest$9),
             fmt$10=match$11[2],
             sub_fmtty_rest$20=match$11[1];
            return [0,[10,sub_fmtty_rest$20],fmt$10]}
          break;
         case 11:
          if(typeof match !== "number" && 11 === match[0])
           {var
             fmtty_rest$10=match[1],
             sub_fmtty_rest$21=sub_fmtty[1],
             match$12=
              type_ignored_format_substituti
               (sub_fmtty_rest$21,fmt,fmtty_rest$10),
             fmt$11=match$12[2],
             sub_fmtty_rest$22=match$12[1];
            return [0,[11,sub_fmtty_rest$22],fmt$11]}
          break;
         case 13:
          if(typeof match !== "number" && 13 === match[0])
           {var
             fmtty_rest$11=match[1],
             sub_fmtty_rest$23=sub_fmtty[1],
             match$13=
              type_ignored_format_substituti
               (sub_fmtty_rest$23,fmt,fmtty_rest$11),
             fmt$12=match$13[2],
             sub_fmtty_rest$24=match$13[1];
            return [0,[13,sub_fmtty_rest$24],fmt$12]}
          break;
         case 14:
          if(typeof match !== "number" && 14 === match[0])
           {var
             fmtty_rest$12=match[1],
             sub_fmtty_rest$25=sub_fmtty[1],
             match$14=
              type_ignored_format_substituti
               (sub_fmtty_rest$25,fmt,fmtty_rest$12),
             fmt$13=match$14[2],
             sub_fmtty_rest$26=match$14[1];
            return [0,[14,sub_fmtty_rest$26],fmt$13]}
          break
         }
      throw Type_mismatch}
    function type_format_gen(fmt,fmtty)
     {if(typeof fmt === "number")
       return [0,0,fmtty];
      else
       switch(fmt[0])
        {case 0:
          if(typeof fmtty !== "number" && 0 === fmtty[0])
           {var
             fmtty_rest=fmtty[1],
             fmt_rest=fmt[1],
             match=type_format_gen(fmt_rest,fmtty_rest),
             fmtty$0=match[2],
             fmt$0=match[1];
            return [0,[0,fmt$0],fmtty$0]}
          break;
         case 1:
          if(typeof fmtty !== "number" && 0 === fmtty[0])
           {var
             fmtty_rest$0=fmtty[1],
             fmt_rest$0=fmt[1],
             match$0=type_format_gen(fmt_rest$0,fmtty_rest$0),
             fmtty$1=match$0[2],
             fmt$1=match$0[1];
            return [0,[1,fmt$1],fmtty$1]}
          break;
         case 2:
          var
           fmt_rest$1=fmt[2],
           pad=fmt[1],
           _Y2_=type_padding(pad,fmtty),
           _Y3_=_Y2_[2],
           _Y4_=_Y2_[1];
          if(typeof _Y3_ !== "number" && 1 === _Y3_[0])
           {var
             fmtty_rest$1=_Y3_[1],
             match$1=type_format_gen(fmt_rest$1,fmtty_rest$1),
             fmtty$2=match$1[2],
             fmt$2=match$1[1];
            return [0,[2,_Y4_,fmt$2],fmtty$2]}
          throw Type_mismatch;
         case 3:
          var
           fmt_rest$2=fmt[2],
           pad$0=fmt[1],
           _Y5_=type_padding(pad$0,fmtty),
           _Y6_=_Y5_[2],
           _Y7_=_Y5_[1];
          if(typeof _Y6_ !== "number" && 1 === _Y6_[0])
           {var
             fmtty_rest$2=_Y6_[1],
             match$2=type_format_gen(fmt_rest$2,fmtty_rest$2),
             fmtty$3=match$2[2],
             fmt$3=match$2[1];
            return [0,[3,_Y7_,fmt$3],fmtty$3]}
          throw Type_mismatch;
         case 4:
          var
           fmt_rest$3=fmt[4],
           prec=fmt[3],
           pad$1=fmt[2],
           iconv=fmt[1],
           _Y8_=type_padprec(pad$1,prec,fmtty),
           _Y9_=_Y8_[3],
           _Y__=_Y8_[2],
           _Y$_=_Y8_[1];
          if(typeof _Y9_ !== "number" && 2 === _Y9_[0])
           {var
             fmtty_rest$3=_Y9_[1],
             match$3=type_format_gen(fmt_rest$3,fmtty_rest$3),
             fmtty$4=match$3[2],
             fmt$4=match$3[1];
            return [0,[4,iconv,_Y$_,_Y__,fmt$4],fmtty$4]}
          throw Type_mismatch;
         case 5:
          var
           fmt_rest$4=fmt[4],
           prec$0=fmt[3],
           pad$2=fmt[2],
           iconv$0=fmt[1],
           _Za_=type_padprec(pad$2,prec$0,fmtty),
           _Zb_=_Za_[3],
           _Zc_=_Za_[2],
           _Zd_=_Za_[1];
          if(typeof _Zb_ !== "number" && 3 === _Zb_[0])
           {var
             fmtty_rest$4=_Zb_[1],
             match$4=type_format_gen(fmt_rest$4,fmtty_rest$4),
             fmtty$5=match$4[2],
             fmt$5=match$4[1];
            return [0,[5,iconv$0,_Zd_,_Zc_,fmt$5],fmtty$5]}
          throw Type_mismatch;
         case 6:
          var
           fmt_rest$5=fmt[4],
           prec$1=fmt[3],
           pad$3=fmt[2],
           iconv$1=fmt[1],
           _Ze_=type_padprec(pad$3,prec$1,fmtty),
           _Zf_=_Ze_[3],
           _Zg_=_Ze_[2],
           _Zh_=_Ze_[1];
          if(typeof _Zf_ !== "number" && 4 === _Zf_[0])
           {var
             fmtty_rest$5=_Zf_[1],
             match$5=type_format_gen(fmt_rest$5,fmtty_rest$5),
             fmtty$6=match$5[2],
             fmt$6=match$5[1];
            return [0,[6,iconv$1,_Zh_,_Zg_,fmt$6],fmtty$6]}
          throw Type_mismatch;
         case 7:
          var
           fmt_rest$6=fmt[4],
           prec$2=fmt[3],
           pad$4=fmt[2],
           iconv$2=fmt[1],
           _Zi_=type_padprec(pad$4,prec$2,fmtty),
           _Zj_=_Zi_[3],
           _Zk_=_Zi_[2],
           _Zl_=_Zi_[1];
          if(typeof _Zj_ !== "number" && 5 === _Zj_[0])
           {var
             fmtty_rest$6=_Zj_[1],
             match$6=type_format_gen(fmt_rest$6,fmtty_rest$6),
             fmtty$7=match$6[2],
             fmt$7=match$6[1];
            return [0,[7,iconv$2,_Zl_,_Zk_,fmt$7],fmtty$7]}
          throw Type_mismatch;
         case 8:
          var
           fmt_rest$7=fmt[4],
           prec$3=fmt[3],
           pad$5=fmt[2],
           fconv=fmt[1],
           _Zm_=type_padprec(pad$5,prec$3,fmtty),
           _Zn_=_Zm_[3],
           _Zo_=_Zm_[2],
           _Zp_=_Zm_[1];
          if(typeof _Zn_ !== "number" && 6 === _Zn_[0])
           {var
             fmtty_rest$7=_Zn_[1],
             match$7=type_format_gen(fmt_rest$7,fmtty_rest$7),
             fmtty$8=match$7[2],
             fmt$8=match$7[1];
            return [0,[8,fconv,_Zp_,_Zo_,fmt$8],fmtty$8]}
          throw Type_mismatch;
         case 9:
          var
           fmt_rest$8=fmt[2],
           pad$6=fmt[1],
           _Zq_=type_padding(pad$6,fmtty),
           _Zr_=_Zq_[2],
           _Zs_=_Zq_[1];
          if(typeof _Zr_ !== "number" && 7 === _Zr_[0])
           {var
             fmtty_rest$8=_Zr_[1],
             match$8=type_format_gen(fmt_rest$8,fmtty_rest$8),
             fmtty$9=match$8[2],
             fmt$9=match$8[1];
            return [0,[9,_Zs_,fmt$9],fmtty$9]}
          throw Type_mismatch;
         case 10:
          var
           fmt_rest$9=fmt[1],
           match$9=type_format_gen(fmt_rest$9,fmtty),
           fmtty$10=match$9[2],
           fmt$10=match$9[1];
          return [0,[10,fmt$10],fmtty$10];
         case 11:
          var
           fmt_rest$10=fmt[2],
           str=fmt[1],
           match$10=type_format_gen(fmt_rest$10,fmtty),
           fmtty$11=match$10[2],
           fmt$11=match$10[1];
          return [0,[11,str,fmt$11],fmtty$11];
         case 12:
          var
           fmt_rest$11=fmt[2],
           chr=fmt[1],
           match$11=type_format_gen(fmt_rest$11,fmtty),
           fmtty$12=match$11[2],
           fmt$12=match$11[1];
          return [0,[12,chr,fmt$12],fmtty$12];
         case 13:
          if(typeof fmtty !== "number" && 8 === fmtty[0])
           {var
             fmtty_rest$9=fmtty[2],
             sub_fmtty=fmtty[1],
             fmt_rest$12=fmt[3],
             sub_fmtty$0=fmt[2],
             pad_opt=fmt[1];
            if(caml_notequal([0,sub_fmtty$0],[0,sub_fmtty]))
             throw Type_mismatch;
            var
             match$12=type_format_gen(fmt_rest$12,fmtty_rest$9),
             fmtty$13=match$12[2],
             fmt$13=match$12[1];
            return [0,[13,pad_opt,sub_fmtty,fmt$13],fmtty$13]}
          break;
         case 14:
          if(typeof fmtty !== "number" && 9 === fmtty[0])
           {var
             fmtty_rest$10=fmtty[3],
             sub_fmtty1=fmtty[1],
             fmt_rest$13=fmt[3],
             sub_fmtty$1=fmt[2],
             pad_opt$0=fmt[1],
             _Zt_=[0,erase_rel(sub_fmtty1)];
            if(caml_notequal([0,erase_rel(sub_fmtty$1)],_Zt_))
             throw Type_mismatch;
            var
             match$13=type_format_gen(fmt_rest$13,erase_rel(fmtty_rest$10)),
             fmtty$14=match$13[2],
             fmt$14=match$13[1];
            return [0,[14,pad_opt$0,sub_fmtty1,fmt$14],fmtty$14]}
          break;
         case 15:
          if(typeof fmtty !== "number" && 10 === fmtty[0])
           {var
             fmtty_rest$11=fmtty[1],
             fmt_rest$14=fmt[1],
             match$14=type_format_gen(fmt_rest$14,fmtty_rest$11),
             fmtty$15=match$14[2],
             fmt$15=match$14[1];
            return [0,[15,fmt$15],fmtty$15]}
          break;
         case 16:
          if(typeof fmtty !== "number" && 11 === fmtty[0])
           {var
             fmtty_rest$12=fmtty[1],
             fmt_rest$15=fmt[1],
             match$15=type_format_gen(fmt_rest$15,fmtty_rest$12),
             fmtty$16=match$15[2],
             fmt$16=match$15[1];
            return [0,[16,fmt$16],fmtty$16]}
          break;
         case 17:
          var
           fmt_rest$16=fmt[2],
           formatting_lit=fmt[1],
           match$16=type_format_gen(fmt_rest$16,fmtty),
           fmtty$17=match$16[2],
           fmt$17=match$16[1];
          return [0,[17,formatting_lit,fmt$17],fmtty$17];
         case 18:
          var fmt_rest$17=fmt[2],formatting_gen=fmt[1];
          if(0 === formatting_gen[0])
           {var
             match$20=formatting_gen[1],
             str$0=match$20[2],
             fmt1=match$20[1],
             match$21=type_format_gen(fmt1,fmtty),
             fmtty2=match$21[2],
             fmt2=match$21[1],
             match$22=type_format_gen(fmt_rest$17,fmtty2),
             fmtty3=match$22[2],
             fmt3=match$22[1];
            return [0,[18,[0,[0,fmt2,str$0]],fmt3],fmtty3]}
          var
           match$23=formatting_gen[1],
           str$1=match$23[2],
           fmt1$0=match$23[1],
           match$24=type_format_gen(fmt1$0,fmtty),
           fmtty2$0=match$24[2],
           fmt2$0=match$24[1],
           match$25=type_format_gen(fmt_rest$17,fmtty2$0),
           fmtty3$0=match$25[2],
           fmt3$0=match$25[1];
          return [0,[18,[1,[0,fmt2$0,str$1]],fmt3$0],fmtty3$0];
         case 19:
          if(typeof fmtty !== "number" && 13 === fmtty[0])
           {var
             fmtty_rest$13=fmtty[1],
             fmt_rest$18=fmt[1],
             match$17=type_format_gen(fmt_rest$18,fmtty_rest$13),
             fmtty$18=match$17[2],
             fmt$18=match$17[1];
            return [0,[19,fmt$18],fmtty$18]}
          break;
         case 20:
          if(typeof fmtty !== "number" && 1 === fmtty[0])
           {var
             fmtty_rest$14=fmtty[1],
             fmt_rest$19=fmt[3],
             char_set=fmt[2],
             width_opt=fmt[1],
             match$18=type_format_gen(fmt_rest$19,fmtty_rest$14),
             fmtty$19=match$18[2],
             fmt$19=match$18[1];
            return [0,[20,width_opt,char_set,fmt$19],fmtty$19]}
          break;
         case 21:
          if(typeof fmtty !== "number" && 2 === fmtty[0])
           {var
             fmtty_rest$15=fmtty[1],
             fmt_rest$20=fmt[2],
             counter=fmt[1],
             match$19=type_format_gen(fmt_rest$20,fmtty_rest$15),
             fmtty$20=match$19[2],
             fmt$20=match$19[1];
            return [0,[21,counter,fmt$20],fmtty$20]}
          break;
         case 23:
          var rest=fmt[2],ign=fmt[1];
          if(typeof ign === "number")
           switch(ign)
            {case 0:return type_ignored_param_one(ign,rest,fmtty);
             case 1:return type_ignored_param_one(ign,rest,fmtty);
             case 2:
              if(typeof fmtty !== "number" && 14 === fmtty[0])
               {var
                 fmtty_rest$16=fmtty[1],
                 match$26=type_format_gen(rest,fmtty_rest$16),
                 fmtty$21=match$26[2],
                 fmt$21=match$26[1];
                return [0,[23,2,fmt$21],fmtty$21]}
              throw Type_mismatch;
             default:return type_ignored_param_one(ign,rest,fmtty)}
          else
           switch(ign[0])
            {case 0:return type_ignored_param_one(ign,rest,fmtty);
             case 1:return type_ignored_param_one(ign,rest,fmtty);
             case 2:return type_ignored_param_one(ign,rest,fmtty);
             case 3:return type_ignored_param_one(ign,rest,fmtty);
             case 4:return type_ignored_param_one(ign,rest,fmtty);
             case 5:return type_ignored_param_one(ign,rest,fmtty);
             case 6:return type_ignored_param_one(ign,rest,fmtty);
             case 7:return type_ignored_param_one(ign,rest,fmtty);
             case 8:
              var sub_fmtty$2=ign[2],pad_opt$1=ign[1];
              return type_ignored_param_one
                      ([8,pad_opt$1,sub_fmtty$2],rest,fmtty);
             case 9:
              var
               sub_fmtty$3=ign[2],
               pad_opt$2=ign[1],
               _Zu_=type_ignored_format_substituti(sub_fmtty$3,rest,fmtty),
               match$27=_Zu_[2],
               fmtty$22=match$27[2],
               fmt$22=match$27[1],
               sub_fmtty$4=_Zu_[1];
              return [0,[23,[9,pad_opt$2,sub_fmtty$4],fmt$22],fmtty$22];
             case 10:return type_ignored_param_one(ign,rest,fmtty);
             default:return type_ignored_param_one(ign,rest,fmtty)}
         }
      throw Type_mismatch}
    function type_ignored_param_one(ign,fmt,fmtty)
     {var match=type_format_gen(fmt,fmtty),fmtty$0=match[2],fmt$0=match[1];
      return [0,[23,ign,fmt$0],fmtty$0]}
    function fix_padding(padty,width,str)
     {var
       len=caml_ml_string_length(str),
       padty$0=0 <= width?padty:0,
       width$0=abs(width);
      if(width$0 <= len)return str;
      var _Y1_=2 === padty$0?48:32,res=make(width$0,_Y1_);
      switch(padty$0)
       {case 0:blit$0(str,0,res,0,len);break;
        case 1:blit$0(str,0,res,width$0 - len | 0,len);break;
        default:
         var switch$0=0;
         if(0 < len)
          {var switch$1=0;
           if
            (43
             !==
             caml_string_get(str,0)
             &&
             45
             !==
             caml_string_get(str,0)
             &&
             32
             !==
             caml_string_get(str,0))
            {switch$0 = 1;switch$1 = 1}
           if(! switch$1)
            {caml_bytes_set(res,0,caml_string_get(str,0));
             blit$0(str,1,res,(width$0 - len | 0) + 1 | 0,len - 1 | 0)}}
         else
          switch$0 = 1;
         if(switch$0)
          {var switch$2=0;
           if(1 < len && 48 === caml_string_get(str,0))
            {var switch$3=0;
             if
              (120
               !==
               caml_string_get(str,1)
               &&
               88
               !==
               caml_string_get(str,1))
              {switch$2 = 1;switch$3 = 1}
             if(! switch$3)
              {caml_bytes_set(res,1,caml_string_get(str,1));
               blit$0(str,2,res,(width$0 - len | 0) + 2 | 0,len - 2 | 0)}}
           else
            switch$2 = 1;
           if(switch$2)blit$0(str,0,res,width$0 - len | 0,len)}}
      return caml_string_of_bytes(res)}
    function fix_int_precision(prec,str)
     {var
       prec$0=abs(prec),
       len=caml_ml_string_length(str),
       c=caml_string_get(str,0),
       switch$0=0;
      if(58 <= c)
       {if(71 <= c)
         {if(! (5 < (c - 97 | 0) >>> 0))switch$0 = 1}
        else
         if(65 <= c)switch$0 = 1}
      else
       {var switch$1=0;
        if(32 !== c)
         if(43 <= c)
          {var switcher=c - 43 | 0;
           switch(switcher)
            {case 5:
              if(len < (prec$0 + 2 | 0) && 1 < len)
               {var switch$2=0;
                if
                 (120
                  ===
                  caml_string_get(str,1)
                  ||
                  88
                  ===
                  caml_string_get(str,1))
                 switch$2 = 1;
                if(switch$2)
                 {var res$1=make(prec$0 + 2 | 0,48);
                  caml_bytes_set(res$1,1,caml_string_get(str,1));
                  blit$0(str,2,res$1,(prec$0 - len | 0) + 4 | 0,len - 2 | 0);
                  return caml_string_of_bytes(res$1)}}
              switch$0 = 1;
              switch$1 = 1;
              break;
             case 0:
             case 2:break;
             case 1:
             case 3:
             case 4:switch$1 = 1;break;
             default:switch$0 = 1;switch$1 = 1}}
         else
          switch$1 = 1;
        if(! switch$1 && len < (prec$0 + 1 | 0))
         {var res$0=make(prec$0 + 1 | 0,48);
          caml_bytes_set(res$0,0,c);
          blit$0(str,1,res$0,(prec$0 - len | 0) + 2 | 0,len - 1 | 0);
          return caml_string_of_bytes(res$0)}}
      if(switch$0 && len < prec$0)
       {var res=make(prec$0,48);
        blit$0(str,0,res,prec$0 - len | 0,len);
        return caml_string_of_bytes(res)}
      return str}
    function string_to_caml_string(str)
     {var
       str$0=escaped(str),
       l=caml_ml_string_length(str$0),
       res=make(l + 2 | 0,34);
      caml_blit_string(str$0,0,res,1,l);
      return caml_string_of_bytes(res)}
    function convert_int(iconv,n)
     {switch(iconv)
       {case 0:var _Y0_=_aS_;break;
        case 1:var _Y0_=_aT_;break;
        case 2:var _Y0_=_aU_;break;
        case 3:var _Y0_=_aV_;break;
        case 4:var _Y0_=_aW_;break;
        case 5:var _Y0_=_aX_;break;
        case 6:var _Y0_=_aY_;break;
        case 7:var _Y0_=_aZ_;break;
        case 8:var _Y0_=_a0_;break;
        case 9:var _Y0_=_a1_;break;
        case 10:var _Y0_=_a2_;break;
        case 11:var _Y0_=_a3_;break;
        default:var _Y0_=_a4_}
      return caml_format_int(_Y0_,n)}
    function convert_int32(iconv,n)
     {switch(iconv)
       {case 0:var _YZ_=_bg_;break;
        case 1:var _YZ_=_bh_;break;
        case 2:var _YZ_=_bi_;break;
        case 3:var _YZ_=_bj_;break;
        case 4:var _YZ_=_bk_;break;
        case 5:var _YZ_=_bl_;break;
        case 6:var _YZ_=_bm_;break;
        case 7:var _YZ_=_bn_;break;
        case 8:var _YZ_=_bo_;break;
        case 9:var _YZ_=_bp_;break;
        case 10:var _YZ_=_bq_;break;
        case 11:var _YZ_=_br_;break;
        default:var _YZ_=_bs_}
      return caml_format_int(_YZ_,n)}
    function convert_nativeint(iconv,n)
     {switch(iconv)
       {case 0:var _YY_=_bt_;break;
        case 1:var _YY_=_bu_;break;
        case 2:var _YY_=_bv_;break;
        case 3:var _YY_=_bw_;break;
        case 4:var _YY_=_bx_;break;
        case 5:var _YY_=_by_;break;
        case 6:var _YY_=_bz_;break;
        case 7:var _YY_=_bA_;break;
        case 8:var _YY_=_bB_;break;
        case 9:var _YY_=_bC_;break;
        case 10:var _YY_=_bD_;break;
        case 11:var _YY_=_bE_;break;
        default:var _YY_=_bF_}
      return caml_format_int(_YY_,n)}
    function convert_int64(iconv,n)
     {switch(iconv)
       {case 0:var _YX_=_a5_;break;
        case 1:var _YX_=_a6_;break;
        case 2:var _YX_=_a7_;break;
        case 3:var _YX_=_a8_;break;
        case 4:var _YX_=_a9_;break;
        case 5:var _YX_=_a__;break;
        case 6:var _YX_=_a$_;break;
        case 7:var _YX_=_ba_;break;
        case 8:var _YX_=_bb_;break;
        case 9:var _YX_=_bc_;break;
        case 10:var _YX_=_bd_;break;
        case 11:var _YX_=_be_;break;
        default:var _YX_=_bf_}
      return caml_int64_format(_YX_,n)}
    function convert_float(fconv,prec$0,x)
     {if(16 <= fconv)
       {var switch$0=0;
        if(17 <= fconv)
         switch(fconv - 17 | 0)
          {case 2:switch$0 = 1;break;
           case 0:
           case 3:var sign=43;break;
           default:var sign=32}
        else
         switch$0 = 1;
        if(switch$0)var sign=45;
        var s$0=caml_hexstring_of_float(x,prec$0,sign);
        if(19 <= fconv)
         {var s=caml_bytes_of_string(s$0);
          return caml_string_of_bytes(map$1(uppercase_ascii,s))}
        return s$0}
      if(15 === fconv)
       var _YU_=_bG_;
      else
       {var prec=abs(prec$0);
        switch(fconv)
         {case 15:var symb=70;break;
          case 0:
          case 1:
          case 2:var symb=102;break;
          case 3:
          case 4:
          case 5:var symb=101;break;
          case 6:
          case 7:
          case 8:var symb=69;break;
          case 9:
          case 10:
          case 11:var symb=103;break;
          case 12:
          case 13:
          case 14:var symb=71;break;
          case 16:
          case 17:
          case 18:var symb=104;break;
          default:var symb=72}
        var buf=buffer_create(16);
        buffer_add_char(buf,37);
        switch(fconv)
         {case 1:
          case 4:
          case 7:
          case 10:
          case 13:
          case 17:
          case 20:buffer_add_char(buf,43);break;
          case 2:
          case 5:
          case 8:
          case 11:
          case 14:
          case 18:
          case 21:buffer_add_char(buf,32);break
          }
        buffer_add_char(buf,46);
        buffer_add_string(buf,caml_string_of_jsbytes("" + prec));
        buffer_add_char(buf,symb);
        var _YU_=buffer_contents(buf)}
      var str=caml_format_float(_YU_,x);
      if(15 === fconv)
       {var len=caml_ml_string_length(str),match$0=caml_classify_float(x);
        if(3 === match$0)return x < 0.?_bH_:_bI_;
        if(4 <= match$0)return _bJ_;
        var i=0;
        for(;;)
         {if(i === len)
           var _YW_=0;
          else
           {var match=caml_string_get(str,i),_YV_=match - 46 | 0,switch$1=0;
            if(23 < _YV_ >>> 0)
             {if(55 === _YV_)switch$1 = 1}
            else
             if(21 < (_YV_ - 1 | 0) >>> 0)switch$1 = 1;
            if(! switch$1){var i$0=i + 1 | 0,i=i$0;continue}
            var _YW_=1}
          return _YW_?str:symbol(str,_bK_)}}
      return str}
    function make_printf$0(counter,k,o,acc,fmt)
     {var k$0=k,acc$0=acc,fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call2(k$0,o,acc$0);
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1];
           return function(c)
            {var new_acc=[5,acc$0,c];return make_printf(k$0,o,new_acc,rest)};
          case 1:
           var rest$0=fmt$0[1];
           return function(c)
            {var switch$0=0;
             if(40 <= c)
              if(92 === c)
               var str=_r_;
              else
               if(127 <= c)switch$0 = 1;else switch$0 = 2;
             else
              if(32 <= c)
               if(39 <= c)var str=_s_;else switch$0 = 2;
              else
               if(14 <= c)
                switch$0 = 1;
               else
                switch(c)
                 {case 8:var str=_t_;break;
                  case 9:var str=_u_;break;
                  case 10:var str=_v_;break;
                  case 13:var str=_w_;break;
                  default:switch$0 = 1}
             switch(switch$0)
              {case 1:
                var s=caml_create_bytes(4);
                caml_bytes_unsafe_set(s,0,92);
                caml_bytes_unsafe_set(s,1,48 + (c / 100 | 0) | 0);
                caml_bytes_unsafe_set(s,2,48 + ((c / 10 | 0) % 10 | 0) | 0);
                caml_bytes_unsafe_set(s,3,48 + (c % 10 | 0) | 0);
                var str=caml_string_of_bytes(s);
                break;
               case 2:
                var s$0=caml_create_bytes(1);
                caml_bytes_unsafe_set(s$0,0,c);
                var str=caml_string_of_bytes(s$0);
                break
               }
             var l=caml_ml_string_length(str),res=make(l + 2 | 0,39);
             caml_blit_string(str,0,res,1,l);
             var new_acc=[4,acc$0,caml_string_of_bytes(res)];
             return make_printf(k$0,o,new_acc,rest$0)};
          case 2:
           var rest$1=fmt$0[2],pad=fmt$0[1];
           return make_padding
                   (k$0,o,acc$0,rest$1,pad,function(str){return str});
          case 3:
           var rest$2=fmt$0[2],pad$0=fmt$0[1];
           return make_padding(k$0,o,acc$0,rest$2,pad$0,string_to_caml_string);
          case 4:
           var rest$3=fmt$0[4],prec=fmt$0[3],pad$1=fmt$0[2],iconv=fmt$0[1];
           return make_int_padding_precision
                   (k$0,o,acc$0,rest$3,pad$1,prec,convert_int,iconv);
          case 5:
           var
            rest$4=fmt$0[4],
            prec$0=fmt$0[3],
            pad$2=fmt$0[2],
            iconv$0=fmt$0[1];
           return make_int_padding_precision
                   (k$0,o,acc$0,rest$4,pad$2,prec$0,convert_int32,iconv$0);
          case 6:
           var
            rest$5=fmt$0[4],
            prec$1=fmt$0[3],
            pad$3=fmt$0[2],
            iconv$1=fmt$0[1];
           return make_int_padding_precision
                   (k$0,o,acc$0,rest$5,pad$3,prec$1,convert_nativeint,iconv$1);
          case 7:
           var
            rest$6=fmt$0[4],
            prec$2=fmt$0[3],
            pad$4=fmt$0[2],
            iconv$2=fmt$0[1];
           return make_int_padding_precision
                   (k$0,o,acc$0,rest$6,pad$4,prec$2,convert_int64,iconv$2);
          case 8:
           var rest$7=fmt$0[4],prec$3=fmt$0[3],pad$5=fmt$0[2],fconv=fmt$0[1];
           if(typeof pad$5 === "number")
            {if(typeof prec$3 === "number")
              return 0 === prec$3
                      ?function(x)
                        {var str=convert_float(fconv,default_float_precision,x);
                         return make_printf(k$0,o,[4,acc$0,str],rest$7)}
                      :function(p,x)
                        {var str=convert_float(fconv,p,x);
                         return make_printf(k$0,o,[4,acc$0,str],rest$7)};
             var p=prec$3[1];
             return function(x)
              {var str=convert_float(fconv,p,x);
               return make_printf(k$0,o,[4,acc$0,str],rest$7)}}
           else
            {if(0 === pad$5[0])
              {var _YQ_=pad$5[2],_YR_=pad$5[1];
               if(typeof prec$3 === "number")
                return 0 === prec$3
                        ?function(x)
                          {var
                            str=convert_float(fconv,default_float_precision,x),
                            str$0=fix_padding(_YR_,_YQ_,str);
                           return make_printf(k$0,o,[4,acc$0,str$0],rest$7)}
                        :function(p,x)
                          {var str=fix_padding(_YR_,_YQ_,convert_float(fconv,p,x));
                           return make_printf(k$0,o,[4,acc$0,str],rest$7)};
               var p$0=prec$3[1];
               return function(x)
                {var str=fix_padding(_YR_,_YQ_,convert_float(fconv,p$0,x));
                 return make_printf(k$0,o,[4,acc$0,str],rest$7)}}
             var _YS_=pad$5[1];
             if(typeof prec$3 === "number")
              return 0 === prec$3
                      ?function(w,x)
                        {var
                          str=convert_float(fconv,default_float_precision,x),
                          str$0=fix_padding(_YS_,w,str);
                         return make_printf(k$0,o,[4,acc$0,str$0],rest$7)}
                      :function(w,p,x)
                        {var str=fix_padding(_YS_,w,convert_float(fconv,p,x));
                         return make_printf(k$0,o,[4,acc$0,str],rest$7)};
             var p$1=prec$3[1];
             return function(w,x)
              {var str=fix_padding(_YS_,w,convert_float(fconv,p$1,x));
               return make_printf(k$0,o,[4,acc$0,str],rest$7)}}
          case 9:
           var rest$8=fmt$0[2],pad$6=fmt$0[1];
           return make_padding(k$0,o,acc$0,rest$8,pad$6,string_of_bool);
          case 10:
           var fmt$1=fmt$0[1],acc$1=[7,acc$0],acc$0=acc$1,fmt$0=fmt$1;
           continue;
          case 11:
           var
            fmt$2=fmt$0[2],
            str=fmt$0[1],
            acc$2=[2,acc$0,str],
            acc$0=acc$2,
            fmt$0=fmt$2;
           continue;
          case 12:
           var
            fmt$3=fmt$0[2],
            chr=fmt$0[1],
            acc$3=[3,acc$0,chr],
            acc$0=acc$3,
            fmt$0=fmt$3;
           continue;
          case 13:
           var rest$9=fmt$0[3],sub_fmtty=fmt$0[2],buf=buffer_create(16);
           bprint_fmtty(buf,sub_fmtty);
           var ty=buffer_contents(buf);
           return function(str)
            {return make_printf(k$0,o,[4,acc$0,ty],rest$9)};
          case 14:
           var rest$10=fmt$0[3],fmtty=fmt$0[2];
           return function(param)
            {var
              fmt$0=param[1],
              fmtty$0=erase_rel(symm(fmtty)),
              _YT_=type_format_gen(fmt$0,fmtty$0);
             if(typeof _YT_[2] === "number")
              {var fmt=_YT_[1];
               return make_printf(k$0,o,acc$0,concat_fmt(fmt,rest$10))}
             throw Type_mismatch};
          case 15:
           var rest$11=fmt$0[1];
           return function(f,x)
            {return make_printf
                     (k$0,
                      o,
                      [6,acc$0,function(o){return caml_call2(f,o,x)}],
                      rest$11)};
          case 16:
           var rest$12=fmt$0[1];
           return function(f){return make_printf(k$0,o,[6,acc$0,f],rest$12)};
          case 17:
           var
            fmt$4=fmt$0[2],
            fmting_lit=fmt$0[1],
            acc$4=[0,acc$0,fmting_lit],
            acc$0=acc$4,
            fmt$0=fmt$4;
           continue;
          case 18:
           var _YO_=fmt$0[1];
           if(0 === _YO_[0])
            {var
              rest$13=fmt$0[2],
              match=_YO_[1],
              fmt$5=match[1],
              k$3=
               function(acc,k,rest)
                {function k$0(koc,kacc)
                  {return make_printf(k,koc,[1,acc,[0,kacc]],rest)}
                 return k$0},
              k$1=k$3(acc$0,k$0,rest$13),
              k$0=k$1,
              acc$0=0,
              fmt$0=fmt$5;
             continue}
           var
            rest$14=fmt$0[2],
            match$0=_YO_[1],
            fmt$6=match$0[1],
            k$4=
             function(acc,k,rest)
              {function k$0(koc,kacc)
                {return make_printf(k,koc,[1,acc,[1,kacc]],rest)}
               return k$0},
            k$2=k$4(acc$0,k$0,rest$14),
            k$0=k$2,
            acc$0=0,
            fmt$0=fmt$6;
           continue;
          case 19:throw [0,Assert_failure,_bL_];
          case 20:
           var rest$15=fmt$0[3],new_acc=[8,acc$0,_bM_];
           return function(param){return make_printf(k$0,o,new_acc,rest$15)};
          case 21:
           var rest$16=fmt$0[2];
           return function(n)
            {var new_acc=[4,acc$0,caml_format_int(_bN_,n)];
             return make_printf(k$0,o,new_acc,rest$16)};
          case 22:
           var rest$17=fmt$0[1];
           return function(c)
            {var new_acc=[5,acc$0,c];
             return make_printf(k$0,o,new_acc,rest$17)};
          case 23:
           var rest$18=fmt$0[2],ign=fmt$0[1];
           if(typeof ign === "number")
            switch(ign)
             {case 0:
               if(counter < 50)
                {var counter$1=counter + 1 | 0;
                 return make_invalid_arg(counter$1,k$0,o,acc$0,rest$18)}
               return caml_trampoline_return
                       (make_invalid_arg,[0,k$0,o,acc$0,rest$18]);
              case 1:
               if(counter < 50)
                {var counter$2=counter + 1 | 0;
                 return make_invalid_arg(counter$2,k$0,o,acc$0,rest$18)}
               return caml_trampoline_return
                       (make_invalid_arg,[0,k$0,o,acc$0,rest$18]);
              case 2:throw [0,Assert_failure,_bO_];
              default:
               if(counter < 50)
                {var counter$3=counter + 1 | 0;
                 return make_invalid_arg(counter$3,k$0,o,acc$0,rest$18)}
               return caml_trampoline_return
                       (make_invalid_arg,[0,k$0,o,acc$0,rest$18])}
           else
            switch(ign[0])
             {case 0:
               if(counter < 50)
                {var counter$4=counter + 1 | 0;
                 return make_invalid_arg(counter$4,k$0,o,acc$0,rest$18)}
               return caml_trampoline_return
                       (make_invalid_arg,[0,k$0,o,acc$0,rest$18]);
              case 1:
               if(counter < 50)
                {var counter$5=counter + 1 | 0;
                 return make_invalid_arg(counter$5,k$0,o,acc$0,rest$18)}
               return caml_trampoline_return
                       (make_invalid_arg,[0,k$0,o,acc$0,rest$18]);
              case 2:
               if(counter < 50)
                {var counter$6=counter + 1 | 0;
                 return make_invalid_arg(counter$6,k$0,o,acc$0,rest$18)}
               return caml_trampoline_return
                       (make_invalid_arg,[0,k$0,o,acc$0,rest$18]);
              case 3:
               if(counter < 50)
                {var counter$7=counter + 1 | 0;
                 return make_invalid_arg(counter$7,k$0,o,acc$0,rest$18)}
               return caml_trampoline_return
                       (make_invalid_arg,[0,k$0,o,acc$0,rest$18]);
              case 4:
               if(counter < 50)
                {var counter$8=counter + 1 | 0;
                 return make_invalid_arg(counter$8,k$0,o,acc$0,rest$18)}
               return caml_trampoline_return
                       (make_invalid_arg,[0,k$0,o,acc$0,rest$18]);
              case 5:
               if(counter < 50)
                {var counter$9=counter + 1 | 0;
                 return make_invalid_arg(counter$9,k$0,o,acc$0,rest$18)}
               return caml_trampoline_return
                       (make_invalid_arg,[0,k$0,o,acc$0,rest$18]);
              case 6:
               if(counter < 50)
                {var counter$10=counter + 1 | 0;
                 return make_invalid_arg(counter$10,k$0,o,acc$0,rest$18)}
               return caml_trampoline_return
                       (make_invalid_arg,[0,k$0,o,acc$0,rest$18]);
              case 7:
               if(counter < 50)
                {var counter$11=counter + 1 | 0;
                 return make_invalid_arg(counter$11,k$0,o,acc$0,rest$18)}
               return caml_trampoline_return
                       (make_invalid_arg,[0,k$0,o,acc$0,rest$18]);
              case 8:
               if(counter < 50)
                {var counter$12=counter + 1 | 0;
                 return make_invalid_arg(counter$12,k$0,o,acc$0,rest$18)}
               return caml_trampoline_return
                       (make_invalid_arg,[0,k$0,o,acc$0,rest$18]);
              case 9:
               var fmtty$0=ign[2];
               if(counter < 50)
                {var counter$15=counter + 1 | 0;
                 return make_from_fmtty$0
                         (counter$15,k$0,o,acc$0,fmtty$0,rest$18)}
               return caml_trampoline_return
                       (make_from_fmtty$0,[0,k$0,o,acc$0,fmtty$0,rest$18]);
              case 10:
               if(counter < 50)
                {var counter$13=counter + 1 | 0;
                 return make_invalid_arg(counter$13,k$0,o,acc$0,rest$18)}
               return caml_trampoline_return
                       (make_invalid_arg,[0,k$0,o,acc$0,rest$18]);
              default:
               if(counter < 50)
                {var counter$14=counter + 1 | 0;
                 return make_invalid_arg(counter$14,k$0,o,acc$0,rest$18)}
               return caml_trampoline_return
                       (make_invalid_arg,[0,k$0,o,acc$0,rest$18])}
          default:
           var
            rest$19=fmt$0[3],
            f=fmt$0[2],
            arity=fmt$0[1],
            _YP_=caml_call1(f,0);
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return make_custom$0(counter$0,k$0,o,acc$0,rest$19,arity,_YP_)}
           return caml_trampoline_return
                   (make_custom$0,[0,k$0,o,acc$0,rest$19,arity,_YP_])}}
    function make_from_fmtty$0(counter,k,o,acc,fmtty,fmt)
     {if(typeof fmtty === "number")
       {if(counter < 50)
         {var counter$0=counter + 1 | 0;
          return make_invalid_arg(counter$0,k,o,acc,fmt)}
        return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt])}
      else
       switch(fmtty[0])
        {case 0:
          var rest=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest,fmt)};
         case 1:
          var rest$0=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$0,fmt)};
         case 2:
          var rest$1=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$1,fmt)};
         case 3:
          var rest$2=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$2,fmt)};
         case 4:
          var rest$3=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$3,fmt)};
         case 5:
          var rest$4=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$4,fmt)};
         case 6:
          var rest$5=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$5,fmt)};
         case 7:
          var rest$6=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$6,fmt)};
         case 8:
          var rest$7=fmtty[2];
          return function(param){return make_from_fmtty(k,o,acc,rest$7,fmt)};
         case 9:
          var
           rest$8=fmtty[3],
           ty2=fmtty[2],
           ty1=fmtty[1],
           ty=trans(symm(ty1),ty2);
          return function(param)
           {return make_from_fmtty(k,o,acc,concat_fmtty(ty,rest$8),fmt)};
         case 10:
          var rest$9=fmtty[1];
          return function(param,_YN_)
           {return make_from_fmtty(k,o,acc,rest$9,fmt)};
         case 11:
          var rest$10=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$10,fmt)};
         case 12:
          var rest$11=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$11,fmt)};
         case 13:throw [0,Assert_failure,_bP_];
         default:throw [0,Assert_failure,_bQ_]}}
    function make_invalid_arg(counter,k,o,acc,fmt)
     {var _YM_=[8,acc,_bR_];
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_printf$0(counter$0,k,o,_YM_,fmt)}
      return caml_trampoline_return(make_printf$0,[0,k,o,_YM_,fmt])}
    function make_custom$0(counter,k,o,acc,rest,arity,f)
     {if(arity)
       {var arity$0=arity[1];
        return function(x)
         {return make_custom(k,o,acc,rest,arity$0,caml_call1(f,x))}}
      var _YL_=[4,acc,f];
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_printf$0(counter$0,k,o,_YL_,rest)}
      return caml_trampoline_return(make_printf$0,[0,k,o,_YL_,rest])}
    function make_printf(k,o,acc,fmt)
     {return caml_trampoline(make_printf$0(0,k,o,acc,fmt))}
    function make_from_fmtty(k,o,acc,fmtty,fmt)
     {return caml_trampoline(make_from_fmtty$0(0,k,o,acc,fmtty,fmt))}
    function make_custom(k,o,acc,rest,arity,f)
     {return caml_trampoline(make_custom$0(0,k,o,acc,rest,arity,f))}
    function make_padding(k,o,acc,fmt,pad,trans)
     {if(typeof pad === "number")
       return function(x)
        {var new_acc=[4,acc,caml_call1(trans,x)];
         return make_printf(k,o,new_acc,fmt)};
      else
       {if(0 === pad[0])
         {var width=pad[2],padty=pad[1];
          return function(x)
           {var new_acc=[4,acc,fix_padding(padty,width,caml_call1(trans,x))];
            return make_printf(k,o,new_acc,fmt)}}
        var padty$0=pad[1];
        return function(w,x)
         {var new_acc=[4,acc,fix_padding(padty$0,w,caml_call1(trans,x))];
          return make_printf(k,o,new_acc,fmt)}}}
    function make_int_padding_precision(k,o,acc,fmt,pad,match,trans,iconv)
     {if(typeof pad === "number")
       {if(typeof match === "number")
         return 0 === match
                 ?function(x)
                   {var str=caml_call2(trans,iconv,x);
                    return make_printf(k,o,[4,acc,str],fmt)}
                 :function(p,x)
                   {var str=fix_int_precision(p,caml_call2(trans,iconv,x));
                    return make_printf(k,o,[4,acc,str],fmt)};
        var p=match[1];
        return function(x)
         {var str=fix_int_precision(p,caml_call2(trans,iconv,x));
          return make_printf(k,o,[4,acc,str],fmt)}}
      else
       {if(0 === pad[0])
         {var _YI_=pad[2],_YJ_=pad[1];
          if(typeof match === "number")
           return 0 === match
                   ?function(x)
                     {var str=fix_padding(_YJ_,_YI_,caml_call2(trans,iconv,x));
                      return make_printf(k,o,[4,acc,str],fmt)}
                   :function(p,x)
                     {var
                       str=
                        fix_padding
                         (_YJ_,_YI_,fix_int_precision(p,caml_call2(trans,iconv,x)));
                      return make_printf(k,o,[4,acc,str],fmt)};
          var p$0=match[1];
          return function(x)
           {var
             str=
              fix_padding
               (_YJ_,_YI_,fix_int_precision(p$0,caml_call2(trans,iconv,x)));
            return make_printf(k,o,[4,acc,str],fmt)}}
        var _YK_=pad[1];
        if(typeof match === "number")
         return 0 === match
                 ?function(w,x)
                   {var str=fix_padding(_YK_,w,caml_call2(trans,iconv,x));
                    return make_printf(k,o,[4,acc,str],fmt)}
                 :function(w,p,x)
                   {var
                     str=
                      fix_padding
                       (_YK_,w,fix_int_precision(p,caml_call2(trans,iconv,x)));
                    return make_printf(k,o,[4,acc,str],fmt)};
        var p$1=match[1];
        return function(w,x)
         {var
           str=
            fix_padding
             (_YK_,w,fix_int_precision(p$1,caml_call2(trans,iconv,x)));
          return make_printf(k,o,[4,acc,str],fmt)}}}
    function output_acc(o,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           output_acc(o,p);
           return output_string(o,s);
          case 1:
           var _YG_=acc$0[2],_YH_=acc$0[1];
           if(0 === _YG_[0])
            {var acc$1=_YG_[1];
             output_acc(o,_YH_);
             output_string(o,_bS_);
             var acc$0=acc$1;
             continue}
           var acc$2=_YG_[1];
           output_acc(o,_YH_);
           output_string(o,_bT_);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           output_acc(o,p$2);
           return caml_call1(f,o);
          case 7:var p$3=acc$0[1];output_acc(o,p$3);return caml_ml_flush(o);
          case 8:
           var msg=acc$0[2],p$4=acc$0[1];
           output_acc(o,p$4);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           output_acc(o,p$0);
           return output_string(o,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];
           output_acc(o,p$1);
           return caml_ml_output_char(o,c)}}
    function bufput_acc(b,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           bufput_acc(b,p);
           return add_string(b,s);
          case 1:
           var _YE_=acc$0[2],_YF_=acc$0[1];
           if(0 === _YE_[0])
            {var acc$1=_YE_[1];
             bufput_acc(b,_YF_);
             add_string(b,_bU_);
             var acc$0=acc$1;
             continue}
           var acc$2=_YE_[1];
           bufput_acc(b,_YF_);
           add_string(b,_bV_);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           bufput_acc(b,p$2);
           return caml_call1(f,b);
          case 7:var acc$3=acc$0[1],acc$0=acc$3;continue;
          case 8:
           var msg=acc$0[2],p$3=acc$0[1];
           bufput_acc(b,p$3);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           bufput_acc(b,p$0);
           return add_string(b,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];bufput_acc(b,p$1);return add_char(b,c)}}
    function strput_acc(b,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           strput_acc(b,p);
           return add_string(b,s);
          case 1:
           var _YC_=acc$0[2],_YD_=acc$0[1];
           if(0 === _YC_[0])
            {var acc$1=_YC_[1];
             strput_acc(b,_YD_);
             add_string(b,_bW_);
             var acc$0=acc$1;
             continue}
           var acc$2=_YC_[1];
           strput_acc(b,_YD_);
           add_string(b,_bX_);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           strput_acc(b,p$2);
           return add_string(b,caml_call1(f,0));
          case 7:var acc$3=acc$0[1],acc$0=acc$3;continue;
          case 8:
           var msg=acc$0[2],p$3=acc$0[1];
           strput_acc(b,p$3);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           strput_acc(b,p$0);
           return add_string(b,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];strput_acc(b,p$1);return add_char(b,c)}}
    function open_box_of_string(str)
     {if(caml_string_equal(str,_bY_))return _bZ_;
      var len=caml_ml_string_length(str);
      function invalid_box(param$0)
       {var fmt=param[1],buf=create(256);
        function k(param,acc)
         {strput_acc(buf,acc);return failwith(contents(buf))}
        return caml_call1(make_printf(k,0,0,fmt),str)}
      function parse_spaces(i)
       {var i$0=i;
        for(;;)
         {if(i$0 === len)return i$0;
          var match=caml_string_get(str,i$0);
          if(9 !== match && 32 !== match)return i$0;
          var i$1=i$0 + 1 | 0,i$0=i$1;
          continue}}
      function parse_lword(i,j)
       {var j$0=j;
        for(;;)
         {if(j$0 === len)return j$0;
          var match=caml_string_get(str,j$0),switcher=match - 97 | 0;
          if(25 < switcher >>> 0)return j$0;
          var j$1=j$0 + 1 | 0,j$0=j$1;
          continue}}
      function parse_int(i,j)
       {var j$0=j;
        for(;;)
         {if(j$0 === len)return j$0;
          var match=caml_string_get(str,j$0),switch$0=0;
          if(48 <= match)
           {if(! (58 <= match))switch$0 = 1}
          else
           if(45 === match)switch$0 = 1;
          if(switch$0){var j$1=j$0 + 1 | 0,j$0=j$1;continue}
          return j$0}}
      var
       wstart=parse_spaces(0),
       wend=parse_lword(wstart,wstart),
       box_name=sub$0(str,wstart,wend - wstart | 0),
       nstart=parse_spaces(wend),
       nend=parse_int(nstart,nstart);
      if(nstart === nend)
       var indent=0;
      else
       try
        {var
          _YA_=caml_int_of_string(sub$0(str,nstart,nend - nstart | 0)),
          indent=_YA_}
       catch(_YB_)
        {_YB_ = caml_wrap_exception(_YB_);
         if(_YB_[1] !== Failure)throw _YB_;
         var indent=invalid_box(0)}
      var exp_end=parse_spaces(nend);
      if(exp_end !== len)invalid_box(0);
      var switch$0=0;
      if
       (caml_string_notequal(box_name,_b0_)
        &&
        caml_string_notequal(box_name,_b1_))
       var
        box_type=
         caml_string_notequal(box_name,_b2_)
          ?caml_string_notequal(box_name,_b3_)
            ?caml_string_notequal(box_name,_b4_)
              ?caml_string_notequal(box_name,_b5_)?invalid_box(0):1
              :2
            :3
          :0;
      else
       switch$0 = 1;
      if(switch$0)var box_type=4;
      return [0,indent,box_type]}
    function fprintf(oc,fmt$0)
     {var fmt=fmt$0[1],_Yz_=0;
      return make_printf
              (function(o,acc){output_acc(o,acc);return 0},oc,_Yz_,fmt)}
    function bprintf(b,fmt$0)
     {var fmt=fmt$0[1],_Yy_=0;
      return make_printf
              (function(b,acc){bufput_acc(b,acc);return 0},b,_Yy_,fmt)}
    function printf(fmt){return fprintf(stdout,fmt)}
    function eprintf(fmt){return fprintf(stderr,fmt)}
    function sprintf(fmt$0)
     {var fmt=fmt$0[1];
      function k(param,acc)
       {var buf=create(64);strput_acc(buf,acc);return contents(buf)}
      return make_printf(k,0,0,fmt)}
    var
     Bad=[248,_b6_,caml_fresh_oo_id(0)],
     Help=[248,_b7_,caml_fresh_oo_id(0)],
     Stop=[248,_b8_,caml_fresh_oo_id(0)];
    function assoc3(x,l)
     {var l$0=l;
      for(;;)
       {if(l$0)
         {var t=l$0[2],match=l$0[1],y2=match[2],y1=match[1];
          if(caml_equal(y1,x))return y2;
          var l$0=t;
          continue}
        throw Not_found}}
    function split(s)
     {var
       i=index(s,61),
       len=caml_ml_string_length(s),
       _Yx_=sub$0(s,i + 1 | 0,len - (i + 1 | 0) | 0);
      return [0,sub$0(s,0,i),_Yx_]}
    function make_symlist(prefix,sep,suffix,l)
     {if(l)
       {var t=l[2],h=l[1],_Yw_=symbol(prefix,h);
        return symbol
                (fold_left
                  (function(x,y){return symbol(x,symbol(sep,y))},_Yw_,t),
                 suffix)}
      return _b9_}
    function help_action(param){throw [0,Stop,_cd_]}
    function add_help(speclist)
     {try
       {assoc3(_cj_,speclist);var _Yt_=0,_Yr_=_Yt_}
      catch(_Yv_)
       {_Yv_ = caml_wrap_exception(_Yv_);
        if(_Yv_ !== Not_found)throw _Yv_;
        var _Yr_=[0,[0,_cf_,[0,help_action],_ce_],0]}
      try
       {assoc3(_ci_,speclist);var _Ys_=0,add2=_Ys_}
      catch(_Yu_)
       {_Yu_ = caml_wrap_exception(_Yu_);
        if(_Yu_ !== Not_found)throw _Yu_;
        var add2=[0,[0,_ch_,[0,help_action],_cg_],0]}
      return append(speclist,append(_Yr_,add2))}
    var current=[0,0];
    function bool_of_string_opt(x)
     {try
       {var _Yp_=[0,bool_of_string(x)];return _Yp_}
      catch(_Yq_)
       {_Yq_ = caml_wrap_exception(_Yq_);
        if(_Yq_[1] === Invalid_argument)return 0;
        throw _Yq_}}
    function int_of_string_opt(x)
     {try
       {var _Yn_=[0,caml_int_of_string(x)];return _Yn_}
      catch(_Yo_)
       {_Yo_ = caml_wrap_exception(_Yo_);
        if(_Yo_[1] === Failure)return 0;
        throw _Yo_}}
    function float_of_string_opt(x)
     {try
       {var _Yl_=[0,caml_float_of_string(x)];return _Yl_}
      catch(_Ym_)
       {_Ym_ = caml_wrap_exception(_Ym_);
        if(_Ym_[1] === Failure)return 0;
        throw _Ym_}}
    function parse_and_expand_argv_dynamic_
     (allow_expand,current,argv,speclist,anonfun,errmsg)
     {var initpos=current[1];
      function convert_error(error)
       {var
         buf=create(200),
         progname=
          initpos < argv[1].length - 1
           ?caml_check_bound(argv[1],initpos)[1 + initpos]
           :_ct_;
        switch(error[0])
         {case 0:
           var _Yh_=error[1];
           if
            (caml_string_notequal(_Yh_,_cl_)
             &&
             caml_string_notequal(_Yh_,_cm_))
            caml_call2(bprintf(buf,_cn_),progname,_Yh_);
           break;
          case 1:
           var expected=error[3],arg=error[2],opt=error[1];
           caml_call4(bprintf(buf,_cq_),progname,arg,opt,expected);
           break;
          case 2:
           var s=error[1];caml_call2(bprintf(buf,_cr_),progname,s);break;
          default:var s$0=error[1];caml_call2(bprintf(buf,_cs_),progname,s$0)}
        var _Yi_=speclist[1];
        caml_call1(bprintf(buf,_ck_),errmsg);
        var _Yg_=add_help(_Yi_);
        iter$0
         (function(param)
           {var
             doc=param[3],
             spec=param[2],
             key=param[1],
             _Yj_=0 < caml_ml_string_length(doc)?1:0;
            if(_Yj_)
             {if(11 === spec[0])
               {var l=spec[1],_Yk_=make_symlist(_cb_,_ca_,_b$_,l);
                return caml_call3(bprintf(buf,_cc_),key,_Yk_,doc)}
              return caml_call2(bprintf(buf,_b__),key,doc)}
            return _Yj_},
          _Yg_);
        if(! caml_equal(error,_co_) && ! caml_equal(error,_cp_))
         return [0,Bad,contents(buf)];
        return [0,Help,contents(buf)]}
      current[1]++;
      for(;;)
       {if(current[1] < argv[1].length - 1)
         {try
           {var
             _X9_=current[1],
             s=caml_check_bound(argv[1],_X9_)[1 + _X9_],
             switch$0=0;
            if(1 <= caml_ml_string_length(s) && 45 === caml_string_get(s,0))
             {try
               {var
                 follow$1=0,
                 _X$_=assoc3(s,speclist[1]),
                 action=_X$_,
                 follow$0=follow$1}
              catch(_Ye_)
               {_Ye_ = caml_wrap_exception(_Ye_);
                if(_Ye_ !== Not_found)throw _Ye_;
                try
                 {var
                   match=split(s),
                   arg=match[2],
                   keyword=match[1],
                   follow=[0,arg],
                   _X__=assoc3(keyword,speclist[1])}
                catch(_Yf_)
                 {_Yf_ = caml_wrap_exception(_Yf_);
                  if(_Yf_ === Not_found)throw [0,Stop,[0,s]];
                  throw _Yf_;
                  var _Ya_=_Yf_}
                var action=_X__,follow$0=follow,_Yb_=_Ye_}
              var
               no_arg$0=
                function(s,follow)
                 {function no_arg(param)
                   {if(follow){var arg=follow[1];throw [0,Stop,[1,s,arg,_cu_]]}
                    return 0}
                  return no_arg},
               no_arg=no_arg$0(s,follow$0),
               get_arg$0=
                function(s,follow)
                 {function get_arg(param)
                   {if(follow){var arg=follow[1];return arg}
                    if((current[1] + 1 | 0) < argv[1].length - 1)
                     {var _Yd_=current[1] + 1 | 0;
                      return caml_check_bound(argv[1],_Yd_)[1 + _Yd_]}
                    throw [0,Stop,[2,s]]}
                  return get_arg},
               get_arg=get_arg$0(s,follow$0),
               consume_arg$0=
                function(follow)
                 {function consume_arg(param)
                   {return follow?0:(current[1]++,0)}
                  return consume_arg},
               consume_arg=consume_arg$0(follow$0),
               treat_action$0=
                function(s,no_arg,get_arg,consume_arg)
                 {function treat_action(param)
                   {switch(param[0])
                     {case 0:var f=param[1];return caml_call1(f,0);
                      case 1:
                       var
                        f$0=param[1],
                        arg=get_arg(0),
                        match=bool_of_string_opt(arg);
                       if(match)
                        {var s$0=match[1];caml_call1(f$0,s$0);return consume_arg(0)}
                       throw [0,Stop,[1,s,arg,_cv_]];
                      case 2:var r=param[1];no_arg(0);r[1] = 1;return 0;
                      case 3:var r$0=param[1];no_arg(0);r$0[1] = 0;return 0;
                      case 4:
                       var f$1=param[1],arg$0=get_arg(0);
                       caml_call1(f$1,arg$0);
                       return consume_arg(0);
                      case 5:
                       var r$1=param[1];r$1[1] = get_arg(0);return consume_arg(0);
                      case 6:
                       var
                        f$2=param[1],
                        arg$1=get_arg(0),
                        match$0=int_of_string_opt(arg$1);
                       if(match$0)
                        {var x=match$0[1];caml_call1(f$2,x);return consume_arg(0)}
                       throw [0,Stop,[1,s,arg$1,_cw_]];
                      case 7:
                       var
                        r$2=param[1],
                        arg$2=get_arg(0),
                        match$1=int_of_string_opt(arg$2);
                       if(match$1)
                        {var x$0=match$1[1];r$2[1] = x$0;return consume_arg(0)}
                       throw [0,Stop,[1,s,arg$2,_cx_]];
                      case 8:
                       var
                        f$3=param[1],
                        arg$3=get_arg(0),
                        match$2=float_of_string_opt(arg$3);
                       if(match$2)
                        {var x$1=match$2[1];
                         caml_call1(f$3,x$1);
                         return consume_arg(0)}
                       throw [0,Stop,[1,s,arg$3,_cy_]];
                      case 9:
                       var
                        r$3=param[1],
                        arg$4=get_arg(0),
                        match$3=float_of_string_opt(arg$4);
                       if(match$3)
                        {var x$2=match$3[1];r$3[1] = x$2;return consume_arg(0)}
                       throw [0,Stop,[1,s,arg$4,_cz_]];
                      case 10:
                       var specs=param[1];return iter$0(treat_action,specs);
                      case 11:
                       var f$4=param[2],symb=param[1],arg$5=get_arg(0);
                       if(mem(arg$5,symb))
                        {caml_call1(f$4,arg$5);return consume_arg(0)}
                       throw [0,
                              Stop,
                              [1,s,arg$5,symbol(_cD_,make_symlist(_cC_,_cB_,_cA_,symb))]];
                      case 12:
                       var f$5=param[1];
                       for(;;)
                        {if(current[1] < (argv[1].length - 1 - 1 | 0))
                          {var _Yc_=current[1] + 1 | 0;
                           caml_call1(f$5,caml_check_bound(argv[1],_Yc_)[1 + _Yc_]);
                           consume_arg(0);
                           continue}
                         return 0}
                      default:
                       var f$6=param[1];
                       if(1 - allow_expand)throw [0,Invalid_argument,_cE_];
                       var arg$6=get_arg(0),newarg=caml_call1(f$6,arg$6);
                       consume_arg(0);
                       var
                        before=sub$1(argv[1],0,current[1] + 1 | 0),
                        after=
                         sub$1
                          (argv[1],
                           current[1] + 1 | 0,
                           (argv[1].length - 1 - current[1] | 0) - 1 | 0);
                       argv[1]
                       =
                       caml_array_concat([0,before,[0,newarg,[0,after,0]]]);
                       return 0}}
                  return treat_action},
               treat_action=treat_action$0(s,no_arg,get_arg,consume_arg);
              treat_action(action);
              switch$0 = 1}
            if(! switch$0)caml_call1(anonfun,s)}
          catch(exn$0)
           {exn$0 = caml_wrap_exception(exn$0);
            if(exn$0[1] === Bad){var m=exn$0[2];throw convert_error([3,m])}
            if(exn$0[1] === Stop){var e=exn$0[2];throw convert_error(e)}
            throw exn$0;
            var exn=exn$0}
          current[1]++;
          continue}
        return 0}}
    function parse_argv(opt,argv,speclist,anonfun,errmsg)
     {if(opt)var sth=opt[1],sth$0=sth;else var sth$0=current;
      var
       speclist$0=[0,speclist],
       opt$0=[0,sth$0],
       current$0=opt$0?sth$0:current;
      return parse_and_expand_argv_dynamic_
              (0,current$0,[0,argv],speclist$0,anonfun,errmsg)}
    function second_word(s)
     {var len=caml_ml_string_length(s);
      function loop(n)
       {var n$0=n;
        for(;;)
         {if(len <= n$0)return len;
          if(32 === caml_string_get(s,n$0))
           {var n$1=n$0 + 1 | 0,n$0=n$1;continue}
          return n$0}}
      try
       {var n$0=index(s,9)}
      catch(_X7_)
       {_X7_ = caml_wrap_exception(_X7_);
        if(_X7_ === Not_found)
         {try
           {var n=index(s,32)}
          catch(_X8_)
           {_X8_ = caml_wrap_exception(_X8_);
            if(_X8_ === Not_found)return len;
            throw _X8_}
          return loop(n + 1 | 0)}
        throw _X7_}
      return loop(n$0 + 1 | 0)}
    function max_arg_len(cur,param)
     {var doc=param[3],spec=param[2],kwd=param[1];
      return 11 === spec[0]
              ?max(cur,caml_ml_string_length(kwd))
              :max(cur,caml_ml_string_length(kwd) + second_word(doc) | 0)}
    function replace_leading_tab(s)
     {var seen=[0,0];
      function f(c){if(9 === c && ! seen[1]){seen[1] = 1;return 32}return c}
      return caml_string_of_bytes(map$1(f,caml_bytes_of_string(s)))}
    function align(opt,speclist)
     {if(opt)var sth=opt[1],limit=sth;else var limit=max_int;
      var
       completed=add_help(speclist),
       len=fold_left(max_arg_len,0,completed),
       len$0=min(len,limit);
      return map$0
              (function(ksd)
                {var _X5_=ksd[2],_X6_=ksd[1];
                 if(caml_string_notequal(ksd[3],_cH_))
                  {if(11 === _X5_[0])
                    {var
                      msg$0=ksd[3],
                      cutcol$0=second_word(msg$0),
                      spaces$0=make$0(max(0,len$0 - cutcol$0 | 0) + 3 | 0,32);
                     return [0,
                             _X6_,
                             _X5_,
                             symbol(_cI_,symbol(spaces$0,replace_leading_tab(msg$0)))]}
                   var
                    msg=ksd[3],
                    cutcol=second_word(msg),
                    kwd_len=caml_ml_string_length(_X6_),
                    diff=(len$0 - kwd_len | 0) - cutcol | 0;
                   if(0 < diff)
                    {var
                      spaces=make$0(diff,32),
                      prefix=sub$0(replace_leading_tab(msg),0,cutcol),
                      suffix=
                       sub$0(msg,cutcol,caml_ml_string_length(msg) - cutcol | 0);
                     return [0,_X6_,_X5_,symbol(prefix,symbol(spaces,suffix))]}
                   return [0,_X6_,_X5_,replace_leading_tab(msg)]}
                 return ksd},
               completed)}
    var printers=[0,0];
    function register_printer(fn){printers[1] = [0,fn,printers[1]];return 0}
    function make_self_init(param)
     {var
       seed$0=caml_sys_random_seed(0),
       result=[0,caml_make_vect(55,0),0],
       seed=0 === seed$0.length - 1?[0,0]:seed$0,
       l=seed.length - 1,
       i$0=0;
      for(;;)
       {caml_check_bound(result[1],i$0)[1 + i$0] = i$0;
        var _X4_=i$0 + 1 | 0;
        if(54 !== i$0){var i$0=_X4_;continue}
        var accu=[0,_cJ_],_X0_=54 + max(55,l) | 0,_XZ_=0;
        if(! (_X0_ < 0))
         {var i=_XZ_;
          for(;;)
           {var
             j=i % 55 | 0,
             k=caml_mod(i,l),
             x=caml_check_bound(seed,k)[1 + k],
             str=symbol(accu[1],caml_string_of_jsbytes("" + x));
            accu[1] = caml_md5_string(str,0,caml_ml_string_length(str));
            var
             _X1_=accu[1],
             _XV_=caml_string_get(_X1_,3) << 24,
             _XW_=caml_string_get(_X1_,2) << 16,
             _XX_=caml_string_get(_X1_,1) << 8,
             _XY_=((caml_string_get(_X1_,0) + _XX_ | 0) + _XW_ | 0) + _XV_ | 0,
             _X2_=(caml_check_bound(result[1],j)[1 + j] ^ _XY_) & 1073741823;
            caml_check_bound(result[1],j)[1 + j] = _X2_;
            var _X3_=i + 1 | 0;
            if(_X0_ !== i){var i=_X3_;continue}
            break}}
        result[2] = 0;
        return result}}
    function bits(s)
     {s[2] = (s[2] + 1 | 0) % 55 | 0;
      var
       _XS_=s[2],
       curval=caml_check_bound(s[1],_XS_)[1 + _XS_],
       _XT_=(s[2] + 24 | 0) % 55 | 0,
       newval=
        caml_check_bound(s[1],_XT_)[1 + _XT_]
        +
        (curval ^ (curval >>> 25 | 0) & 31)
        |
        0,
       newval30=newval & 1073741823,
       _XU_=s[2];
      caml_check_bound(s[1],_XU_)[1 + _XU_] = newval30;
      return newval30}
    function hash(x){return caml_hash(10,100,0,x)}
    function ongoing_traversal(h)
     {var _XQ_=h.length - 1 < 4?1:0,_XR_=_XQ_ || (h[4] < 0?1:0);return _XR_}
    function flip_ongoing_traversal(h){h[4] = - h[4] | 0;return 0}
    try
     {var _BO_=caml_sys_getenv(_BN_),params=_BO_}
    catch(_XO_)
     {_XO_ = caml_wrap_exception(_XO_);
      if(_XO_ !== Not_found)throw _XO_;
      try
       {var _BM_=caml_sys_getenv(_BL_),_cL_=_BM_}
      catch(_XP_)
       {_XP_ = caml_wrap_exception(_XP_);
        if(_XP_ !== Not_found)throw _XP_;
        var _cL_=_cK_}
      var params=_cL_}
    var
     randomized_default=contains(params,82),
     prng=[246,function(_XN_){return make_self_init(0)}];
    function create$0(opt,initial_size)
     {if(opt)var sth=opt[1],random=sth;else var random=randomized_default;
      var x=16;
      for(;;)
       {if(! (initial_size <= x) && ! (max_array_length < (x * 2 | 0)))
         {var x$0=x * 2 | 0,x=x$0;continue}
        if(random)
         var
          _XL_=caml_obj_tag(prng),
          _XM_=250 === _XL_?prng[1]:246 === _XL_?force_lazy_block(prng):prng,
          seed=bits(_XM_);
        else
         var seed=0;
        return [0,0,caml_make_vect(x,0),seed,x]}}
    function clear(h)
     {h[1] = 0;
      var len=h[2].length - 1,_XJ_=len - 1 | 0,_XI_=0;
      if(! (_XJ_ < 0))
       {var i=_XI_;
        for(;;)
         {caml_check_bound(h[2],i)[1 + i] = 0;
          var _XK_=i + 1 | 0;
          if(_XJ_ !== i){var i=_XK_;continue}
          break}}
      return 0}
    function reset(h)
     {var len=h[2].length - 1;
      if(4 <= h.length - 1 && len !== abs(h[4]))
       {h[1] = 0;h[2] = caml_make_vect(abs(h[4]),0);return 0}
      return clear(h)}
    function copy_bucketlist(param)
     {if(param)
       {var
         key=param[1],
         data=param[2],
         next=param[3],
         prec$0=[0,key,data,next],
         prec=prec$0,
         param$0=next;
        for(;;)
         {if(param$0)
           {var
             key$0=param$0[1],
             data$0=param$0[2],
             next$0=param$0[3],
             r=[0,key$0,data$0,next$0];
            if(prec){prec[3] = r;var prec=r,param$0=next$0;continue}
            throw [0,Assert_failure,_cM_]}
          return prec$0}}
      return 0}
    function copy$1(h)
     {var _XF_=h[4],_XG_=h[3],_XH_=map$2(copy_bucketlist,h[2]);
      return [0,h[1],_XH_,_XG_,_XF_]}
    function length$0(h){return h[1]}
    function resize$0(indexfun,h)
     {var
       odata=h[2],
       osize=odata.length - 1,
       nsize=osize * 2 | 0,
       _Xw_=nsize < max_array_length?1:0;
      if(_Xw_)
       {var
         ndata=caml_make_vect(nsize,0),
         ndata_tail=caml_make_vect(nsize,0),
         inplace=1 - ongoing_traversal(h);
        h[2] = ndata;
        var _Xy_=osize - 1 | 0,_Xx_=0;
        if(! (_Xy_ < 0))
         {var i$0=_Xx_;
          a:
          for(;;)
           {var cell$1=caml_check_bound(odata,i$0)[1 + i$0],cell=cell$1;
            for(;;)
             {if(cell)
               {var
                 key=cell[1],
                 data=cell[2],
                 next=cell[3],
                 cell$0=inplace?cell:[0,key,data,0],
                 nidx=caml_call2(indexfun,h,key),
                 match=caml_check_bound(ndata_tail,nidx)[1 + nidx];
                if(match)
                 match[3] = cell$0;
                else
                 caml_check_bound(ndata,nidx)[1 + nidx] = cell$0;
                caml_check_bound(ndata_tail,nidx)[1 + nidx] = cell$0;
                var cell=next;
                continue}
              var _XE_=i$0 + 1 | 0;
              if(_Xy_ !== i$0){var i$0=_XE_;continue a}
              break}
            break}}
        if(inplace)
         {var _XA_=nsize - 1 | 0,_Xz_=0;
          if(! (_XA_ < 0))
           {var i=_Xz_;
            for(;;)
             {var match$0=caml_check_bound(ndata_tail,i)[1 + i];
              if(match$0)match$0[3] = 0;
              var _XD_=i + 1 | 0;
              if(_XA_ !== i){var i=_XD_;continue}
              break}}
          var _XB_=0}
        else
         var _XB_=inplace;
        var _XC_=_XB_}
      else
       var _XC_=_Xw_;
      return _XC_}
    function key_index(h,key)
     {return 3 <= h.length - 1
              ?caml_hash(10,100,h[3],key) & (h[2].length - 1 - 1 | 0)
              :caml_mod(caml_hash_univ_param(10,100,key),h[2].length - 1)}
    function add(h,key,data)
     {var
       i=key_index(h,key),
       bucket=[0,key,data,caml_check_bound(h[2],i)[1 + i]];
      caml_check_bound(h[2],i)[1 + i] = bucket;
      h[1] = h[1] + 1 | 0;
      var _Xv_=h[2].length - 1 << 1 < h[1]?1:0;
      return _Xv_?resize$0(key_index,h):_Xv_}
    function remove(h,key)
     {var i=key_index(h,key),c$0=caml_check_bound(h[2],i)[1 + i],prec=0,c=c$0;
      for(;;)
       {if(c)
         {var k=c[1],next=c[3];
          if(0 === caml_compare(k,key))
           {h[1] = h[1] - 1 | 0;
            return prec
                    ?(prec[3] = next,0)
                    :(caml_check_bound(h[2],i)[1 + i] = next,0)}
          var prec=c,c=next;
          continue}
        return 0}}
    function find(h,key)
     {var _Xu_=key_index(h,key),match=caml_check_bound(h[2],_Xu_)[1 + _Xu_];
      if(match)
       {var k1=match[1],d1=match[2],next1=match[3];
        if(0 === caml_compare(key,k1))return d1;
        if(next1)
         {var k2=next1[1],d2=next1[2],next2=next1[3];
          if(0 === caml_compare(key,k2))return d2;
          if(next2)
           {var k3=next2[1],d3=next2[2],next3=next2[3];
            if(0 === caml_compare(key,k3))return d3;
            var param=next3;
            for(;;)
             {if(param)
               {var k=param[1],data=param[2],next=param[3];
                if(0 === caml_compare(key,k))return data;
                var param=next;
                continue}
              throw Not_found}}
          throw Not_found}
        throw Not_found}
      throw Not_found}
    function replace(h,key,data)
     {var
       i=key_index(h,key),
       param$0=caml_check_bound(h[2],i)[1 + i],
       param=param$0;
      for(;;)
       {if(param)
         {var k=param[1],next=param[3];
          if(0 !== caml_compare(k,key)){var param=next;continue}
          param[1] = key;
          param[2] = data;
          var _Xr_=0}
        else
         var _Xr_=1;
        if(_Xr_)
         {caml_check_bound(h[2],i)[1 + i] = [0,key,data,param$0];
          h[1] = h[1] + 1 | 0;
          var _Xs_=h[2].length - 1 << 1 < h[1]?1:0;
          if(_Xs_)return resize$0(key_index,h);
          var _Xt_=_Xs_}
        else
         var _Xt_=_Xr_;
        return _Xt_}}
    function mem$0(h,key)
     {var
       _Xq_=key_index(h,key),
       param$0=caml_check_bound(h[2],_Xq_)[1 + _Xq_],
       param=param$0;
      for(;;)
       {if(param)
         {var k=param[1],next=param[3],_Xp_=0 === caml_compare(k,key)?1:0;
          if(_Xp_)return _Xp_;
          var param=next;
          continue}
        return 0}}
    function iter$1(f,h)
     {function do_bucket(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var key=param$0[1],data=param$0[2],param$1=param$0[3];
            caml_call2(f,key,data);
            var param$0=param$1;
            continue}
          return 0}}
      var old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var d=h[2],_Xl_=d.length - 1 - 1 | 0,_Xk_=0;
        if(! (_Xl_ < 0))
         {var i=_Xk_;
          for(;;)
           {do_bucket(caml_check_bound(d,i)[1 + i]);
            var _Xo_=i + 1 | 0;
            if(_Xl_ !== i){var i=_Xo_;continue}
            break}}
        var _Xm_=1 - old_trav,_Xn_=_Xm_?flip_ongoing_traversal(h):_Xm_;
        return _Xn_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function filter_map_inplace_bucket(f,h,i,prec,slot)
     {var prec$0=prec,slot$0=slot;
      for(;;)
       {if(slot$0)
         {var
           key=slot$0[1],
           data=slot$0[2],
           next=slot$0[3],
           match=caml_call2(f,key,data);
          if(match)
           {var data$0=match[1];
            if(prec$0)
             prec$0[3] = slot$0;
            else
             caml_check_bound(h[2],i)[1 + i] = slot$0;
            slot$0[2] = data$0;
            var prec$0=slot$0,slot$0=next;
            continue}
          h[1] = h[1] - 1 | 0;
          var slot$0=next;
          continue}
        return prec$0
                ?(prec$0[3] = 0,0)
                :(caml_check_bound(h[2],i)[1 + i] = 0,0)}}
    function filter_map_inplace(f,h)
     {var d=h[2],old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var _Xh_=d.length - 1 - 1 | 0,_Xg_=0;
        if(! (_Xh_ < 0))
         {var i=_Xg_;
          for(;;)
           {filter_map_inplace_bucket(f,h,i,0,caml_check_bound(h[2],i)[1 + i]);
            var _Xj_=i + 1 | 0;
            if(_Xh_ !== i){var i=_Xj_;continue}
            break}}
        var _Xi_=0;
        return _Xi_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function fold(f,h,init)
     {function do_bucket(b,accu)
       {var b$0=b,accu$0=accu;
        for(;;)
         {if(b$0)
           {var
             key=b$0[1],
             data=b$0[2],
             b$1=b$0[3],
             accu$1=caml_call3(f,key,data,accu$0),
             b$0=b$1,
             accu$0=accu$1;
            continue}
          return accu$0}}
      var old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var d=h[2],accu=[0,init],_Xc_=d.length - 1 - 1 | 0,_Xb_=0;
        if(! (_Xc_ < 0))
         {var i=_Xb_;
          for(;;)
           {var _Xe_=accu[1];
            accu[1] = do_bucket(caml_check_bound(d,i)[1 + i],_Xe_);
            var _Xf_=i + 1 | 0;
            if(_Xc_ !== i){var i=_Xf_;continue}
            break}}
        if(1 - old_trav)flip_ongoing_traversal(h);
        var _Xd_=accu[1];
        return _Xd_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function bucket_length(accu,param)
     {var accu$0=accu,param$0=param;
      for(;;)
       {if(param$0)
         {var
           param$1=param$0[3],
           accu$1=accu$0 + 1 | 0,
           accu$0=accu$1,
           param$0=param$1;
          continue}
        return accu$0}}
    function stats(h)
     {var
       _W__=h[2],
       _W$_=0,
       mbl=
        fold_left$0(function(m,b){return max(m,bucket_length(0,b))},_W$_,_W__),
       histo=caml_make_vect(mbl + 1 | 0,0),
       _Xa_=h[2],
       _W8_=_Xa_.length - 1 - 1 | 0,
       _W7_=0;
      if(! (_W8_ < 0))
       {var i=_W7_;
        for(;;)
         {var b=_Xa_[1 + i],l=bucket_length(0,b);
          histo[1 + l] = caml_check_bound(histo,l)[1 + l] + 1 | 0;
          var _W9_=i + 1 | 0;
          if(_W8_ !== i){var i=_W9_;continue}
          break}}
      return [0,h[1],h[2].length - 1,mbl,histo]}
    function to_seq(tbl)
     {var tbl_data=tbl[2];
      function aux(i,buck,param)
       {var i$0=i,buck$0=buck;
        for(;;)
         {if(buck$0)
           {var key=buck$0[1],data=buck$0[2],next=buck$0[3];
            return [0,[0,key,data],function(_W6_){return aux(i$0,next,_W6_)}]}
          if(i$0 === tbl_data.length - 1)return 0;
          var
           buck$1=caml_check_bound(tbl_data,i$0)[1 + i$0],
           i$1=i$0 + 1 | 0,
           i$0=i$1,
           buck$0=buck$1;
          continue}}
      var _W3_=0,_W4_=0;
      return function(_W5_){return aux(_W4_,_W3_,_W5_)}}
    function to_seq_keys(m)
     {var _WZ_=to_seq(m);
      function _W0_(_W2_){return _W2_[1]}
      return function(_W1_){return map(_W0_,_WZ_,_W1_)}}
    function to_seq_values(m)
     {var _WV_=to_seq(m);
      function _WW_(_WY_){return _WY_[2]}
      return function(_WX_){return map(_WW_,_WV_,_WX_)}}
    function add_seq(tbl,i)
     {return iter
              (function(param){var v=param[2],k=param[1];return add(tbl,k,v)},
               i)}
    function replace_seq(tbl,i)
     {return iter
              (function(param)
                {var v=param[2],k=param[1];return replace(tbl,k,v)},
               i)}
    function of_seq(i){var tbl=create$0(0,16);replace_seq(tbl,i);return tbl}
    function Make(H)
     {var equal=H[1];
      function key_index(h,x)
       {var _WU_=h[2].length - 1 - 1 | 0;return caml_call1(H[2],x) & _WU_}
      function add(h,key,data)
       {var
         i=key_index(h,key),
         bucket=[0,key,data,caml_check_bound(h[2],i)[1 + i]];
        caml_check_bound(h[2],i)[1 + i] = bucket;
        h[1] = h[1] + 1 | 0;
        var _WT_=h[2].length - 1 << 1 < h[1]?1:0;
        return _WT_?resize$0(key_index,h):_WT_}
      function remove(h,key)
       {var
         i=key_index(h,key),
         c$0=caml_check_bound(h[2],i)[1 + i],
         prec=0,
         c=c$0;
        for(;;)
         {if(c)
           {var k=c[1],next=c[3];
            if(caml_call2(equal,k,key))
             {h[1] = h[1] - 1 | 0;
              return prec
                      ?(prec[3] = next,0)
                      :(caml_check_bound(h[2],i)[1 + i] = next,0)}
            var prec=c,c=next;
            continue}
          return 0}}
      function find(h,key)
       {var _WS_=key_index(h,key),match=caml_check_bound(h[2],_WS_)[1 + _WS_];
        if(match)
         {var k1=match[1],d1=match[2],next1=match[3];
          if(caml_call2(equal,key,k1))return d1;
          if(next1)
           {var k2=next1[1],d2=next1[2],next2=next1[3];
            if(caml_call2(equal,key,k2))return d2;
            if(next2)
             {var k3=next2[1],d3=next2[2],next3=next2[3];
              if(caml_call2(equal,key,k3))return d3;
              var param=next3;
              for(;;)
               {if(param)
                 {var k=param[1],data=param[2],next=param[3];
                  if(caml_call2(equal,key,k))return data;
                  var param=next;
                  continue}
                throw Not_found}}
            throw Not_found}
          throw Not_found}
        throw Not_found}
      function find_opt(h,key)
       {var _WR_=key_index(h,key),match=caml_check_bound(h[2],_WR_)[1 + _WR_];
        if(match)
         {var k1=match[1],d1=match[2],next1=match[3];
          if(caml_call2(equal,key,k1))return [0,d1];
          if(next1)
           {var k2=next1[1],d2=next1[2],next2=next1[3];
            if(caml_call2(equal,key,k2))return [0,d2];
            if(next2)
             {var k3=next2[1],d3=next2[2],next3=next2[3];
              if(caml_call2(equal,key,k3))return [0,d3];
              var param=next3;
              for(;;)
               {if(param)
                 {var k=param[1],data=param[2],next=param[3];
                  if(caml_call2(equal,key,k))return [0,data];
                  var param=next;
                  continue}
                return 0}}
            return 0}
          return 0}
        return 0}
      function find_all(h,key)
       {function find_in_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var k=param$0[1],d=param$0[2],next=param$0[3];
              if(caml_call2(equal,k,key))return [0,d,find_in_bucket(next)];
              var param$0=next;
              continue}
            return 0}}
        var _WQ_=key_index(h,key);
        return find_in_bucket(caml_check_bound(h[2],_WQ_)[1 + _WQ_])}
      function replace(h,key,data)
       {var
         i=key_index(h,key),
         param$0=caml_check_bound(h[2],i)[1 + i],
         param=param$0;
        for(;;)
         {if(param)
           {var k=param[1],next=param[3];
            if(! caml_call2(equal,k,key)){var param=next;continue}
            param[1] = key;
            param[2] = data;
            var _WN_=0}
          else
           var _WN_=1;
          if(_WN_)
           {caml_check_bound(h[2],i)[1 + i] = [0,key,data,param$0];
            h[1] = h[1] + 1 | 0;
            var _WO_=h[2].length - 1 << 1 < h[1]?1:0;
            if(_WO_)return resize$0(key_index,h);
            var _WP_=_WO_}
          else
           var _WP_=_WN_;
          return _WP_}}
      function mem(h,key)
       {var
         _WM_=key_index(h,key),
         param$0=caml_check_bound(h[2],_WM_)[1 + _WM_],
         param=param$0;
        for(;;)
         {if(param)
           {var k=param[1],next=param[3],_WL_=caml_call2(equal,k,key);
            if(_WL_)return _WL_;
            var param=next;
            continue}
          return 0}}
      function create(sz){return create$0(_cN_,sz)}
      return [0,
              create,
              clear,
              reset,
              copy$1,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter$1,
              filter_map_inplace,
              fold,
              length$0,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq]}
    function add_queue(x,q)
     {var c=[0,x,0],_WK_=q[1];
      return _WK_?(q[1] = c,_WK_[2] = c,0):(q[1] = c,q[2] = c,0)}
    var Empty_queue=[248,_cO_,caml_fresh_oo_id(0)];
    function take_queue(q)
     {var _WJ_=q[2];
      if(_WJ_)
       {var x=_WJ_[1],tl=_WJ_[2];q[2] = tl;if(0 === tl)q[1] = 0;return x}
      throw Empty_queue}
    function pp_enqueue(state,token)
     {var len=token[3];
      state[13] = state[13] + len | 0;
      return add_queue(token,state[28])}
    var pp_infinity=1000000010;
    function pp_output_string(state,s)
     {return caml_call3(state[17],s,0,caml_ml_string_length(s))}
    function pp_output_newline(state){return caml_call1(state[19],0)}
    function break_new_line(state,offset,width)
     {pp_output_newline(state);
      state[11] = 1;
      var
       indent=(state[6] - width | 0) + offset | 0,
       real_indent=min(state[8],indent);
      state[10] = real_indent;
      state[9] = state[6] - state[10] | 0;
      return caml_call1(state[21],state[10])}
    function break_line(state,width){return break_new_line(state,0,width)}
    function break_same_line(state,width)
     {state[9] = state[9] - width | 0;return caml_call1(state[20],width)}
    function pp_force_break_line(state)
     {var _WG_=state[2];
      if(_WG_)
       {var
         match=_WG_[1],
         width=match[2],
         bl_ty=match[1],
         _WH_=state[9] < width?1:0;
        if(_WH_)
         {if(0 !== bl_ty)return 5 <= bl_ty?0:break_line(state,width);
          var _WI_=0}
        else
         var _WI_=_WH_;
        return _WI_}
      return pp_output_newline(state)}
    function pp_skip_token(state)
     {var match=take_queue(state[28]),size=match[1],len=match[3];
      state[12] = state[12] - len | 0;
      state[9] = state[9] + size | 0;
      return 0}
    function format_pp_token(state,size,param)
     {if(typeof param === "number")
       switch(param)
        {case 0:
          var _Wv_=state[3];
          if(_Wv_)
           {var
             match=_Wv_[1],
             tabs=match[1],
             add_tab=
              function(n,ls)
               {if(ls)
                 {var l=ls[2],x=ls[1];
                  return caml_lessthan(n,x)?[0,n,ls]:[0,x,add_tab(n,l)]}
                return [0,n,0]};
            tabs[1] = add_tab(state[6] - state[9] | 0,tabs[1]);
            return 0}
          return 0;
         case 1:
          var _Ww_=state[2];
          if(_Ww_){var ls=_Ww_[2];state[2] = ls;return 0}
          return 0;
         case 2:
          var _Wx_=state[3];
          if(_Wx_){var ls$0=_Wx_[2];state[3] = ls$0;return 0}
          return 0;
         case 3:
          var _Wy_=state[2];
          if(_Wy_)
           {var match$0=_Wy_[1],width=match$0[2];
            return break_line(state,width)}
          return pp_output_newline(state);
         case 4:
          var _Wz_=state[10] !== (state[6] - state[9] | 0)?1:0;
          return _Wz_?pp_skip_token(state):_Wz_;
         default:
          var _WA_=state[5];
          if(_WA_)
           {var
             tags=_WA_[2],
             tag_name=_WA_[1],
             marker=caml_call1(state[25],tag_name);
            pp_output_string(state,marker);
            state[5] = tags;
            return 0}
          return 0}
      else
       switch(param[0])
        {case 0:
          var s=param[1];
          state[9] = state[9] - size | 0;
          pp_output_string(state,s);
          state[11] = 0;
          return 0;
         case 1:
          var off=param[2],n=param[1],_WB_=state[2];
          if(_WB_)
           {var match$1=_WB_[1],width$0=match$1[2],ty=match$1[1];
            switch(ty)
             {case 0:return break_same_line(state,n);
              case 1:return break_new_line(state,off,width$0);
              case 2:return break_new_line(state,off,width$0);
              case 3:
               return state[9] < size
                       ?break_new_line(state,off,width$0)
                       :break_same_line(state,n);
              case 4:
               return state[11]
                       ?break_same_line(state,n)
                       :state[9] < size
                         ?break_new_line(state,off,width$0)
                         :((state[6] - width$0 | 0) + off | 0) < state[10]
                           ?break_new_line(state,off,width$0)
                           :break_same_line(state,n);
              default:return break_same_line(state,n)}}
          return 0;
         case 2:
          var
           off$0=param[2],
           n$0=param[1],
           insertion_point=state[6] - state[9] | 0,
           _WC_=state[3];
          if(_WC_)
           {var
             match$2=_WC_[1],
             tabs$0=match$2[1],
             find=
              function(n,param)
               {var param$0=param;
                for(;;)
                 {if(param$0)
                   {var l=param$0[2],x=param$0[1];
                    if(caml_greaterequal(x,n))return x;
                    var param$0=l;
                    continue}
                  throw Not_found}},
             _WD_=tabs$0[1];
            if(_WD_)
             {var x=_WD_[1];
              try
               {var _WE_=find(insertion_point,tabs$0[1]),x$0=_WE_}
              catch(_WF_)
               {_WF_ = caml_wrap_exception(_WF_);
                if(_WF_ !== Not_found)throw _WF_;
                var x$0=x}
              var tab=x$0}
            else
             var tab=insertion_point;
            var offset=tab - insertion_point | 0;
            return 0 <= offset
                    ?break_same_line(state,offset + n$0 | 0)
                    :break_new_line(state,tab + off$0 | 0,state[6])}
          return 0;
         case 3:
          var
           ty$0=param[2],
           off$1=param[1],
           insertion_point$0=state[6] - state[9] | 0;
          if(state[8] < insertion_point$0)pp_force_break_line(state);
          var
           offset$0=state[9] - off$1 | 0,
           bl_type=1 === ty$0?1:state[9] < size?ty$0:5;
          state[2] = [0,[0,bl_type,offset$0],state[2]];
          return 0;
         case 4:var tbox=param[1];state[3] = [0,tbox,state[3]];return 0;
         default:
          var tag_name$0=param[1],marker$0=caml_call1(state[24],tag_name$0);
          pp_output_string(state,marker$0);
          state[5] = [0,tag_name$0,state[5]];
          return 0}}
    function advance_loop(state)
     {for(;;)
       {var _Wr_=state[28][2];
        if(_Wr_)
         {var
           x=_Wr_[1],
           size=x[1],
           len=x[3],
           tok=x[2],
           _Ws_=size < 0?1:0,
           _Wt_=_Ws_?(state[13] - state[12] | 0) < state[9]?1:0:_Ws_,
           _Wu_=1 - _Wt_;
          if(_Wu_)
           {take_queue(state[28]);
            var size$0=0 <= size?size:pp_infinity;
            format_pp_token(state,size$0,tok);
            state[12] = len + state[12] | 0;
            continue}
          return _Wu_}
        throw Empty_queue}}
    function advance_left(state)
     {try
       {var _Wp_=advance_loop(state);return _Wp_}
      catch(_Wq_)
       {_Wq_ = caml_wrap_exception(_Wq_);
        if(_Wq_ === Empty_queue)return 0;
        throw _Wq_}}
    function enqueue_advance(state,tok)
     {pp_enqueue(state,tok);return advance_left(state)}
    function enqueue_string_as(state,size,s)
     {return enqueue_advance(state,[0,size,[0,s],size])}
    var q_elem=[0,-1,_cP_,0],scan_stack_bottom=[0,[0,-1,q_elem],0];
    function clear_scan_stack(state){state[1] = scan_stack_bottom;return 0}
    function set_size(state,ty)
     {var _Wl_=state[1];
      if(_Wl_)
       {var
         match=_Wl_[1],
         queue_elem=match[2],
         left_tot=match[1],
         size=queue_elem[1],
         t=_Wl_[2],
         tok=queue_elem[2];
        if(left_tot < state[12])return clear_scan_stack(state);
        if(typeof tok !== "number")
         switch(tok[0])
          {case 3:
            var
             _Wn_=1 - ty,
             _Wo_=
              _Wn_?(queue_elem[1] = state[13] + size | 0,state[1] = t,0):_Wn_;
            return _Wo_;
           case 1:
           case 2:
            var
             _Wm_=
              ty?(queue_elem[1] = state[13] + size | 0,state[1] = t,0):ty;
            return _Wm_
           }
        return 0}
      return 0}
    function scan_push(state,b,tok)
     {pp_enqueue(state,tok);
      if(b)set_size(state,1);
      state[1] = [0,[0,state[13],tok],state[1]];
      return 0}
    function pp_open_box_gen(state,indent,br_ty)
     {state[14] = state[14] + 1 | 0;
      if(state[14] < state[15])
       {var elem=[0,- state[13] | 0,[3,indent,br_ty],0];
        return scan_push(state,0,elem)}
      var _Wj_=state[14] === state[15]?1:0;
      if(_Wj_)
       {var _Wk_=state[16],len=caml_ml_string_length(_Wk_);
        return enqueue_string_as(state,len,_Wk_)}
      return _Wj_}
    function pp_close_box(state,param)
     {var _Wh_=1 < state[14]?1:0;
      if(_Wh_)
       {if(state[14] < state[15])
         {pp_enqueue(state,[0,0,1,0]);set_size(state,1);set_size(state,0)}
        state[14] = state[14] - 1 | 0;
        var _Wi_=0}
      else
       var _Wi_=_Wh_;
      return _Wi_}
    function pp_open_tag(state,tag_name)
     {if(state[22])
       {state[4] = [0,tag_name,state[4]];caml_call1(state[26],tag_name)}
      var _Wg_=state[23];
      return _Wg_?pp_enqueue(state,[0,0,[5,tag_name],0]):_Wg_}
    function pp_close_tag(state,param)
     {if(state[23])pp_enqueue(state,[0,0,5,0]);
      var _Wd_=state[22];
      if(_Wd_)
       {var _We_=state[4];
        if(_We_)
         {var tags=_We_[2],tag_name=_We_[1];
          caml_call1(state[27],tag_name);
          state[4] = tags;
          return 0}
        var _Wf_=0}
      else
       var _Wf_=_Wd_;
      return _Wf_}
    function pp_rinit(state)
     {state[12] = 1;
      state[13] = 1;
      var _Wc_=state[28];
      _Wc_[1] = 0;
      _Wc_[2] = 0;
      clear_scan_stack(state);
      state[2] = 0;
      state[3] = 0;
      state[4] = 0;
      state[5] = 0;
      state[10] = 0;
      state[14] = 0;
      state[9] = state[6];
      return pp_open_box_gen(state,0,3)}
    function pp_flush_queue(state,b)
     {var _Wb_=state[4];
      iter$0(function(param){return pp_close_tag(state,0)},_Wb_);
      for(;;)
       {if(1 < state[14]){pp_close_box(state,0);continue}
        state[13] = pp_infinity;
        advance_left(state);
        if(b)pp_output_newline(state);
        return pp_rinit(state)}}
    function pp_print_as_size(state,size,s)
     {var _Wa_=state[14] < state[15]?1:0;
      return _Wa_?enqueue_string_as(state,size,s):_Wa_}
    function pp_print_as(state,isize,s)
     {return pp_print_as_size(state,isize,s)}
    function pp_print_string(state,s)
     {return pp_print_as(state,caml_ml_string_length(s),s)}
    function pp_print_char(state,c){return pp_print_as(state,1,make$0(1,c))}
    function pp_print_newline(state,param)
     {pp_flush_queue(state,1);return caml_call1(state[18],0)}
    function pp_print_flush(state,param)
     {pp_flush_queue(state,0);return caml_call1(state[18],0)}
    function pp_limit(n){return n < 1000000010?n:1000000009}
    function pp_set_margin(state,n$1)
     {var _V$_=1 <= n$1?1:0;
      if(_V$_)
       {var n$2=pp_limit(n$1);
        state[6] = n$2;
        var
         new_max_indent=
          state[8] <= state[6]
           ?state[8]
           :max(max(state[6] - state[7] | 0,state[6] / 2 | 0),1),
         n$0=state[6] - new_max_indent | 0,
         _V__=1 <= n$0?1:0;
        if(_V__)
         {var n=pp_limit(n$0);
          state[7] = n;
          state[8] = state[6] - state[7] | 0;
          return pp_rinit(state)}
        return _V__}
      return _V$_}
    var blank_line=make$0(80,32);
    function display_blanks(state,n)
     {var n$0=n;
      for(;;)
       {var _V9_=0 < n$0?1:0;
        if(_V9_)
         {if(80 < n$0)
           {caml_call3(state[17],blank_line,0,80);
            var n$1=n$0 - 80 | 0,n$0=n$1;
            continue}
          return caml_call3(state[17],blank_line,0,n$0)}
        return _V9_}}
    function default_pp_mark_open_tag(s){return symbol(_cS_,symbol(s,_cR_))}
    function default_pp_mark_close_tag(s){return symbol(_cU_,symbol(s,_cT_))}
    function default_pp_print_open_tag(_V8_){return 0}
    function default_pp_print_close_tag(_V7_){return 0}
    function make_formatter(output,flush)
     {function j(_V6_){return 0}
      function i(_V5_){return 0}
      function h(_V4_){return 0}
      var pp_queue=[0,0,0],sys_tok=[0,-1,_cV_,0];
      add_queue(sys_tok,pp_queue);
      var
       sys_scan_stack=[0,[0,1,sys_tok],scan_stack_bottom],
       ppf=
        [0,
         sys_scan_stack,
         0,
         0,
         0,
         0,
         78,
         10,
         68,
         78,
         0,
         1,
         1,
         1,
         1,
         max_int,
         _cW_,
         output,
         flush,
         h,
         i,
         j,
         0,
         0,
         default_pp_mark_open_tag,
         default_pp_mark_close_tag,
         default_pp_print_open_tag,
         default_pp_print_close_tag,
         pp_queue];
      ppf[19] = function(_V3_){return caml_call3(ppf[17],_cQ_,0,1)};
      ppf[20] = function(_V2_){return display_blanks(ppf,_V2_)};
      ppf[21] = function(_V1_){return display_blanks(ppf,_V1_)};
      return ppf}
    function formatter_of_out_channel(oc)
     {function _VX_(param){return caml_ml_flush(oc)}
      return make_formatter
              (function(_VY_,_VZ_,_V0_)
                {return output_substring(oc,_VY_,_VZ_,_V0_)},
               _VX_)}
    function formatter_of_buffer(b)
     {function _VS_(_VW_){return 0}
      return make_formatter
              (function(s,offset,len)
                {var _VT_=offset < 0?1:0;
                 if(_VT_)
                  var _VU_=_VT_;
                 else
                  var
                   _VV_=len < 0?1:0,
                   _VU_=
                    _VV_
                    ||
                    ((caml_ml_string_length(s) - len | 0) < offset?1:0);
                 if(_VU_)invalid_arg(_ab_);
                 var new_position=b[2] + len | 0;
                 if(b[3] < new_position)resize(b,len);
                 blit$0(s,offset,b[1],b[2],len);
                 b[2] = new_position;
                 return 0},
               _VS_)}
    var pp_buffer_size=512;
    function pp_make_buffer(param){return create(pp_buffer_size)}
    var
     stdbuf=pp_make_buffer(0),
     fmt=formatter_of_out_channel(stdout),
     fmt$0=formatter_of_out_channel(stderr);
    formatter_of_buffer(stdbuf);
    function print_flush(_VR_){return pp_print_flush(fmt,_VR_)}
    function compute_tag(output,tag_acc)
     {var b=create(16),ppf=formatter_of_buffer(b);
      caml_call2(output,ppf,tag_acc);
      pp_print_flush(ppf,0);
      var len=b[2];
      if(2 <= len)
       {var len$0=len - 2 | 0,ofs=1;
        if(0 <= len$0 && ! ((b[2] - len$0 | 0) < 1))
         return sub_string(b[1],ofs,len$0);
        return invalid_arg(_$_)}
      return contents(b)}
    function output_formatting_lit(ppf,fmting_lit)
     {if(typeof fmting_lit === "number")
       switch(fmting_lit)
        {case 0:return pp_close_box(ppf,0);
         case 1:return pp_close_tag(ppf,0);
         case 2:return pp_print_flush(ppf,0);
         case 3:
          var _VP_=ppf[14] < ppf[15]?1:0;
          return _VP_?enqueue_advance(ppf,[0,0,3,0]):_VP_;
         case 4:return pp_print_newline(ppf,0);
         case 5:return pp_print_char(ppf,64);
         default:return pp_print_char(ppf,37)}
      else
       switch(fmting_lit[0])
        {case 0:
          var
           offset=fmting_lit[3],
           width=fmting_lit[2],
           _VQ_=ppf[14] < ppf[15]?1:0;
          if(_VQ_)
           {var elem=[0,- ppf[13] | 0,[1,width,offset],width];
            return scan_push(ppf,1,elem)}
          return _VQ_;
         case 1:return 0;
         default:
          var c=fmting_lit[1];
          pp_print_char(ppf,64);
          return pp_print_char(ppf,c)}}
    function output_acc$0(ppf,acc)
     {var switch$0=0;
      if(typeof acc === "number")
       return 0;
      else
       switch(acc[0])
        {case 0:
          var f=acc[2],p=acc[1];
          output_acc$0(ppf,p);
          return output_formatting_lit(ppf,f);
         case 1:
          var _VF_=acc[2],_VG_=acc[1];
          if(0 === _VF_[0])
           {var acc$0=_VF_[1];
            output_acc$0(ppf,_VG_);
            return pp_open_tag(ppf,compute_tag(output_acc$0,acc$0))}
          var acc$1=_VF_[1];
          output_acc$0(ppf,_VG_);
          var
           match=open_box_of_string(compute_tag(output_acc$0,acc$1)),
           bty=match[2],
           indent=match[1];
          return pp_open_box_gen(ppf,indent,bty);
         case 2:
          var _VH_=acc[1],switch$1=0;
          if(typeof _VH_ !== "number" && 0 === _VH_[0])
           {var _VI_=_VH_[2],switch$2=0;
            if(typeof _VI_ !== "number" && 1 === _VI_[0])
             {var s$0=acc[2],size=_VI_[2],p$1=_VH_[1];
              switch$1 = 1;
              switch$2 = 1}}
          if(! switch$1){var s=acc[2],p$0=_VH_;switch$0 = 2}
          break;
         case 3:
          var _VJ_=acc[1],switch$3=0;
          if(typeof _VJ_ !== "number" && 0 === _VJ_[0])
           {var _VK_=_VJ_[2],switch$4=0;
            if(typeof _VK_ !== "number" && 1 === _VK_[0])
             {var c$0=acc[2],size$0=_VK_[2],p$3=_VJ_[1];
              switch$0 = 1;
              switch$3 = 1;
              switch$4 = 1}}
          if(! switch$3){var c=acc[2],p$2=_VJ_;switch$0 = 3}
          break;
         case 4:
          var _VL_=acc[1],switch$5=0;
          if(typeof _VL_ !== "number" && 0 === _VL_[0])
           {var _VM_=_VL_[2],switch$6=0;
            if(typeof _VM_ !== "number" && 1 === _VM_[0])
             {var s$0=acc[2],size=_VM_[2],p$1=_VL_[1];
              switch$5 = 1;
              switch$6 = 1}}
          if(! switch$5){var s=acc[2],p$0=_VL_;switch$0 = 2}
          break;
         case 5:
          var _VN_=acc[1],switch$7=0;
          if(typeof _VN_ === "number" || ! (0 === _VN_[0]))
           switch$7 = 1;
          else
           {var _VO_=_VN_[2],switch$8=0;
            if(typeof _VO_ !== "number" && 1 === _VO_[0])
             {var c$0=acc[2],size$0=_VO_[2],p$3=_VN_[1];
              switch$0 = 1;
              switch$8 = 1}
            if(! switch$8)switch$7 = 1}
          if(switch$7){var c=acc[2],p$2=_VN_;switch$0 = 3}
          break;
         case 6:
          var f$0=acc[2],p$4=acc[1];
          output_acc$0(ppf,p$4);
          return caml_call1(f$0,ppf);
         case 7:
          var p$5=acc[1];output_acc$0(ppf,p$5);return pp_print_flush(ppf,0);
         default:
          var msg=acc[2],p$6=acc[1];
          output_acc$0(ppf,p$6);
          return invalid_arg(msg)}
      switch(switch$0)
       {case 0:output_acc$0(ppf,p$1);return pp_print_as_size(ppf,size,s$0);
        case 1:
         output_acc$0(ppf,p$3);
         return pp_print_as_size(ppf,size$0,make$0(1,c$0));
        case 2:output_acc$0(ppf,p$0);return pp_print_string(ppf,s);
        default:output_acc$0(ppf,p$2);return pp_print_char(ppf,c)}}
    function strput_acc$0(ppf,acc)
     {var switch$0=0;
      if(typeof acc === "number")
       return 0;
      else
       switch(acc[0])
        {case 0:
          var f=acc[2],p=acc[1];
          strput_acc$0(ppf,p);
          return output_formatting_lit(ppf,f);
         case 1:
          var _Vt_=acc[2],_Vu_=acc[1];
          if(0 === _Vt_[0])
           {var acc$0=_Vt_[1];
            strput_acc$0(ppf,_Vu_);
            return pp_open_tag(ppf,compute_tag(strput_acc$0,acc$0))}
          var acc$1=_Vt_[1];
          strput_acc$0(ppf,_Vu_);
          var
           match=open_box_of_string(compute_tag(strput_acc$0,acc$1)),
           bty=match[2],
           indent=match[1];
          return pp_open_box_gen(ppf,indent,bty);
         case 2:
          var _Vv_=acc[1],switch$1=0;
          if(typeof _Vv_ !== "number" && 0 === _Vv_[0])
           {var _Vw_=_Vv_[2],switch$2=0;
            if(typeof _Vw_ !== "number" && 1 === _Vw_[0])
             {var s$0=acc[2],size=_Vw_[2],p$1=_Vv_[1];
              switch$1 = 1;
              switch$2 = 1}}
          if(! switch$1){var s=acc[2],p$0=_Vv_;switch$0 = 2}
          break;
         case 3:
          var _Vx_=acc[1],switch$3=0;
          if(typeof _Vx_ !== "number" && 0 === _Vx_[0])
           {var _Vy_=_Vx_[2],switch$4=0;
            if(typeof _Vy_ !== "number" && 1 === _Vy_[0])
             {var c$0=acc[2],size$0=_Vy_[2],p$3=_Vx_[1];
              switch$0 = 1;
              switch$3 = 1;
              switch$4 = 1}}
          if(! switch$3){var c=acc[2],p$2=_Vx_;switch$0 = 3}
          break;
         case 4:
          var _Vz_=acc[1],switch$5=0;
          if(typeof _Vz_ !== "number" && 0 === _Vz_[0])
           {var _VA_=_Vz_[2],switch$6=0;
            if(typeof _VA_ !== "number" && 1 === _VA_[0])
             {var s$0=acc[2],size=_VA_[2],p$1=_Vz_[1];
              switch$5 = 1;
              switch$6 = 1}}
          if(! switch$5){var s=acc[2],p$0=_Vz_;switch$0 = 2}
          break;
         case 5:
          var _VB_=acc[1],switch$7=0;
          if(typeof _VB_ === "number" || ! (0 === _VB_[0]))
           switch$7 = 1;
          else
           {var _VC_=_VB_[2],switch$8=0;
            if(typeof _VC_ !== "number" && 1 === _VC_[0])
             {var c$0=acc[2],size$0=_VC_[2],p$3=_VB_[1];
              switch$0 = 1;
              switch$8 = 1}
            if(! switch$8)switch$7 = 1}
          if(switch$7){var c=acc[2],p$2=_VB_;switch$0 = 3}
          break;
         case 6:
          var _VD_=acc[1];
          if(typeof _VD_ !== "number" && 0 === _VD_[0])
           {var _VE_=_VD_[2];
            if(typeof _VE_ !== "number" && 1 === _VE_[0])
             {var f$1=acc[2],size$1=_VE_[2],p$4=_VD_[1];
              strput_acc$0(ppf,p$4);
              return pp_print_as_size(ppf,size$1,caml_call1(f$1,0))}}
          var f$0=acc[2];
          strput_acc$0(ppf,_VD_);
          return pp_print_string(ppf,caml_call1(f$0,0));
         case 7:
          var p$5=acc[1];strput_acc$0(ppf,p$5);return pp_print_flush(ppf,0);
         default:
          var msg=acc[2],p$6=acc[1];
          strput_acc$0(ppf,p$6);
          return invalid_arg(msg)}
      switch(switch$0)
       {case 0:strput_acc$0(ppf,p$1);return pp_print_as_size(ppf,size,s$0);
        case 1:
         strput_acc$0(ppf,p$3);
         return pp_print_as_size(ppf,size$0,make$0(1,c$0));
        case 2:strput_acc$0(ppf,p$0);return pp_print_string(ppf,s);
        default:strput_acc$0(ppf,p$2);return pp_print_char(ppf,c)}}
    function fprintf$0(ppf)
     {return function(param)
       {var fmt=param[1],_Vs_=0;
        return make_printf
                (function(ppf,acc){output_acc$0(ppf,acc);return 0},
                 ppf,
                 _Vs_,
                 fmt)}}
    function ksprintf(k,param)
     {var fmt=param[1],buf=pp_make_buffer(0),ppf=formatter_of_buffer(buf);
      function k$0(param,acc)
       {strput_acc$0(ppf,acc);
        pp_flush_queue(ppf,0);
        var s=contents(buf);
        buf[2] = 0;
        buf[1] = buf[4];
        buf[3] = caml_ml_bytes_length(buf[1]);
        return caml_call1(k,s)}
      return make_printf(k$0,0,0,fmt)}
    function sprintf$0(fmt){return ksprintf(function(s){return s},fmt)}
    at_exit(print_flush);
    function register_exception(name,exn)
     {var slot=caml_obj_tag(exn) === 248?exn:exn[1];
      return caml_register_named_value(name,slot)}
    function generic_basename(is_dir_sep,current_dir_name,name)
     {if(caml_string_equal(name,_cX_))return current_dir_name;
      var n$3=caml_ml_string_length(name) - 1 | 0,n=n$3;
      for(;;)
       {if(0 <= n)
         {if(caml_call2(is_dir_sep,name,n)){var n$0=n - 1 | 0,n=n$0;continue}
          var p=n + 1 | 0,n$1=n;
          for(;;)
           {if(0 <= n$1)
             {if(caml_call2(is_dir_sep,name,n$1))
               return sub$0(name,n$1 + 1 | 0,(p - n$1 | 0) - 1 | 0);
              var n$2=n$1 - 1 | 0,n$1=n$2;
              continue}
            return sub$0(name,0,p)}}
        return sub$0(name,0,1)}}
    function generic_dirname(is_dir_sep,current_dir_name,name)
     {if(caml_string_equal(name,_cY_))return current_dir_name;
      var n$5=caml_ml_string_length(name) - 1 | 0,n=n$5;
      for(;;)
       {if(0 <= n)
         {if(caml_call2(is_dir_sep,name,n)){var n$0=n - 1 | 0,n=n$0;continue}
          var n$1=n;
          for(;;)
           {if(0 <= n$1)
             {if(caml_call2(is_dir_sep,name,n$1))
               {var n$3=n$1;
                for(;;)
                 {if(0 <= n$3)
                   {if(caml_call2(is_dir_sep,name,n$3))
                     {var n$4=n$3 - 1 | 0,n$3=n$4;continue}
                    return sub$0(name,0,n$3 + 1 | 0)}
                  return sub$0(name,0,1)}}
              var n$2=n$1 - 1 | 0,n$1=n$2;
              continue}
            return current_dir_name}}
        return sub$0(name,0,1)}}
    function is_dir_sep(s,i){return 47 === caml_string_get(s,i)?1:0}
    try
     {var _BK_=caml_sys_getenv(_BJ_),temp_dir_name=_BK_}
    catch(_Vr_)
     {_Vr_ = caml_wrap_exception(_Vr_);
      if(_Vr_ !== Not_found)throw _Vr_;
      var temp_dir_name=_cZ_}
    function quote(s)
     {var l=caml_ml_string_length(s),b=create(l + 20 | 0);
      add_char(b,39);
      var _Vp_=l - 1 | 0,_Vo_=0;
      if(! (_Vp_ < 0))
       {var i=_Vo_;
        for(;;)
         {if(39 === caml_string_get(s,i))
           add_string(b,quotequote);
          else
           add_char(b,caml_string_get(s,i));
          var _Vq_=i + 1 | 0;
          if(_Vp_ !== i){var i=_Vq_;continue}
          break}}
      add_char(b,39);
      return contents(b)}
    function basename(_Vn_)
     {return generic_basename(is_dir_sep,current_dir_name,_Vn_)}
    function dirname(_Vm_)
     {return generic_dirname(is_dir_sep,current_dir_name,_Vm_)}
    function is_dir_sep$0(s,i)
     {var c=caml_string_get(s,i),_Vj_=47 === c?1:0;
      if(_Vj_)
       var _Vk_=_Vj_;
      else
       var _Vl_=92 === c?1:0,_Vk_=_Vl_ || (58 === c?1:0);
      return _Vk_}
    function is_relative(n)
     {var
       _Vd_=caml_ml_string_length(n) < 1?1:0,
       _Ve_=_Vd_ || (47 !== caml_string_get(n,0)?1:0);
      if(_Ve_)
       {var
         _Vf_=caml_ml_string_length(n) < 1?1:0,
         _Vg_=_Vf_ || (92 !== caml_string_get(n,0)?1:0);
        if(_Vg_)
         var
          _Vh_=caml_ml_string_length(n) < 2?1:0,
          _Vi_=_Vh_ || (58 !== caml_string_get(n,1)?1:0);
        else
         var _Vi_=_Vg_}
      else
       var _Vi_=_Ve_;
      return _Vi_}
    function is_implicit(n)
     {var _U6_=is_relative(n);
      if(_U6_)
       {var
         _U7_=caml_ml_string_length(n) < 2?1:0,
         _U8_=_U7_ || caml_string_notequal(sub$0(n,0,2),_c3_);
        if(_U8_)
         {var
           _U9_=caml_ml_string_length(n) < 2?1:0,
           _U__=_U9_ || caml_string_notequal(sub$0(n,0,2),_c2_);
          if(_U__)
           {var
             _U$_=caml_ml_string_length(n) < 3?1:0,
             _Va_=_U$_ || caml_string_notequal(sub$0(n,0,3),_c1_);
            if(_Va_)
             var
              _Vb_=caml_ml_string_length(n) < 3?1:0,
              _Vc_=_Vb_ || caml_string_notequal(sub$0(n,0,3),_c0_);
            else
             var _Vc_=_Va_}
          else
           var _Vc_=_U__}
        else
         var _Vc_=_U8_}
      else
       var _Vc_=_U6_;
      return _Vc_}
    function check_suffix(name,suff)
     {var _U3_=caml_ml_string_length(suff) <= caml_ml_string_length(name)?1:0;
      if(_U3_)
       var
        s=
         sub$0
          (name,
           caml_ml_string_length(name) - caml_ml_string_length(suff) | 0,
           caml_ml_string_length(suff)),
        _U4_=lowercase_ascii$0(suff),
        _U5_=caml_string_equal(lowercase_ascii$0(s),_U4_);
      else
       var _U5_=_U3_;
      return _U5_}
    try
     {var _BI_=caml_sys_getenv(_BH_),temp_dir_name$0=_BI_}
    catch(_U2_)
     {_U2_ = caml_wrap_exception(_U2_);
      if(_U2_ !== Not_found)throw _U2_;
      var temp_dir_name$0=_c4_}
    function quote$0(s)
     {var l=caml_ml_string_length(s),b=create(l + 20 | 0);
      add_char(b,34);
      function add_bs(n)
       {var _U0_=1;
        if(! (n < 1))
         {var j=_U0_;
          for(;;)
           {add_char(b,92);
            var _U1_=j + 1 | 0;
            if(n !== j){var j=_U1_;continue}
            break}}
        return 0}
      function loop$0(counter,i)
       {var i$0=i;
        for(;;)
         {if(i$0 === l)return add_char(b,34);
          var c=caml_string_get(s,i$0);
          if(34 === c)
           {var _UY_=0;
            if(counter < 50)
             {var counter$1=counter + 1 | 0;
              return loop_bs(counter$1,_UY_,i$0)}
            return caml_trampoline_return(loop_bs,[0,_UY_,i$0])}
          if(92 === c)
           {var _UZ_=0;
            if(counter < 50)
             {var counter$0=counter + 1 | 0;
              return loop_bs(counter$0,_UZ_,i$0)}
            return caml_trampoline_return(loop_bs,[0,_UZ_,i$0])}
          add_char(b,c);
          var i$1=i$0 + 1 | 0,i$0=i$1;
          continue}}
      function loop_bs(counter,n,i)
       {var n$0=n,i$0=i;
        for(;;)
         {if(i$0 === l){add_char(b,34);return add_bs(n$0)}
          var match=caml_string_get(s,i$0);
          if(34 === match)
           {add_bs((2 * n$0 | 0) + 1 | 0);
            add_char(b,34);
            var _UX_=i$0 + 1 | 0;
            if(counter < 50)
             {var counter$1=counter + 1 | 0;return loop$0(counter$1,_UX_)}
            return caml_trampoline_return(loop$0,[0,_UX_])}
          if(92 === match)
           {var i$1=i$0 + 1 | 0,n$1=n$0 + 1 | 0,n$0=n$1,i$0=i$1;continue}
          add_bs(n$0);
          if(counter < 50)
           {var counter$0=counter + 1 | 0;return loop$0(counter$0,i$0)}
          return caml_trampoline_return(loop$0,[0,i$0])}}
      function loop(i){return caml_trampoline(loop$0(0,i))}
      loop(0);
      return contents(b)}
    function drive_and_path(s)
     {var _UT_=2 <= caml_ml_string_length(s)?1:0;
      if(_UT_)
       {var param=caml_string_get(s,0),switch$0=0;
        if(91 <= param)
         {if(! (25 < (param - 97 | 0) >>> 0))switch$0 = 1}
        else
         if(65 <= param)switch$0 = 1;
        var _UU_=switch$0?1:0,_UV_=_UU_?58 === caml_string_get(s,1)?1:0:_UU_}
      else
       var _UV_=_UT_;
      if(_UV_)
       {var _UW_=sub$0(s,2,caml_ml_string_length(s) - 2 | 0);
        return [0,sub$0(s,0,2),_UW_]}
      return [0,_c5_,s]}
    function dirname$0(s)
     {var
       match=drive_and_path(s),
       path=match[2],
       drive=match[1],
       dir=generic_dirname(is_dir_sep$0,current_dir_name$0,path);
      return symbol(drive,dir)}
    function basename$0(s)
     {var match=drive_and_path(s),path=match[2];
      return generic_basename(is_dir_sep$0,current_dir_name$0,path)}
    function basename$1(_US_)
     {return generic_basename(is_dir_sep$0,current_dir_name$1,_US_)}
    function dirname$1(_UR_)
     {return generic_dirname(is_dir_sep$0,current_dir_name$1,_UR_)}
    var switch$0=0;
    if(caml_string_notequal(os_type,_c6_))
     if(caml_string_notequal(os_type,_c7_))
      {var
        dir_sep$2=dir_sep,
        is_dir_sep$1=is_dir_sep,
        temp_dir_name$1=temp_dir_name,
        basename$2=basename,
        dirname$2=dirname;
       switch$0 = 1}
     else
      var
       _BG_=
        [0,
         current_dir_name$0,
         parent_dir_name,
         dir_sep$0,
         is_dir_sep$0,
         is_relative,
         is_implicit,
         check_suffix,
         temp_dir_name$0,
         quote$0,
         basename$0,
         dirname$0];
    else
     var
      _BG_=
       [0,
        current_dir_name$1,
        parent_dir_name$0,
        dir_sep$1,
        is_dir_sep$0,
        is_relative,
        is_implicit,
        check_suffix,
        temp_dir_name,
        quote,
        basename$1,
        dirname$1];
    if(! switch$0)
     var
      dir_sep$2=_BG_[3],
      is_dir_sep$1=is_dir_sep$0,
      temp_dir_name$1=_BG_[8],
      basename$2=_BG_[10],
      dirname$2=_BG_[11];
    function cc(dirname,filename)
     {var l=caml_ml_string_length(dirname);
      if(0 !== l && ! is_dir_sep$1(dirname,l - 1 | 0))
       return symbol(dirname,symbol(dir_sep$2,filename));
      return symbol(dirname,filename)}
    var prng$0=[246,function(_UQ_){return make_self_init(0)}];
    function temp_file_name(temp_dir,prefix,suffix)
     {var
       _UO_=caml_obj_tag(prng$0),
       _UP_=
        250 === _UO_?prng$0[1]:246 === _UO_?force_lazy_block(prng$0):prng$0,
       rnd=bits(_UP_) & 16777215;
      return cc(temp_dir,caml_call3(sprintf(_c8_),prefix,rnd,suffix))}
    var
     global=joo_global_object,
     null$0=null,
     undefined$0=undefined,
     array_constructor=global.Array,
     Error$0=[248,_c__,caml_fresh_oo_id(0)];
    register_exception(_c$_,[0,Error$0,{}]);
    (function(exn){throw exn});
    register_printer
     (function(param)
       {if(param[1] === Error$0)
         {var e=param[2];return [0,caml_string_of_jsstring(e.toString())]}
        return 0});
    register_printer
     (function(e)
       {return e instanceof array_constructor
                ?0
                :[0,caml_string_of_jsstring(e.toString())]});
    function set_onmessage(handler)
     {if(global.onmessage === undefined$0)invalid_arg(_da_);
      function js_handler(ev){return caml_call1(handler,ev.data)}
      return global.onmessage = caml_js_wrap_callback(js_handler)}
    function post_message(msg)
     {if(global.postMessage === undefined$0)invalid_arg(_db_);
      return global.postMessage(msg)}
    function update_file(name,content)
     {var oc=open_out(name);output_string(oc,content);return close_out(oc)}
    var Unix_error=[248,_dc_,caml_fresh_oo_id(0)];
    register_exception(_df_,[0,Unix_error,0,_de_,_dd_]);
    register_printer
     (function(param)
       {if(param[1] === Unix_error)
         {var s=param[4],s$0=param[3],e=param[2];
          if(typeof e === "number")
           {var _UN_=e;
            if(34 <= _UN_)
             switch(_UN_)
              {case 34:var msg=_dP_;break;
               case 35:var msg=_dQ_;break;
               case 36:var msg=_dR_;break;
               case 37:var msg=_dS_;break;
               case 38:var msg=_dT_;break;
               case 39:var msg=_dU_;break;
               case 40:var msg=_dV_;break;
               case 41:var msg=_dW_;break;
               case 42:var msg=_dX_;break;
               case 43:var msg=_dY_;break;
               case 44:var msg=_dZ_;break;
               case 45:var msg=_d0_;break;
               case 46:var msg=_d1_;break;
               case 47:var msg=_d2_;break;
               case 48:var msg=_d3_;break;
               case 49:var msg=_d4_;break;
               case 50:var msg=_d5_;break;
               case 51:var msg=_d6_;break;
               case 52:var msg=_d7_;break;
               case 53:var msg=_d8_;break;
               case 54:var msg=_d9_;break;
               case 55:var msg=_d__;break;
               case 56:var msg=_d$_;break;
               case 57:var msg=_ea_;break;
               case 58:var msg=_eb_;break;
               case 59:var msg=_ec_;break;
               case 60:var msg=_ed_;break;
               case 61:var msg=_ee_;break;
               case 62:var msg=_ef_;break;
               case 63:var msg=_eg_;break;
               case 64:var msg=_eh_;break;
               case 65:var msg=_ei_;break;
               case 66:var msg=_ej_;break;
               default:var msg=_ek_}
            else
             switch(_UN_)
              {case 0:var msg=_dg_;break;
               case 1:var msg=_di_;break;
               case 2:var msg=_dj_;break;
               case 3:var msg=_dk_;break;
               case 4:var msg=_dl_;break;
               case 5:var msg=_dm_;break;
               case 6:var msg=_dn_;break;
               case 7:var msg=_do_;break;
               case 8:var msg=_dp_;break;
               case 9:var msg=_dq_;break;
               case 10:var msg=_dr_;break;
               case 11:var msg=_ds_;break;
               case 12:var msg=_dt_;break;
               case 13:var msg=_du_;break;
               case 14:var msg=_dv_;break;
               case 15:var msg=_dw_;break;
               case 16:var msg=_dx_;break;
               case 17:var msg=_dy_;break;
               case 18:var msg=_dz_;break;
               case 19:var msg=_dA_;break;
               case 20:var msg=_dB_;break;
               case 21:var msg=_dC_;break;
               case 22:var msg=_dD_;break;
               case 23:var msg=_dE_;break;
               case 24:var msg=_dF_;break;
               case 25:var msg=_dG_;break;
               case 26:var msg=_dH_;break;
               case 27:var msg=_dI_;break;
               case 28:var msg=_dJ_;break;
               case 29:var msg=_dK_;break;
               case 30:var msg=_dL_;break;
               case 31:var msg=_dM_;break;
               case 32:var msg=_dN_;break;
               default:var msg=_dO_}}
          else
           var x=e[1],msg=caml_call1(sprintf(_el_),x);
          return [0,caml_call3(sprintf(_dh_),msg,s$0,s)]}
        return 0});
    unix_inet_addr_of_string(_em_);
    unix_inet_addr_of_string(_en_);
    var error=2;
    try
     {unix_inet_addr_of_string(_BF_)}
    catch(_UM_)
     {_UM_ = caml_wrap_exception(_UM_);if(_UM_[1] !== Failure)throw _UM_}
    try
     {unix_inet_addr_of_string(_BE_)}
    catch(_UL_)
     {_UL_ = caml_wrap_exception(_UL_);if(_UL_[1] !== Failure)throw _UL_}
    function file_descr_not_standard(fd)
     {var fd$0=fd;
      for(;;)
       {if(3 <= fd$0)return fd$0;var fd$1=unix_dup(0,fd$0),fd$0=fd$1;continue}}
    function safe_close(fd)
     {try
       {var _UJ_=unix_close(fd);return _UJ_}
      catch(_UK_)
       {_UK_ = caml_wrap_exception(_UK_);
        if(_UK_[1] === Unix_error)return 0;
        throw _UK_}}
    function perform_redirections(new_stdin,new_stdout,new_stderr)
     {var
       new_stdin$0=file_descr_not_standard(new_stdin),
       new_stdout$0=file_descr_not_standard(new_stdout),
       new_stderr$0=file_descr_not_standard(new_stderr);
      unix_dup2(_eo_,new_stdin$0,0);
      unix_dup2(_ep_,new_stdout$0,1);
      unix_dup2(_eq_,new_stderr$0,2);
      safe_close(new_stdin$0);
      safe_close(new_stdout$0);
      return safe_close(new_stderr$0)}
    var popen_processes=create$0(0,7);
    function open_process(cmd)
     {var match=unix_pipe(_es_,0),in_write=match[2],in_read=match[1];
      try
       {var match$0=unix_pipe(_et_,0)}
      catch(e)
       {e = caml_wrap_exception(e);
        unix_close(in_read);
        unix_close(in_write);
        throw e}
      var
       out_write=match$0[2],
       out_read=match$0[1],
       inchan=caml_ml_open_descriptor_in(in_read),
       outchan=caml_ml_open_descriptor_out(out_write);
      try
       {var proc=[0,inchan,outchan],id=unix_fork(0);
        if(0 === id)
         {perform_redirections(out_read,in_write,error);
          var argv=[0,shell,_er_,cmd];
          try {unix_execv(shell,argv)}catch(_UI_){caml_sys_exit(127)}}
        else
         add(popen_processes,proc,id)}
      catch(e)
       {e = caml_wrap_exception(e);
        unix_close(out_read);
        unix_close(out_write);
        unix_close(in_read);
        unix_close(in_write);
        throw e}
      unix_close(out_read);
      unix_close(in_write);
      return [0,inchan,outchan]}
    function close_process(param)
     {var outchan=param[2],inchan=param[1],proc=[0,inchan,outchan];
      try
       {var pid=find(popen_processes,proc);remove(popen_processes,proc)}
      catch(_UH_)
       {_UH_ = caml_wrap_exception(_UH_);
        if(_UH_ === Not_found)throw [0,Unix_error,3,fun_name,_eu_];
        throw _UH_}
      caml_ml_close_channel(inchan);
      try
       {close_out(outchan)}
      catch(_UG_)
       {_UG_ = caml_wrap_exception(_UG_);if(_UG_[1] !== Sys_error)throw _UG_}
      for(;;)
       {try
         {var _UE_=unix_waitpid(0,pid)}
        catch(_UF_)
         {_UF_ = caml_wrap_exception(_UF_);
          if(_UF_[1] === Unix_error)
           {var _UD_=_UF_[2];
            if(typeof _UD_ === "number" && 11 === _UD_)continue}
          throw _UF_}
        return _UE_[2]}}
    function string_before(s,n){return sub$0(s,0,n)}
    function string_after(s,n)
     {return sub$0(s,n,caml_ml_string_length(s) - n | 0)}
    var full=make(32,255);
    function make_empty(param){return make(32,0)}
    function add$0(s,c)
     {return caml_bytes_set
              (s,
               c >>> 3 | 0,
               chr(caml_bytes_get(s,c >>> 3 | 0) | 1 << (c & 7)))}
    function singleton(c){var s=make_empty(0);add$0(s,c);return s}
    function complement(s)
     {var r=caml_create_bytes(32),i=0;
      for(;;)
       {caml_bytes_set(r,i,chr(caml_bytes_get(s,i) ^ 255));
        var _UC_=i + 1 | 0;
        if(31 !== i){var i=_UC_;continue}
        return r}}
    function union(s1,s2)
     {var r=caml_create_bytes(32),i=0;
      for(;;)
       {var _UA_=caml_bytes_get(s2,i);
        caml_bytes_set(r,i,chr(caml_bytes_get(s1,i) | _UA_));
        var _UB_=i + 1 | 0;
        if(31 !== i){var i=_UB_;continue}
        return r}}
    function disjoint(s1,s2)
     {try
       {var i=0;
        for(;;)
         {var _Ux_=caml_bytes_get(s2,i);
          if(0 !== (caml_bytes_get(s1,i) & _Ux_))throw Exit;
          var _Uy_=i + 1 | 0;
          if(31 !== i){var i=_Uy_;continue}
          var _Uw_=1;
          return _Uw_}}
      catch(_Uz_)
       {_Uz_ = caml_wrap_exception(_Uz_);if(_Uz_ === Exit)return 0;throw _Uz_}}
    function iter$2(fn,s)
     {var i=0;
      for(;;)
       {var c=caml_bytes_get(s,i);
        if(0 !== c)
         {var j=0;
          for(;;)
           {if(0 !== (c & 1 << j))caml_call1(fn,chr((i << 3) + j | 0));
            var _Uv_=j + 1 | 0;
            if(7 !== j){var j=_Uv_;continue}
            break}}
        var _Uu_=i + 1 | 0;
        if(31 !== i){var i=_Uu_;continue}
        return 0}}
    var
     op_CHAR=0,
     op_STRING=2,
     op_CHARCLASS=4,
     op_BOL=5,
     op_EOL=6,
     op_WORDBOUNDARY=7,
     op_BEGGROUP=8,
     op_ENDGROUP=9,
     op_REFGROUP=10,
     op_ACCEPT=11,
     op_SIMPLEOPT=12,
     op_SIMPLESTAR=13,
     op_SIMPLEPLUS=14,
     op_GOTO=15,
     op_PUSHBACK=16,
     op_SETMARK=17,
     op_CHECKPROGRESS=18;
    function instr(opc,arg){return opc | arg << 8}
    function displ(dest,from){return (dest - from | 0) - 1 | 0}
    function p(param$0)
     {var param$1=param$0;
      for(;;)
       if(typeof param$1 === "number")
        switch(param$1){case 0:return 1;case 1:return 1;default:return 1}
       else
        switch(param$1[0])
         {case 0:return 0;
          case 1:var s=param$1[1];return caml_string_equal(s,_ev_);
          case 2:return 0;
          case 3:
           var rl=param$1[1],param=rl;
           for(;;)
            {if(param)
              {var l=param[2],a=param[1],_Us_=p(a);
               if(_Us_){var param=l;continue}
               return _Us_}
             return 1}
          case 4:
           var r2=param$1[2],r1=param$1[1],_Ut_=p(r1);
           if(_Ut_)return _Ut_;
           var param$1=r2;
           continue;
          case 5:return 1;
          case 6:var param$2=param$1[1],param$1=param$2;continue;
          case 7:return 1;
          case 8:var param$3=param$1[2],param$1=param$3;continue;
          default:return 1}}
    function first$0(counter,param)
     {var param$0=param;
      for(;;)
       if(typeof param$0 === "number")
        switch(param$0)
         {case 0:return full;case 1:return full;default:return full}
       else
        switch(param$0[0])
         {case 0:var c=param$0[1];return singleton(c);
          case 1:
           var s=param$0[1];
           return caml_string_equal(s,_ew_)
                   ?full
                   :singleton(caml_string_get(s,0));
          case 2:
           var cmpl=param$0[2],cl=param$0[1];return cmpl?complement(cl):cl;
          case 3:
           var rl=param$0[1];
           if(counter < 50)
            {var counter$0=counter + 1 | 0;return first_seq$0(counter$0,rl)}
           return caml_trampoline_return(first_seq$0,[0,rl]);
          case 4:
           var r2=param$0[2],r1=param$0[1],_Ur_=first(r2);
           return union(first(r1),_Ur_);
          case 5:return full;
          case 6:var param$1=param$0[1],param$0=param$1;continue;
          case 7:return full;
          case 8:var param$2=param$0[2],param$0=param$2;continue;
          default:return full}}
    function first_seq$0(counter,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var _Uo_=param$0[1];
          if(typeof _Uo_ === "number")
           {var param$1=param$0[2],param$0=param$1;continue}
          else
           switch(_Uo_[0])
            {case 5:
              var rl=param$0[2],r=_Uo_[1],_Up_=first_seq(rl);
              return union(first(r),_Up_);
             case 7:
              var rl$0=param$0[2],r$0=_Uo_[1],_Uq_=first_seq(rl$0);
              return union(first(r$0),_Uq_);
             default:
              if(counter < 50)
               {var counter$0=counter + 1 | 0;return first$0(counter$0,_Uo_)}
              return caml_trampoline_return(first$0,[0,_Uo_])}}
        return full}}
    function first(param){return caml_trampoline(first$0(0,param))}
    function first_seq(param){return caml_trampoline(first_seq$0(0,param))}
    function charclass_of_regexp(fold_case,re)
     {var switch$0=0;
      if(typeof re !== "number")
       switch(re[0])
        {case 0:var c=re[1],match=[0,singleton(c),0];switch$0 = 1;break;
         case 2:
          var compl$0=re[2],cl=re[1],match=[0,cl,compl$0];switch$0 = 1;break
         }
      if(switch$0)
       {var compl=match[2],cl1=match[1];
        if(fold_case)
         {var r=make_empty(0);
          iter$2
           (function(c)
             {add$0(r,lowercase(c));
              var switch$0=0;
              if(! (97 <= c) || 122 < c)switch$0 = 1;
              var switch$1=0;
              if(switch$0)
               {var switch$2=0;
                if(224 <= c && ! (246 < c))switch$2 = 1;
                if(! switch$2)
                 {var switch$3=0;
                  if(248 <= c && ! (254 < c))switch$3 = 1;
                  if(! switch$3){var _Un_=c;switch$1 = 1}}}
              if(! switch$1)var _Un_=c - 32 | 0;
              return add$0(r,_Un_)},
            cl1);
          var cl2=r}
        else
         var cl2=cl1;
        var _Um_=compl?complement(cl2):cl2;
        return to_string(_Um_)}
      throw [0,Assert_failure,_ex_]}
    var t=caml_create_bytes(256),i=0;
    for(;;)
     {caml_bytes_set(t,i,lowercase(chr(i)));
      var _BD_=i + 1 | 0;
      if(255 !== i){var i=_BD_;continue}
      to_string(t);
      var
       compare=caml_string_compare,
       StringMap=_Z_([0,compare]),
       flush=
        function(buf)
         {var s=contents(buf[1]);
          buf[1][2] = 0;
          var match=caml_ml_string_length(s);
          if(0 === match)return 0;
          if(1 === match)
           {var _Ul_=buf[2];
            buf[2] = [0,[0,caml_string_get(s,0)],_Ul_];
            return 0}
          buf[2] = [0,[1,s],buf[2]];
          return 0},
       dotclass=complement(singleton(10)),
       regexp=
        function(e)
         {var len=caml_ml_string_length(e),group_counter=[0,1];
          function regexpclass1(start)
           {var c=make_empty(0),i$0=start;
            for(;;)
             {if(len <= i$0)failwith(_eD_);
              if(93 === caml_string_get(e,i$0) && start < i$0)
               {var j=i$0 + 1 | 0;return [0,c,j]}
              var c1=caml_string_get(e,i$0);
              if
               ((i$0 + 2 | 0)
                <
                len
                &&
                45
                ===
                caml_string_get(e,i$0 + 1 | 0)
                &&
                93
                !==
                caml_string_get(e,i$0 + 2 | 0))
               {var c2=caml_string_get(e,i$0 + 2 | 0);
                if(! (c2 < c1))
                 {var i=c1;
                  for(;;)
                   {add$0(c,chr(i));
                    var _Uk_=i + 1 | 0;
                    if(c2 !== i){var i=_Uk_;continue}
                    break}}
                var i$2=i$0 + 3 | 0,i$0=i$2;
                continue}
              add$0(c,c1);
              var i$1=i$0 + 1 | 0,i$0=i$1;
              continue}}
          function regexp1(i)
           {var sb=[0,create(16),0],i$0=i;
            a:
            for(;;)
             {if(! (len <= i$0))
               {var switch$0=0;
                if((i$0 + 2 | 0) <= len && 92 === caml_string_get(e,i$0))
                 {var
                   c$0=caml_string_get(e,i$0 + 1 | 0),
                   _Uh_=124 === c$0?1:0,
                   _Ui_=_Uh_ || (41 === c$0?1:0);
                  if(_Ui_)switch$0 = 1}
                if(! switch$0)
                 {var c$1=caml_string_get(e,i$0);
                  if(36 === c$1)
                   var match=[0,1,i$0 + 1 | 0];
                  else
                   {var switch$1=0;
                    if(91 <= c$1)
                     if(95 <= c$1)
                      switch$1 = 1;
                     else
                      {var switcher$0=c$1 - 91 | 0;
                       switch(switcher$0)
                        {case 0:
                          var i$5=i$0 + 1 | 0,switch$2=0;
                          if(i$5 < len && 94 === caml_string_get(e,i$5))
                           {var
                             match$3=regexpclass1(i$5 + 1 | 0),
                             j$2=match$3[2],
                             c$4=match$3[1],
                             match$1=[0,c$4,1,j$2];
                            switch$2 = 1}
                          if(! switch$2)
                           var
                            match$4=regexpclass1(i$5),
                            j$3=match$4[2],
                            c$5=match$4[1],
                            match$1=[0,c$5,0,j$3];
                          var
                           j$0=match$1[3],
                           compl=match$1[2],
                           c$2=match$1[1],
                           match=[0,[2,c$2,compl],j$0];
                          break;
                         case 1:
                          var i$6=i$0 + 1 | 0;
                          if(len <= i$6)
                           var _Uj_=[0,_eA_,i$6];
                          else
                           {var c$3=caml_string_get(e,i$6),switch$3=0;
                            if(58 <= c$3)
                             if(98 === c$3)
                              var _Uj_=[0,2,i$6 + 1 | 0];
                             else
                              if(124 === c$3)switch$3 = 2;else switch$3 = 1;
                            else
                             {var switcher$1=c$3 - 40 | 0;
                              if(1 < switcher$1 >>> 0)
                               if(9 <= switcher$1)
                                var _Uj_=[0,[9,c$3 - 48 | 0],i$6 + 1 | 0];
                               else
                                switch$3 = 1;
                              else
                               if(0 === switcher$1)
                                {var group_no=group_counter[1];
                                 group_counter[1]++;
                                 var
                                  match$2=regexp0(i$6 + 1 | 0),
                                  j$1=match$2[2],
                                  r$4=match$2[1],
                                  switch$4=0;
                                 if
                                  ((j$1 + 1 | 0)
                                   <
                                   len
                                   &&
                                   92
                                   ===
                                   caml_string_get(e,j$1)
                                   &&
                                   41
                                   ===
                                   caml_string_get(e,j$1 + 1 | 0))
                                  {var _Uj_=[0,[8,group_no,r$4],j$1 + 2 | 0];switch$4 = 1}
                                 if(! switch$4)var _Uj_=failwith(_eC_)}
                               else
                                switch$3 = 2}
                            switch(switch$3)
                             {case 1:var _Uj_=[0,[0,c$3],i$6 + 1 | 0];break;
                              case 2:throw [0,Assert_failure,_eB_]
                              }}
                          var match=_Uj_;
                          break;
                         case 2:switch$1 = 1;break;
                         default:var match=[0,0,i$0 + 1 | 0]}}
                    else
                     if(46 === c$1)
                      var match=[0,[2,dotclass,0],i$0 + 1 | 0];
                     else
                      switch$1 = 1;
                    if(switch$1)var match=[0,[0,c$1],i$0 + 1 | 0]}
                  var j=match[2],r=match[1],r$0=r,i$1=j;
                  for(;;)
                   {if(! (len <= i$1))
                     {var
                       match$0=caml_string_get(e,i$1),
                       switcher=match$0 - 42 | 0;
                      if(! (1 < switcher >>> 0))
                       {if(0 === switcher)
                         {var i$3=i$1 + 1 | 0,r$2=[5,r$0],r$0=r$2,i$1=i$3;continue}
                        var i$4=i$1 + 1 | 0,r$3=[6,r$0],r$0=r$3,i$1=i$4;
                        continue}
                      if(21 === switcher)
                       {var i$2=i$1 + 1 | 0,r$1=[7,r$0],r$0=r$1,i$1=i$2;continue}}
                    var switch$5=0;
                    if(typeof r$0 !== "number" && 0 === r$0[0])
                     {var c=r$0[1];add_char(sb[1],c);switch$5 = 1}
                    if(! switch$5){flush(sb);sb[2] = [0,r$0,sb[2]]}
                    var i$0=i$1;
                    continue a}}}
              flush(sb);
              return [0,[3,rev(sb[2])],i$0]}}
          function regexp0(i)
           {var match=regexp1(i),j=match[2],r=match[1],r1=r,i$0=j;
            for(;;)
             {if
               ((i$0 + 2 | 0)
                <=
                len
                &&
                92
                ===
                caml_string_get(e,i$0)
                &&
                124
                ===
                caml_string_get(e,i$0 + 1 | 0))
               {var
                 match$0=regexp1(i$0 + 2 | 0),
                 i$1=match$0[2],
                 r2=match$0[1],
                 r1$0=[4,r1,r2],
                 r1=r1$0,
                 i$0=i$1;
                continue}
              return [0,r1,i$0]}}
          var
           match=regexp0(0),
           j=match[2],
           r$0=match[1],
           _T4_=j === len?r$0:failwith(_eE_),
           prog=[0,caml_make_vect(32,0)],
           progpos=[0,0],
           cpool=[0,StringMap[1]],
           cpoolpos=[0,0],
           numgroups=[0,1],
           numregs=[0,0],
           fold_case=0;
          function emit_instr(opc,arg)
           {if(prog[1].length - 1 <= progpos[1])
             {var newlen=[0,prog[1].length - 1];
              for(;;)
               {if(newlen[1] <= progpos[1])
                 {newlen[1] = newlen[1] * 2 | 0;continue}
                var nprog=caml_make_vect(newlen[1],0);
                blit$1(prog[1],0,nprog,0,prog[1].length - 1);
                prog[1] = nprog;
                break}}
            var _Uf_=instr(opc,arg),_Ug_=progpos[1];
            caml_check_bound(prog[1],_Ug_)[1 + _Ug_] = _Uf_;
            progpos[1]++;
            return 0}
          function emit_hole(param)
           {var p=progpos[1];emit_instr(op_CHAR,0);return p}
          function patch_instr(pos,opc,dest)
           {var _Ue_=instr(opc,displ(dest,pos));
            caml_check_bound(prog[1],pos)[1 + pos] = _Ue_;
            return 0}
          function cpool_index(s)
           {try
             {var _Uc_=caml_call2(StringMap[27],s,cpool[1]);return _Uc_}
            catch(_Ud_)
             {_Ud_ = caml_wrap_exception(_Ud_);
              if(_Ud_ === Not_found)
               {var p=cpoolpos[1];
                cpool[1] = caml_call3(StringMap[4],s,p,cpool[1]);
                cpoolpos[1]++;
                return p}
              throw _Ud_}}
          function allocate_register_if_nullable(r)
           {if(p(r))
             {var n=numregs[1];
              if(64 <= n)failwith(_ey_);
              numregs[1]++;
              return n}
            return -1}
          function disjoint_modulo_case(c1,c2){return disjoint(c1,c2)}
          function emit_code(param)
           {if(typeof param === "number")
             switch(param)
              {case 0:return emit_instr(op_BOL,0);
               case 1:return emit_instr(op_EOL,0);
               default:return emit_instr(op_WORDBOUNDARY,0)}
            else
             switch(param[0])
              {case 0:var c=param[1];return emit_instr(op_CHAR,c);
               case 1:
                var s=param[1],match=caml_ml_string_length(s);
                if(0 === match)return 0;
                if(1 === match)
                 return emit_instr(op_CHAR,caml_string_get(s,0));
                try
                 {var i=index(s,0);
                  emit_code([1,string_before(s,i)]);
                  emit_instr(op_CHAR,0);
                  var _Ua_=emit_code([1,string_after(s,i + 1 | 0)]);
                  return _Ua_}
                catch(_Ub_)
                 {_Ub_ = caml_wrap_exception(_Ub_);
                  if(_Ub_ === Not_found)
                   return emit_instr(op_STRING,cpool_index(s));
                  throw _Ub_}
               case 2:
                var compl=param[2],cl=param[1],cl2=compl?complement(cl):cl;
                return emit_instr(op_CHARCLASS,cpool_index(to_string(cl2)));
               case 3:var rl=param[1];return emit_seq_code(rl);
               case 4:
                var r2=param[2],r1=param[1],pos_pushback=emit_hole(0);
                emit_code(r1);
                var pos_goto_end=emit_hole(0),lbl1=progpos[1];
                emit_code(r2);
                var lbl2=progpos[1];
                patch_instr(pos_pushback,op_PUSHBACK,lbl1);
                return patch_instr(pos_goto_end,op_GOTO,lbl2);
               case 5:
                var
                 r=param[1],
                 regno=allocate_register_if_nullable(r),
                 lbl1$0=emit_hole(0);
                if(0 <= regno)emit_instr(op_SETMARK,regno);
                emit_code(r);
                if(0 <= regno)emit_instr(op_CHECKPROGRESS,regno);
                emit_instr(op_GOTO,displ(lbl1$0,progpos[1]));
                var lbl2$0=progpos[1];
                return patch_instr(lbl1$0,op_PUSHBACK,lbl2$0);
               case 6:
                var
                 r$0=param[1],
                 regno$0=allocate_register_if_nullable(r$0),
                 lbl1$1=progpos[1];
                emit_code(r$0);
                if(0 <= regno$0)emit_instr(op_CHECKPROGRESS,regno$0);
                var pos_pushback$0=emit_hole(0);
                if(0 <= regno$0)emit_instr(op_SETMARK,regno$0);
                emit_instr(op_GOTO,displ(lbl1$1,progpos[1]));
                var lbl2$1=progpos[1];
                return patch_instr(pos_pushback$0,op_PUSHBACK,lbl2$1);
               case 7:
                var r$1=param[1],pos_pushback$1=emit_hole(0);
                emit_code(r$1);
                var lbl=progpos[1];
                return patch_instr(pos_pushback$1,op_PUSHBACK,lbl);
               case 8:
                var r$2=param[2],n=param[1];
                emit_instr(op_BEGGROUP,n);
                emit_code(r$2);
                emit_instr(op_ENDGROUP,n);
                numgroups[1] = max(numgroups[1],n + 1 | 0);
                return 0;
               default:
                var n$0=param[1];
                emit_instr(op_REFGROUP,n$0);
                numgroups[1] = max(numgroups[1],n$0 + 1 | 0);
                return 0}}
          function emit_seq_code(param)
           {var param$0=param;
            for(;;)
             {if(param$0)
               {var _T5_=param$0[1];
                if(typeof _T5_ !== "number")
                 switch(_T5_[0])
                  {case 5:
                    var _T6_=_T5_[1],switch$0=0;
                    if(typeof _T6_ === "number")
                     switch$0 = 1;
                    else
                     switch(_T6_[0])
                      {case 0:
                       case 2:
                        var rl=param$0[2],_T7_=first_seq(rl);
                        if(disjoint_modulo_case(first(_T6_),_T7_))
                         {emit_instr
                           (op_SIMPLESTAR,
                            cpool_index(charclass_of_regexp(fold_case,_T6_)));
                          var param$0=rl;
                          continue}
                        break;
                       default:switch$0 = 1}
                    break;
                   case 6:
                    var _T8_=_T5_[1],switch$1=0;
                    if(typeof _T8_ === "number")
                     switch$1 = 1;
                    else
                     switch(_T8_[0])
                      {case 0:
                       case 2:
                        var rl$0=param$0[2],_T9_=first_seq(rl$0);
                        if(disjoint_modulo_case(first(_T8_),_T9_))
                         {emit_instr
                           (op_SIMPLEPLUS,
                            cpool_index(charclass_of_regexp(fold_case,_T8_)));
                          var param$0=rl$0;
                          continue}
                        break;
                       default:switch$1 = 1}
                    break;
                   case 7:
                    var _T__=_T5_[1],switch$2=0;
                    if(typeof _T__ === "number")
                     switch$2 = 1;
                    else
                     switch(_T__[0])
                      {case 0:
                       case 2:
                        var rl$1=param$0[2],_T$_=first_seq(rl$1);
                        if(disjoint_modulo_case(first(_T__),_T$_))
                         {emit_instr
                           (op_SIMPLEOPT,
                            cpool_index(charclass_of_regexp(fold_case,_T__)));
                          var param$0=rl$1;
                          continue}
                        break;
                       default:switch$2 = 1}
                    break
                   }
                var param$1=param$0[2];
                emit_code(_T5_);
                var param$0=param$1;
                continue}
              return 0}}
          emit_code(_T4_);
          emit_instr(op_ACCEPT,0);
          var start=first(_T4_);
          if(caml_bytes_equal(start,full))
           var start_pos=-1;
          else
           {var r=make(256,0);
            iter$2(function(c){return caml_bytes_set(r,c,1)},start);
            var start_pos=cpool_index(to_string(r))}
          var constantpool=caml_make_vect(cpoolpos[1],_ez_),_T0_=cpool[1];
          function _T1_(str,idx)
           {caml_check_bound(constantpool,idx)[1 + idx] = str;return 0}
          caml_call2(StringMap[12],_T1_,_T0_);
          var _T2_=numregs[1],_T3_=numgroups[1];
          return [0,
                  sub$1(prog[1],0,progpos[1]),
                  constantpool,
                  fold_case_table,
                  _T3_,
                  _T2_,
                  start_pos]},
       last_search_result=[0,[0]],
       string_match=
        function(re,s,pos)
         {var res=re_string_match(re,s,pos);
          last_search_result[1] = res;
          return 0 < res.length - 1?1:0},
       search_forward=
        function(re,s,pos)
         {var res=re_search_forward(re,s,pos);
          last_search_result[1] = res;
          if(0 === res.length - 1)throw Not_found;
          return caml_check_bound(res,0)[1]},
       match_end=
        function(param)
         {if(last_search_result[1].length - 1 <= 0)return invalid_arg(_eF_);
          var pos=caml_check_bound(last_search_result[1],1)[2];
          if(-1 === pos)throw Not_found;
          return pos},
       opt_search_forward=
        function(re,s,pos)
         {try
           {var _TY_=[0,search_forward(re,s,pos)];return _TY_}
          catch(_TZ_)
           {_TZ_ = caml_wrap_exception(_TZ_);
            if(_TZ_ === Not_found)return 0;
            throw _TZ_}},
       global_replace=
        function(expr,repl,matched)
         {var accu=0,start=0,last_was_empty=0;
          for(;;)
           {var startpos=last_was_empty?start + 1 | 0:start;
            if(caml_ml_string_length(matched) < startpos)
             var _TX_=[0,string_after(matched,start),accu];
            else
             {var match=opt_search_forward(expr,matched,startpos);
              if(match)
               {var
                 pos=match[1],
                 start$0=match_end(0),
                 repl_text=
                  re_replacement_text(repl,last_search_result[1],matched),
                 last_was_empty$0=start$0 === pos?1:0,
                 accu$0=
                  [0,repl_text,[0,sub$0(matched,start,pos - start | 0),accu]],
                 accu=accu$0,
                 start=start$0,
                 last_was_empty=last_was_empty$0;
                continue}
              var _TX_=[0,string_after(matched,start),accu]}
            return concat(_eH_,rev(_TX_))}},
       num_bits_int_aux=
        function(n){return 0 === n?0:num_bits_int_aux(n >>> 1 | 0) + 1 | 0},
       num_bits_int=function(n){return num_bits_int_aux(abs(n))},
       sign_int=function(i){return 0 === i?0:0 < i?1:-1},
       monster_int=-2147483648,
       biggest_int=2147483647,
       least_int=-2147483647,
       compare_int=
        function(n1,n2){return n1 === n2?0:caml_greaterthan(n1,n2)?1:-1};
      initialize_nat(0);
      var
       length_nat=function(n){return n.length - 1 - 1 | 0},
       make_nat=
        function(len)
         {if(0 <= len)
           {var res=create_nat(len);set_to_zero_nat(res,0,len);return res}
          return invalid_arg(_eI_)},
       a_2=make_nat(2),
       a_1=make_nat(1),
       b_2=make_nat(2),
       copy_nat=
        function(nat,off_set,length)
         {var res=create_nat(length);
          blit_nat(res,0,nat,off_set,length);
          return res},
       is_zero_nat=
        function(n,off,len)
         {var _TW_=num_digits_nat(n,off,len);
          return 0 === compare_nat(make_nat(1),0,1,n,off,_TW_)?1:0},
       is_nat_int=
        function(nat,off,len)
         {var
           _TU_=1 === num_digits_nat(nat,off,len)?1:0,
           _TV_=_TU_?is_digit_int(nat,off):_TU_;
          return _TV_},
       int_of_nat=
        function(nat)
         {var len=length_nat(nat);
          return is_nat_int(nat,0,len)?nth_digit_nat(nat,0):failwith(_eJ_)},
       nat_of_int=
        function(i)
         {if(0 <= i)
           {var res=make_nat(1);
            return 0 === i?res:(set_digit_nat(res,0,i),res)}
          return invalid_arg(_eK_)},
       exchange=
        function(r1,r2){var old1=r1[1];r1[1] = r2[1];r2[1] = old1;return 0},
       gcd_nat=
        function(nat1,off1,len1,nat2,off2,len2)
         {if(is_zero_nat(nat1,off1,len1))
           {blit_nat(nat1,off1,nat2,off2,len2);return len2}
          var
           copy1=[0,create_nat(len1 + 1 | 0)],
           copy2=[0,create_nat(len2 + 1 | 0)];
          blit_nat(copy1[1],0,nat1,off1,len1);
          blit_nat(copy2[1],0,nat2,off2,len2);
          set_digit_nat(copy1[1],len1,0);
          set_digit_nat(copy2[1],len2,0);
          var _TQ_=copy2[1],_TR_=copy1[1],_TP_=num_digits_nat(_TQ_,0,len2);
          if(compare_nat(_TR_,0,num_digits_nat(_TR_,0,len1),_TQ_,0,_TP_) < 0)
           exchange(copy1,copy2);
          var
           _TS_=length_nat(copy1[1]),
           real_len1=[0,num_digits_nat(copy1[1],0,_TS_)],
           _TT_=length_nat(copy2[1]),
           real_len2=[0,num_digits_nat(copy2[1],0,_TT_)];
          for(;;)
           {if(is_zero_nat(copy2[1],0,real_len2[1]))
             {blit_nat(nat1,off1,copy1[1],0,real_len1[1]);return real_len1[1]}
            set_digit_nat(copy1[1],real_len1[1],0);
            div_nat(copy1[1],0,real_len1[1] + 1 | 0,copy2[1],0,real_len2[1]);
            exchange(copy1,copy2);
            real_len1[1] = real_len2[1];
            real_len2[1] = num_digits_nat(copy2[1],0,real_len2[1]);
            continue}},
       power_base_max=make_nat(2);
      set_digit_nat(power_base_max,0,1000000000);
      var
       max_power_10_power_in_int=nat_of_int(1000000000),
       raw_string_of_digit=
        function(nat,off)
         {if(is_nat_int(nat,off,1))
           return caml_string_of_jsbytes("" + nth_digit_nat(nat,off));
          blit_nat(b_2,0,nat,off,1);
          div_digit_nat(a_2,0,a_1,0,b_2,0,2,max_power_10_power_in_int,0);
          var
           leading_digits=nth_digit_nat(a_2,0),
           s1=caml_string_of_jsbytes("" + nth_digit_nat(a_1,0)),
           len=caml_ml_string_length(s1);
          if(10 <= leading_digits)
           {var result=make(11,48);
            blit$0(caml_string_of_jsbytes("" + leading_digits),0,result,0,2);
            blit$0(s1,0,result,caml_ml_bytes_length(result) - len | 0,len);
            return to_string(result)}
          var result$0=make(10,48);
          caml_bytes_set(result$0,0,chr(48 + leading_digits | 0));
          blit$0(s1,0,result$0,caml_ml_bytes_length(result$0) - len | 0,len);
          return to_string(result$0)},
       make_power_base=
        function(base,power_base)
         {var i=[0,0],j=[0,0];
          set_digit_nat(power_base,0,base);
          for(;;)
           {i[1]++;
            if(is_digit_zero(power_base,i[1]))
             {mult_digit_nat
               (power_base,i[1],2,power_base,i[1] - 1 | 0,1,power_base,0);
              continue}
            for(;;)
             {if(j[1] < (i[1] - 1 | 0) && is_digit_int(power_base,j[1]))
               {j[1]++;continue}
              return [0,i[1] - 2 | 0,j[1]]}}},
       unadjusted_string_of_nat=
        function(nat,off,len_nat)
         {var len=num_digits_nat(nat,off,len_nat);
          if(1 === len)return raw_string_of_digit(nat,off);
          var
           len_copy=[0,len + 1 | 0],
           copy1=create_nat(len_copy[1]),
           copy2=make_nat(len_copy[1]),
           rest_digit=make_nat(2);
          if(214748364 < len)return failwith(_eM_);
          var len_s=10 * len | 0,s=make(len_s,48),pos_ref=[0,len_s];
          len_copy[1] = len_copy[1] - 1 | 0;
          blit_nat(copy1,0,nat,off,len);
          set_digit_nat(copy1,len,0);
          for(;;)
           {if(is_zero_nat(copy1,0,len_copy[1]))
             return caml_string_of_bytes(s);
            div_digit_nat
             (copy2,
              0,
              rest_digit,
              0,
              copy1,
              0,
              len_copy[1] + 1 | 0,
              power_base_max,
              0);
            var str=raw_string_of_digit(rest_digit,0);
            blit$0
             (str,
              0,
              s,
              pos_ref[1] - caml_ml_string_length(str) | 0,
              caml_ml_string_length(str));
            pos_ref[1] = pos_ref[1] - 9 | 0;
            len_copy[1] = num_digits_nat(copy2,0,len_copy[1]);
            blit_nat(copy1,0,copy2,0,len_copy[1]);
            set_digit_nat(copy1,len_copy[1],0);
            continue}},
       string_of_nat=
        function(nat)
         {var s=unadjusted_string_of_nat(nat,0,length_nat(nat)),index=[0,0];
          try
           {var _TM_=caml_ml_string_length(s) - 2 | 0,_TL_=0;
            if(! (_TM_ < 0))
             {var i=_TL_;
              for(;;)
               {if(48 !== caml_string_get(s,i)){index[1] = i;throw Exit}
                var _TN_=i + 1 | 0;
                if(_TM_ !== i){var i=_TN_;continue}
                break}}}
          catch(_TO_)
           {_TO_ = caml_wrap_exception(_TO_);if(_TO_ !== Exit)throw _TO_}
          return sub$0(s,index[1],caml_ml_string_length(s) - index[1] | 0)},
       rem=[0,0,make_nat(1)],
       t$0=[0,1,nat_of_int(1)],
       num_digits_big_int=
        function(bi)
         {var _TK_=length_nat(bi[2]);return num_digits_nat(bi[2],0,_TK_)},
       num_bits_big_int=
        function(bi)
         {var
           _TJ_=length_nat(bi[2]),
           nd=num_digits_nat(bi[2],0,_TJ_),
           lz=num_leading_zero_bits_in_digit(bi[2],nd - 1 | 0);
          return (nd * 32 | 0) - lz | 0},
       minus_big_int=
        function(bi)
         {var _TH_=num_digits_big_int(bi),_TI_=copy_nat(bi[2],0,_TH_);
          return [0,- bi[1] | 0,_TI_]},
       abs_big_int=
        function(bi)
         {var
           _TE_=num_digits_big_int(bi),
           _TF_=copy_nat(bi[2],0,_TE_),
           _TG_=0 === bi[1]?0:1;
          return [0,_TG_,_TF_]},
       compare_big_int=
        function(bi1,bi2)
         {if(0 === bi1[1] && 0 === bi2[1])return 0;
          if(bi1[1] < bi2[1])return -1;
          if(bi2[1] < bi1[1])return 1;
          if(1 === bi1[1])
           {var
             _Ty_=num_digits_big_int(bi2),
             _Tz_=bi2[2],
             _TA_=num_digits_big_int(bi1);
            return compare_nat(bi1[2],0,_TA_,_Tz_,0,_Ty_)}
          var
           _TB_=num_digits_big_int(bi1),
           _TC_=bi1[2],
           _TD_=num_digits_big_int(bi2);
          return compare_nat(bi2[2],0,_TD_,_TC_,0,_TB_)},
       eq_big_int=function(bi1,bi2){return 0 === compare_big_int(bi1,bi2)?1:0},
       ge_big_int=function(bi1,bi2){return 0 <= compare_big_int(bi1,bi2)?1:0},
       pred_big_int=
        function(bi)
         {var _Tw_=bi[1];
          if(0 === _Tw_)return [0,-1,nat_of_int(1)];
          if(1 === _Tw_)
           {var
             size_bi=num_digits_big_int(bi),
             copy_bi=copy_nat(bi[2],0,size_bi);
            decr_nat(copy_bi,0,size_bi,0);
            var _Tx_=is_zero_nat(copy_bi,0,size_bi)?0:1;
            return [0,_Tx_,copy_bi]}
          var
           size_bi$0=num_digits_big_int(bi),
           size_res=size_bi$0 + 1 | 0,
           copy_bi$0=create_nat(size_res);
          blit_nat(copy_bi$0,0,bi[2],0,size_bi$0);
          set_digit_nat(copy_bi$0,size_bi$0,0);
          incr_nat(copy_bi$0,0,size_res,1);
          return [0,-1,copy_bi$0]},
       succ_big_int=
        function(bi)
         {var _Tu_=bi[1];
          if(-1 === _Tu_)
           {var
             size_bi=num_digits_big_int(bi),
             copy_bi=copy_nat(bi[2],0,size_bi);
            decr_nat(copy_bi,0,size_bi,0);
            var _Tv_=is_zero_nat(copy_bi,0,size_bi)?0:-1;
            return [0,_Tv_,copy_bi]}
          if(0 === _Tu_)return [0,1,nat_of_int(1)];
          var
           size_bi$0=num_digits_big_int(bi),
           size_res=size_bi$0 + 1 | 0,
           copy_bi$0=create_nat(size_res);
          blit_nat(copy_bi$0,0,bi[2],0,size_bi$0);
          set_digit_nat(copy_bi$0,size_bi$0,0);
          incr_nat(copy_bi$0,0,size_res,1);
          return [0,1,copy_bi$0]},
       add_big_int=
        function(bi1,bi2)
         {var
           size_bi1=num_digits_big_int(bi1),
           size_bi2=num_digits_big_int(bi2);
          if(bi1[1] === bi2[1])
           {var match=compare_nat(bi1[2],0,size_bi1,bi2[2],0,size_bi2);
            if(-1 === match)
             {var res=create_nat(size_bi2 + 1 | 0);
              blit_nat(res,0,bi2[2],0,size_bi2);
              set_digit_nat(res,size_bi2,0);
              add_nat(res,0,size_bi2 + 1 | 0,bi1[2],0,size_bi1,0);
              var res$0=res}
            else
             {var res$1=create_nat(size_bi1 + 1 | 0);
              blit_nat(res$1,0,bi1[2],0,size_bi1);
              set_digit_nat(res$1,size_bi1,0);
              add_nat(res$1,0,size_bi1 + 1 | 0,bi2[2],0,size_bi2,0);
              var res$0=res$1}
            return [0,bi1[1],res$0]}
          var match$0=compare_nat(bi1[2],0,size_bi1,bi2[2],0,size_bi2);
          if(0 === match$0)return rem;
          if(1 === match$0)
           {var res$2=copy_nat(bi1[2],0,size_bi1);
            sub_nat(res$2,0,size_bi1,bi2[2],0,size_bi2,1);
            return [0,bi1[1],res$2]}
          var res$3=copy_nat(bi2[2],0,size_bi2);
          sub_nat(res$3,0,size_bi2,bi1[2],0,size_bi1,1);
          return [0,bi2[1],res$3]},
       big_int_of_int=
        function(i)
         {var res=create_nat(1);
          if(i === -2147483648)
           {set_digit_nat(res,0,2147483647);incr_nat(res,0,1,1)}
          else
           set_digit_nat(res,0,abs(i));
          return [0,sign_int(i),res]},
       add_int_big_int=
        function(i,bi){return add_big_int(big_int_of_int(i),bi)},
       sub_big_int=
        function(bi1,bi2){return add_big_int(bi1,minus_big_int(bi2))},
       mult_int_big_int=
        function(i,bi)
         {var size_bi=num_digits_big_int(bi),size_res=size_bi + 1 | 0;
          if(i === -2147483648)
           {var res=create_nat(size_res);
            blit_nat(res,0,bi[2],0,size_bi);
            set_digit_nat(res,size_bi,0);
            var _Tr_=nat_of_int(biggest_int);
            mult_digit_nat(res,0,size_res,bi[2],0,size_bi,_Tr_,0);
            return [0,- bi[1] | 0,res]}
          var res$0=make_nat(size_res),_Ts_=nat_of_int(abs(i));
          mult_digit_nat(res$0,0,size_res,bi[2],0,size_bi,_Ts_,0);
          var _Tt_=bi[1];
          return [0,caml_mul(sign_int(i),_Tt_),res$0]},
       mult_big_int=
        function(bi1,bi2)
         {var
           size_bi1=num_digits_big_int(bi1),
           size_bi2=num_digits_big_int(bi2),
           size_res=size_bi1 + size_bi2 | 0,
           res=make_nat(size_res);
          if(size_bi1 < size_bi2)
           mult_nat(res,0,size_res,bi2[2],0,size_bi2,bi1[2],0,size_bi1);
          else
           mult_nat(res,0,size_res,bi1[2],0,size_bi1,bi2[2],0,size_bi2);
          return [0,caml_mul(bi1[1],bi2[1]),res]},
       quomod_big_int=
        function(bi1,bi2)
         {if(0 === bi2[1])throw Division_by_zero;
          var
           size_bi1=num_digits_big_int(bi1),
           size_bi2=num_digits_big_int(bi2),
           match=compare_nat(bi1[2],0,size_bi1,bi2[2],0,size_bi2);
          if(-1 === match)
           {if(0 <= bi1[1])return [0,big_int_of_int(0),bi1];
            if(0 <= bi2[1])
             {var _Tl_=add_big_int(bi2,bi1);
              return [0,big_int_of_int(-1),_Tl_]}
            var _Tm_=sub_big_int(bi1,bi2);
            return [0,big_int_of_int(1),_Tm_]}
          if(0 === match)
           return [0,big_int_of_int(caml_mul(bi1[1],bi2[1])),rem];
          var
           bi1_negatif=-1 === bi1[1]?1:0,
           size_q=
            bi1_negatif
             ?max((size_bi1 - size_bi2 | 0) + 1 | 0,1) + 1 | 0
             :max((size_bi1 - size_bi2 | 0) + 1 | 0,1),
           size_r=max(size_bi1,size_bi2) + 1 | 0,
           q=create_nat(size_q),
           r=create_nat(size_r);
          blit_nat(r,0,bi1[2],0,size_bi1);
          set_to_zero_nat(r,size_bi1,size_r - size_bi1 | 0);
          div_nat(r,0,size_r,bi2[2],0,size_bi2);
          blit_nat(q,0,r,size_bi2,size_r - size_bi2 | 0);
          var not_null_mod=1 - is_zero_nat(r,0,size_bi2);
          if(bi1_negatif && not_null_mod)
           {var new_r=copy_nat(bi2[2],0,size_bi2);
            sub_nat(new_r,0,size_bi2,r,0,size_bi2,1);
            set_digit_nat(q,size_q - 1 | 0,0);
            incr_nat(q,0,size_q,1);
            return [0,[0,- bi2[1] | 0,q],[0,1,new_r]]}
          if(bi1_negatif)set_digit_nat(q,size_q - 1 | 0,0);
          var
           _Tn_=copy_nat(r,0,size_bi2),
           _To_=not_null_mod?1:0,
           _Tp_=[0,_To_,_Tn_],
           _Tq_=is_zero_nat(q,0,size_q)?0:caml_mul(bi1[1],bi2[1]);
          return [0,[0,_Tq_,q],_Tp_]},
       div_big_int=function(bi1,bi2){return quomod_big_int(bi1,bi2)[1]},
       gcd_big_int=
        function(bi1,bi2)
         {var
           size_bi1=num_digits_big_int(bi1),
           size_bi2=num_digits_big_int(bi2);
          if(is_zero_nat(bi1[2],0,size_bi1))return abs_big_int(bi2);
          if(is_zero_nat(bi2[2],0,size_bi2))return [0,1,bi1[2]];
          var match=compare_nat(bi1[2],0,size_bi1,bi2[2],0,size_bi2);
          if(0 === match)
           var _Tk_=bi1[2];
          else
           if(1 === match)
            var
             res=copy_nat(bi1[2],0,size_bi1),
             len=gcd_nat(res,0,size_bi1,bi2[2],0,size_bi2),
             _Tk_=copy_nat(res,0,len);
           else
            var
             res$0=copy_nat(bi2[2],0,size_bi2),
             len$0=gcd_nat(res$0,0,size_bi2,bi1[2],0,size_bi1),
             _Tk_=copy_nat(res$0,0,len$0);
          return [0,1,_Tk_]},
       monster_big_int=big_int_of_int(monster_int),
       monster_nat=monster_big_int[2],
       is_int_big_int=
        function(bi)
         {var _Ti_=1 === num_digits_big_int(bi)?1:0;
          if(_Ti_)
           {var match=compare_nat(bi[2],0,1,monster_nat,0,1);
            if(-1 !== match)return 0 === match?-1 === bi[1]?1:0:0;
            var _Tj_=1}
          else
           var _Tj_=_Ti_;
          return _Tj_},
       int_of_big_int=
        function(bi)
         {try
           {var n=int_of_nat(bi[2]),_Tg_=-1 === bi[1]?- n | 0:n;return _Tg_}
          catch(_Th_)
           {_Th_ = caml_wrap_exception(_Th_);
            if(_Th_[1] === Failure)
             return eq_big_int(bi,monster_big_int)?monster_int:failwith(_eO_);
            throw _Th_}},
       big_int_of_int64=
        function(i)
         {if(caml_equal(i,_eP_))
           var sg=0,absi=_eQ_;
          else
           if(caml_greaterthan(i,_eR_))
            var sg=1,absi=i;
           else
            var absi$0=caml_int64_neg(i),sg=-1,absi=absi$0;
          var res=create_nat(2);
          set_digit_nat_native(res,0,caml_int64_to_int32(absi));
          set_digit_nat_native
           (res,1,caml_int64_to_int32(caml_int64_shift_right(absi,32)));
          return [0,sg,res]},
       int64_of_big_int=
        function(bi)
         {var match=num_digits_big_int(bi);
          if(1 === match)
           var
            i=
             caml_int64_and
              (caml_int64_of_int32(nth_digit_nat_native(bi[2],0)),_eS_);
          else
           if(2 === match)
            var
             _Tf_=
              caml_int64_shift_left
               (caml_int64_of_int32(nth_digit_nat_native(bi[2],1)),32),
             i=
              caml_int64_or
               (caml_int64_and
                 (caml_int64_of_int32(nth_digit_nat_native(bi[2],0)),_eX_),
                _Tf_);
           else
            var i=failwith(_eY_);
          if(0 <= bi[1])return caml_greaterequal(i,_eT_)?i:failwith(_eU_);
          if(! caml_greaterequal(i,_eV_) && ! caml_equal(i,min_int))
           return failwith(_eW_);
          return caml_int64_neg(i)},
       s=
        function(bi)
         {return -1 === bi[1]
                  ?symbol(_eZ_,string_of_nat(bi[2]))
                  :string_of_nat(bi[2])},
       sys_big_int_of_string_aux=
        function(s,ofs,len,sgn,base)
         {if(len < 1)failwith(_e0_);
          var
           power_base=make_nat(33),
           match=make_power_base(base,power_base),
           pint=match[2],
           pmax=match[1],
           _S9_=1 + caml_div(len,pmax + 1 | 0) | 0,
           current_len=[0,1],
           possible_len=[0,min(2,_S9_)],
           nat1=make_nat(_S9_),
           nat2=make_nat(_S9_),
           digits_read=[0,0],
           bound=(ofs + len | 0) - 1 | 0,
           int$0=[0,0];
          if(! (bound < ofs))
           {var i=ofs;
            for(;;)
             {var n$0=caml_string_get(s,i),switch$0=0;
              if(32 <= n$0)
               {if(93 <= n$0)
                 {if(95 === n$0 && ofs < i)switch$0 = 2}
                else
                 if(58 < (n$0 - 33 | 0) >>> 0)switch$0 = 1}
              else
               if(11 <= n$0)
                {if(13 === n$0)switch$0 = 1}
               else
                if(9 <= n$0)switch$0 = 1;
              switch(switch$0)
               {case 0:
                 var switch$1=0;
                 if(48 <= n$0 && n$0 <= (47 + min(base,10) | 0))
                  var _Te_=n$0 - 48 | 0;
                 else
                  switch$1 = 1;
                 if(switch$1)
                  {var switch$2=0;
                   if(65 <= n$0 && n$0 <= ((65 + base | 0) - 11 | 0))
                    var _Te_=n$0 - 55 | 0;
                   else
                    switch$2 = 1;
                   if(switch$2)
                    {var switch$3=0;
                     if(97 <= n$0 && n$0 <= ((97 + base | 0) - 11 | 0))
                      var _Te_=n$0 - 87 | 0;
                     else
                      switch$3 = 1;
                     if(switch$3)var _Te_=failwith(_eN_)}}
                 int$0[1] = caml_mul(int$0[1],base) + _Te_ | 0;
                 digits_read[1]++;
                 break;
                case 1:break
                }
              var
               _S__=digits_read[1] === pint?1:0,
               _S$_=_S__ || (i === bound?1:0),
               _Ta_=_S$_?1 - (0 === digits_read[1]?1:0):_S$_;
              if(_Ta_)
               {set_digit_nat(nat1,0,int$0[1]);
                var
                 erase_len=
                  _S9_ === current_len[1]
                   ?current_len[1] - 1 | 0
                   :current_len[1],
                 _Tb_=1;
                if(! (erase_len < 1))
                 {var j=_Tb_;
                  for(;;)
                   {set_digit_nat(nat1,j,0);
                    var _Td_=j + 1 | 0;
                    if(erase_len !== j){var j=_Td_;continue}
                    break}}
                mult_digit_nat
                 (nat1,
                  0,
                  possible_len[1],
                  nat2,
                  0,
                  current_len[1],
                  power_base,
                  digits_read[1] - 1 | 0);
                blit_nat(nat2,0,nat1,0,possible_len[1]);
                current_len[1] = num_digits_nat(nat1,0,possible_len[1]);
                possible_len[1] = min(_S9_,current_len[1] + 1 | 0);
                int$0[1] = 0;
                digits_read[1] = 0}
              var _Tc_=i + 1 | 0;
              if(bound !== i){var i=_Tc_;continue}
              break}}
          var n=create_nat(current_len[1]);
          blit_nat(n,0,nat1,0,current_len[1]);
          return is_zero_nat(n,0,length_nat(n))?rem:[0,sgn,n]},
       sys_big_int_of_string_base=
        function(s,ofs,len,sgn)
         {if(len < 1)failwith(_e1_);
          if(2 <= len)
           {var
             match=caml_string_get(s,ofs),
             match$0=caml_string_get(s,ofs + 1 | 0);
            if(48 === match)
             {var switch$0=0;
              if(89 <= match$0)
               {if(98 === match$0)
                 switch$0 = 3;
                else
                 if(111 === match$0)
                  switch$0 = 2;
                 else
                  if(120 === match$0)switch$0 = 1}
              else
               if(66 === match$0)
                switch$0 = 3;
               else
                if(79 === match$0)
                 switch$0 = 2;
                else
                 if(88 <= match$0)switch$0 = 1;
              switch(switch$0)
               {case 0:break;
                case 1:
                 return sys_big_int_of_string_aux
                         (s,ofs + 2 | 0,len - 2 | 0,sgn,16);
                case 2:
                 return sys_big_int_of_string_aux
                         (s,ofs + 2 | 0,len - 2 | 0,sgn,8);
                default:
                 return sys_big_int_of_string_aux
                         (s,ofs + 2 | 0,len - 2 | 0,sgn,2)}}
            return sys_big_int_of_string_aux(s,ofs,len,sgn,10)}
          return sys_big_int_of_string_aux(s,ofs,len,sgn,10)},
       sys_big_int_of_string=
        function(s,ofs,len)
         {if(len < 1)failwith(_e2_);
          var match=caml_string_get(s,ofs),switcher=match - 43 | 0;
          if(! (2 < switcher >>> 0))
           switch(switcher)
            {case 0:
              return sys_big_int_of_string_base(s,ofs + 1 | 0,len - 1 | 0,1);
             case 1:break;
             default:
              return sys_big_int_of_string_base(s,ofs + 1 | 0,len - 1 | 0,-1)}
          return sys_big_int_of_string_base(s,ofs,len,1)},
       big_int_of_string=
        function(s)
         {return sys_big_int_of_string(s,0,caml_ml_string_length(s))},
       power_int_positive_int=
        function(i$1,i$0)
         {var match$0=sign_int(i$0);
          if(-1 === match$0)return invalid_arg(_e3_);
          if(0 === match$0)return t$0;
          var base=abs(i$1),switch$0=0;
          if(0 === i$0 || 1 === base)
           switch$0 = 1;
          else
           if(0 === base)
            var nat=nat_of_int(0);
           else
            if(0 <= i$0)
             {var
               power_base=make_nat(33),
               match=make_power_base(base,power_base),
               pmax=match[1],
               n=caml_div(i$0,pmax + 1 | 0),
               rem=caml_mod(i$0,pmax + 1 | 0);
              if(0 < n)
               {var
                 newn=i$0 === 2147483647?n:n + 1 | 0,
                 res=make_nat(newn),
                 res2=make_nat(newn),
                 l=num_bits_int(n) - 2 | 0;
                blit_nat(res,0,power_base,pmax,1);
                if(! (l < 0))
                 {var i=l;
                  for(;;)
                   {var
                     len=num_digits_nat(res,0,newn),
                     len2=min(n,2 * len | 0),
                     succ_len2=len2 + 1 | 0;
                    square_nat(res2,0,len2,res,0,len);
                    if(0 < (n & 1 << i))
                     {set_to_zero_nat(res,0,len);
                      mult_digit_nat(res,0,succ_len2,res2,0,len2,power_base,pmax)}
                    else
                     blit_nat(res,0,res2,0,len2);
                    set_to_zero_nat(res2,0,len2);
                    var _S7_=i - 1 | 0;
                    if(0 !== i){var i=_S7_;continue}
                    break}}
                var
                 nat=
                  0 < rem
                   ?(mult_digit_nat(res2,0,newn,res,0,n,power_base,rem - 1 | 0),
                     res2)
                   :res}
              else
               var nat=copy_nat(power_base,rem - 1 | 0,1)}
            else
             var nat=invalid_arg(_eL_);
          if(switch$0)var nat=nat_of_int(1);
          var _S8_=0 <= i$1?sign_int(i$1):0 === (i$0 & 1)?1:-1;
          return [0,_S8_,nat]},
       power_big_int_positive_int=
        function(bi,n)
         {var match=sign_int(n);
          if(-1 === match)return invalid_arg(_e4_);
          if(0 === match)return t$0;
          var
           bi_len=num_digits_big_int(bi),
           res_len=caml_mul(bi_len,n),
           res=make_nat(res_len),
           res2=make_nat(res_len),
           l=num_bits_int(n) - 2 | 0;
          blit_nat(res,0,bi[2],0,bi_len);
          if(! (l < 0))
           {var i=l;
            for(;;)
             {var
               len=num_digits_nat(res,0,res_len),
               len2=min(res_len,2 * len | 0);
              set_to_zero_nat(res2,0,len2);
              square_nat(res2,0,len2,res,0,len);
              if(0 < (n & 1 << i))
               {var lenp=min(res_len,len2 + bi_len | 0);
                set_to_zero_nat(res,0,lenp);
                mult_nat(res,0,lenp,res2,0,len2,bi[2],0,bi_len)}
              else
               blit_nat(res,0,res2,0,len2);
              var _S6_=i - 1 | 0;
              if(0 !== i){var i=_S6_;continue}
              break}}
          var _S5_=0 <= bi[1]?bi[1]:0 === (n & 1)?1:-1;
          return [0,_S5_,res]},
       power_int_positive_big_int=
        function(i$0,bi)
         {var match$1=bi[1];
          if(-1 === match$1)return invalid_arg(_e5_);
          if(0 === match$1)return t$0;
          var len$0=num_digits_big_int(bi),_S3_=bi[2],base=abs(i$0),off=0;
          if(0 === base)
           var nat=nat_of_int(0);
          else
           {var switch$0=0;
            if(is_zero_nat(_S3_,off,len$0) || 1 === base)
             switch$0 = 1;
            else
             {var
               power_base=make_nat(33),
               match=make_power_base(base,power_base),
               pmax=match[1],
               _S1_=big_int_of_int(pmax + 1 | 0),
               length=num_digits_nat(_S3_,0,len$0),
               _SZ_=copy_nat(_S3_,off,length),
               _S0_=is_zero_nat(_S3_,off,length)?0:1,
               match$0=quomod_big_int([0,_S0_,_SZ_],_S1_),
               y=match$0[2],
               x=match$0[1],
               rem=int_of_big_int(y),
               n=int_of_big_int(x);
              if(0 === n)
               var nat=copy_nat(power_base,rem - 1 | 0,1);
              else
               {var
                 res=make_nat(n),
                 res2=make_nat(n + 1 | 0),
                 l=num_bits_int(n) - 2 | 0;
                blit_nat(res,0,power_base,pmax,1);
                if(! (l < 0))
                 {var i=l;
                  for(;;)
                   {var
                     len=num_digits_nat(res,0,n),
                     len2=min(n,2 * len | 0),
                     succ_len2=len2 + 1 | 0;
                    square_nat(res2,0,len2,res,0,len);
                    if(0 < (n & 1 << i))
                     {set_to_zero_nat(res,0,len);
                      mult_digit_nat(res,0,succ_len2,res2,0,len2,power_base,pmax)}
                    else
                     blit_nat(res,0,res2,0,len2);
                    set_to_zero_nat(res2,0,len2);
                    var _S2_=i - 1 | 0;
                    if(0 !== i){var i=_S2_;continue}
                    break}}
                var
                 nat=
                  0 < rem
                   ?(mult_digit_nat
                      (res2,0,n + 1 | 0,res,0,n,power_base,rem - 1 | 0),
                     res2)
                   :res}}
            if(switch$0)var nat=nat_of_int(1)}
          var _S4_=0 <= i$0?sign_int(i$0):is_digit_odd(bi[2],0)?-1:1;
          return [0,_S4_,nat]},
       power_big_int_positive_big_int=
        function(bi1,bi2)
         {var match=bi2[1];
          if(-1 === match)return invalid_arg(_e6_);
          if(0 === match)return t$0;
          try
           {var _SW_=power_big_int_positive_int(bi1,int_of_big_int(bi2));
            return _SW_}
          catch(_SX_)
           {_SX_ = caml_wrap_exception(_SX_);
            if(_SX_[1] === Failure)
             try
              {var _SV_=power_int_positive_big_int(int_of_big_int(bi1),bi2);
               return _SV_}
             catch(_SY_)
              {_SY_ = caml_wrap_exception(_SY_);
               if(_SY_[1] === Failure)throw Out_of_memory;
               throw _SY_}
            throw _SX_}},
       shift_left_big_int=
        function(bi,n)
         {if(0 <= n)
           {if(0 === n)return bi;
            if(0 === bi[1])return bi;
            var
             size_bi=num_digits_big_int(bi),
             size_res=size_bi + (((n + 32 | 0) - 1 | 0) / 32 | 0) | 0,
             res=create_nat(size_res),
             ndigits=n / 32 | 0;
            set_to_zero_nat(res,0,ndigits);
            blit_nat(res,ndigits,bi[2],0,size_bi);
            var nbits=n % 32 | 0;
            if(0 < nbits)
             shift_left_nat
              (res,ndigits,size_bi,res,ndigits + size_bi | 0,nbits);
            return [0,bi[1],res]}
          return invalid_arg(_e7_)},
       shift_right_towards_zero_big_i=
        function(bi,n)
         {if(0 <= n)
           {if(0 === n)return bi;
            if(0 === bi[1])return bi;
            var
             size_bi=num_digits_big_int(bi),
             ndigits=n / 32 | 0,
             nbits=n % 32 | 0;
            if(size_bi <= ndigits)return rem;
            var size_res=size_bi - ndigits | 0,res=create_nat(size_res);
            blit_nat(res,0,bi[2],ndigits,size_res);
            if(0 < nbits)
             {var tmp=create_nat(1);
              shift_right_nat(res,0,size_res,tmp,0,nbits)}
            return is_zero_nat(res,0,size_res)?rem:[0,bi[1],res]}
          return invalid_arg(_e8_)},
       shift_right_big_int=
        function(bi,n)
         {if(0 <= n)
           {if(0 <= bi[1])return shift_right_towards_zero_big_i(bi,n);
            if(0 <= n)
             if(0 === n)
              var _SU_=rem;
             else
              {var idx=n / 32 | 0,size_res=idx + 1 | 0,res=make_nat(size_res);
               set_digit_nat_native(res,idx,1 << (n % 32 | 0));
               decr_nat(res,0,size_res,0);
               var _SU_=[0,1,res]}
            else
             var _SU_=invalid_arg(_e9_);
            return shift_right_towards_zero_big_i(sub_big_int(bi,_SU_),n)}
          return invalid_arg(_e__)},
       and_big_int=
        function(a,b)
         {if(0 <= a[1] && 0 <= b[1])
           {if(0 !== a[1] && 0 !== b[1])
             {var
               size_a=num_digits_big_int(a),
               size_b=num_digits_big_int(b),
               size_res=min(size_a,size_b),
               res=create_nat(size_res);
              blit_nat(res,0,a[2],0,size_res);
              var _SS_=size_res - 1 | 0,_SR_=0;
              if(! (_SS_ < 0))
               {var i=_SR_;
                for(;;)
                 {land_digit_nat(res,i,b[2],i);
                  var _ST_=i + 1 | 0;
                  if(_SS_ !== i){var i=_ST_;continue}
                  break}}
              return is_zero_nat(res,0,size_res)?rem:[0,1,res]}
            return rem}
          return invalid_arg(_e$_)},
       round_big_int_to_float=
        function(x,exact)
         {var
           n=num_bits_big_int(x),
           _SP_=55 <= n?1:0,
           _SQ_=_SP_?n <= 63?1:0:_SP_;
          if(_SQ_)
           {var m=int64_of_big_int(x),m$0=exact?m:caml_int64_or(m,_fa_);
            return caml_int64_to_float(m$0)}
          throw [0,Assert_failure,_fb_]},
       normalize_ratio_flag=[0,0],
       failwith_zero=
        function(name)
         {var
           s=
            0 === caml_ml_string_length(name)
             ?s$0
             :symbol(name,symbol(_fc_,s$0));
          return failwith(s)},
       verify_null_denominator=
        function(r){return 0 === r[2][1]?failwith_zero(_fd_):0},
       sign_ratio=function(r){return r[1][1]},
       normalize_ratio=
        function(r)
         {if(r[3])return r;
          if(verify_null_denominator(r))
           {r[1] = big_int_of_int(r[1][1]);r[3] = 1;return r}
          var p=gcd_big_int(r[1],r[2]);
          return eq_big_int(p,t$0)
                  ?(r[3] = 1,r)
                  :(r[1]
                    =
                    div_big_int(r[1],p),
                    r[2]
                    =
                    div_big_int(r[2],p),
                    r[3]
                    =
                    1,
                    r)},
       cautious_normalize_ratio=
        function(r){return normalize_ratio_flag[1]?normalize_ratio(r):r},
       create_ratio=
        function(bi1,bi2)
         {var match=bi2[1];
          if(-1 === match)
           {var _SO_=minus_big_int(bi2);
            return cautious_normalize_ratio([0,minus_big_int(bi1),_SO_,0])}
          return 0 === match
                  ?failwith_zero(_fe_)
                  :cautious_normalize_ratio([0,bi1,bi2,0])},
       create_normalized_ratio=
        function(bi1,bi2)
         {var match=bi2[1];
          if(-1 === match)
           {var _SN_=minus_big_int(bi2);return [0,minus_big_int(bi1),_SN_,1]}
          return 0 === match?failwith_zero(_ff_):[0,bi1,bi2,1]},
       report_sign_ratio=
        function(r,bi){return -1 === sign_ratio(r)?minus_big_int(bi):bi},
       abs_ratio=
        function(r)
         {var _SL_=r[3],_SM_=r[2];return [0,abs_big_int(r[1]),_SM_,_SL_]},
       is_integer_ratio=
        function(r){return eq_big_int(normalize_ratio(r)[2],t$0)},
       add_int_ratio=
        function(i,r)
         {cautious_normalize_ratio(r);
          var _SI_=r[3],_SJ_=r[2],_SK_=r[1];
          return [0,add_big_int(mult_int_big_int(i,r[2]),_SK_),_SJ_,_SI_]},
       add_big_int_ratio=
        function(bi,r)
         {cautious_normalize_ratio(r);
          var _SF_=r[3],_SG_=r[2],_SH_=r[1];
          return [0,add_big_int(mult_big_int(bi,r[2]),_SH_),_SG_,_SF_]},
       mult_ratio=
        function(r1,r2)
         {if(normalize_ratio_flag[1])
           {var
             _SC_=normalize_ratio(r2)[2],
             p1=gcd_big_int(normalize_ratio(r1)[1],_SC_),
             p2=gcd_big_int(r2[1],r1[2]);
            if(eq_big_int(p1,t$0))
             var n1=r1[1],d2=r2[2];
            else
             var d2$0=div_big_int(r2[2],p1),n1=div_big_int(r1[1],p1),d2=d2$0;
            if(eq_big_int(p2,t$0))
             var n2=r2[1],d1=r1[2];
            else
             var
              d1$0=div_big_int(r1[2],p2),
              n2$0=div_big_int(r2[1],p2),
              n2=n2$0,
              d1=d1$0;
            var _SD_=mult_big_int(d1,d2);
            return [0,mult_big_int(n1,n2),_SD_,1]}
          var _SE_=mult_big_int(r1[2],r2[2]);
          return [0,mult_big_int(r1[1],r2[1]),_SE_,0]},
       mult_int_ratio=
        function(i,r)
         {if(normalize_ratio_flag[1])
           {var
             _Sw_=big_int_of_int(i),
             p=gcd_big_int(normalize_ratio(r)[2],_Sw_);
            if(eq_big_int(p,t$0))
             {var _Sx_=r[2],_Sy_=r[1];
              return [0,mult_big_int(big_int_of_int(i),_Sy_),_Sx_,1]}
            var _Sz_=div_big_int(r[2],p),_SA_=r[1];
            return [0,
                    mult_big_int(div_big_int(big_int_of_int(i),p),_SA_),
                    _Sz_,
                    1]}
          var _SB_=r[2];
          return [0,mult_int_big_int(i,r[1]),_SB_,0]},
       mult_big_int_ratio=
        function(bi,r)
         {if(normalize_ratio_flag[1])
           {var p=gcd_big_int(normalize_ratio(r)[2],bi);
            if(eq_big_int(p,t$0))
             {var _Ss_=r[2];return [0,mult_big_int(bi,r[1]),_Ss_,1]}
            var _St_=div_big_int(r[2],p),_Su_=r[1];
            return [0,mult_big_int(div_big_int(bi,p),_Su_),_St_,1]}
          var _Sv_=r[2];
          return [0,mult_big_int(bi,r[1]),_Sv_,0]},
       inverse_ratio=
        function(r)
         {if(0 === r[1][1])return failwith_zero(_fg_);
          var _Sq_=r[3],_Sr_=abs_big_int(r[1]);
          return [0,report_sign_ratio(r,r[2]),_Sr_,_Sq_]},
       div_ratio=function(r1,r2){return mult_ratio(r1,inverse_ratio(r2))},
       floor_ratio=
        function(r){verify_null_denominator(r);return div_big_int(r[1],r[2])},
       eq_big_int_ratio=
        function(bi,r)
         {var _Sp_=is_integer_ratio(r);return _Sp_?eq_big_int(bi,r[1]):_Sp_},
       compare_big_int_ratio=
        function(bi,r)
         {normalize_ratio(r);
          if(verify_null_denominator(r))return - r[1][1] | 0;
          var _So_=r[1];
          return compare_big_int(mult_big_int(bi,r[2]),_So_)},
       ratio_of_int=function(i){return [0,big_int_of_int(i),t$0,1]},
       power_ratio_positive_int=
        function(r,n)
         {var _Sn_=power_big_int_positive_int(r[2],n);
          return create_ratio(power_big_int_positive_int(r[1],n),_Sn_)},
       power_ratio_positive_big_int=
        function(r,bi)
         {var _Sm_=power_big_int_positive_big_int(r[2],bi);
          return create_ratio(power_big_int_positive_big_int(r[1],bi),_Sm_)},
       bi2=big_int_of_int(biggest_int),
       least_INT=big_int_of_int(least_int),
       num_of_big_int=
        function(bi)
         {if(compare_big_int(bi,bi2) <= 0 && ge_big_int(bi,least_INT))
           return [0,int_of_big_int(bi)];
          return [1,bi]},
       num_of_ratio=
        function(r)
         {normalize_ratio(r);
          return is_integer_ratio(r)
                  ?is_int_big_int(r[1])?[0,int_of_big_int(r[1])]:[1,r[1]]
                  :[2,r]},
       add_num=
        function(a,match)
         {switch(a[0])
           {case 0:
             var _Sh_=a[1];
             switch(match[0])
              {case 0:
                var int2=match[1],r=_Sh_ + int2 | 0;
                if(0 <= (_Sh_ ^ int2 | _Sh_ ^ r ^ -1))
                 {var _Si_=big_int_of_int(int2);
                  return [1,add_big_int(big_int_of_int(_Sh_),_Si_)]}
                return [0,r];
               case 1:
                var bi=match[1];
                return num_of_big_int(add_int_big_int(_Sh_,bi));
               default:var r$0=match[1];return [2,add_int_ratio(_Sh_,r$0)]}
            case 1:
             var _Sj_=a[1];
             switch(match[0])
              {case 0:
                var i=match[1];return num_of_big_int(add_int_big_int(i,_Sj_));
               case 1:
                var bi2=match[1];return num_of_big_int(add_big_int(_Sj_,bi2));
               default:var r$1=match[1];return [2,add_big_int_ratio(_Sj_,r$1)]}
            default:
             var _Sk_=a[1];
             switch(match[0])
              {case 0:var i$0=match[1];return [2,add_int_ratio(i$0,_Sk_)];
               case 1:
                var bi$0=match[1];return [2,add_big_int_ratio(bi$0,_Sk_)];
               default:
                var r2=match[1];
                if(normalize_ratio_flag[1])
                 {var
                   _Sa_=normalize_ratio(r2)[2],
                   p=gcd_big_int(normalize_ratio(_Sk_)[2],_Sa_);
                  if(eq_big_int(p,t$0))
                   var
                    _Sb_=mult_big_int(_Sk_[2],r2[2]),
                    _Sc_=mult_big_int(r2[1],_Sk_[2]),
                    _Sl_=
                     [0,add_big_int(mult_big_int(_Sk_[1],r2[2]),_Sc_),_Sb_,1];
                  else
                   var
                    d1=div_big_int(_Sk_[2],p),
                    d2=div_big_int(r2[2],p),
                    _Sd_=mult_big_int(d1,r2[1]),
                    n=add_big_int(mult_big_int(_Sk_[1],d2),_Sd_),
                    p$0=gcd_big_int(n,p),
                    _Se_=mult_big_int(d1,div_big_int(r2[2],p$0)),
                    _Sl_=[0,div_big_int(n,p$0),_Se_,1]}
                else
                 var
                  _Sf_=mult_big_int(_Sk_[2],r2[2]),
                  _Sg_=mult_big_int(_Sk_[2],r2[1]),
                  _Sl_=
                   [0,add_big_int(mult_big_int(_Sk_[1],r2[2]),_Sg_),_Sf_,0];
                return num_of_ratio(_Sl_)}}},
       minus_num=
        function(param)
         {switch(param[0])
           {case 0:
             var i=param[1];
             return i === -2147483648
                     ?[1,minus_big_int(big_int_of_int(i))]
                     :[0,- i | 0];
            case 1:var bi=param[1];return [1,minus_big_int(bi)];
            default:
             var r=param[1],_R__=r[3],_R$_=r[2];
             return [2,[0,minus_big_int(r[1]),_R$_,_R__]]}},
       sub_num=function(n1,n2){return add_num(n1,minus_num(n2))},
       mult_num=
        function(a,match)
         {switch(a[0])
           {case 0:
             var _R5_=a[1];
             switch(match[0])
              {case 0:
                var int2=match[1],_R6_=num_bits_int(int2);
                if((num_bits_int(_R5_) + _R6_ | 0) < 31)
                 return [0,caml_mul(_R5_,int2)];
                var _R7_=big_int_of_int(int2);
                return num_of_big_int(mult_big_int(big_int_of_int(_R5_),_R7_));
               case 1:
                var bi=match[1];
                return num_of_big_int(mult_int_big_int(_R5_,bi));
               default:
                var r=match[1];return num_of_ratio(mult_int_ratio(_R5_,r))}
            case 1:
             var _R8_=a[1];
             switch(match[0])
              {case 0:
                var i=match[1];
                return num_of_big_int(mult_int_big_int(i,_R8_));
               case 1:
                var bi2=match[1];
                return num_of_big_int(mult_big_int(_R8_,bi2));
               default:
                var r$0=match[1];
                return num_of_ratio(mult_big_int_ratio(_R8_,r$0))}
            default:
             var _R9_=a[1];
             switch(match[0])
              {case 0:
                var i$0=match[1];
                return num_of_ratio(mult_int_ratio(i$0,_R9_));
               case 1:
                var bi$0=match[1];
                return num_of_ratio(mult_big_int_ratio(bi$0,_R9_));
               default:
                var r2=match[1];return num_of_ratio(mult_ratio(_R9_,r2))}}},
       div_num=
        function(n1,n2)
         {switch(n1[0])
           {case 0:
             var i1=n1[1];
             switch(n2[0])
              {case 0:
                var i2=n2[1],_R4_=big_int_of_int(i2);
                return num_of_ratio(create_ratio(big_int_of_int(i1),_R4_));
               case 1:
                var bi2=n2[1];
                return num_of_ratio(create_ratio(big_int_of_int(i1),bi2));
               default:
                var r2=n2[1];
                verify_null_denominator(r2);
                return num_of_ratio(mult_int_ratio(i1,inverse_ratio(r2)))}
            case 1:
             var bi1=n1[1];
             switch(n2[0])
              {case 0:
                var i2$0=n2[1];
                return num_of_ratio(create_ratio(bi1,big_int_of_int(i2$0)));
               case 1:
                var bi2$0=n2[1];return num_of_ratio(create_ratio(bi1,bi2$0));
               default:
                var r2$0=n2[1];
                verify_null_denominator(r2$0);
                return num_of_ratio
                        (mult_big_int_ratio(bi1,inverse_ratio(r2$0)))}
            default:
             var r1=n1[1];
             switch(n2[0])
              {case 0:
                var i2$1=n2[1];
                return num_of_ratio(div_ratio(r1,ratio_of_int(i2$1)));
               case 1:
                var bi2$1=n2[1];
                return num_of_ratio(div_ratio(r1,[0,bi2$1,t$0,1]));
               default:var r2$1=n2[1];return num_of_ratio(div_ratio(r1,r2$1))}}},
       floor_num=
        function(n)
         {switch(n[0])
           {case 0:return n;
            case 1:return n;
            default:var r=n[1];return num_of_big_int(floor_ratio(r))}},
       power_num=
        function(n,match$5)
         {switch(match$5[0])
           {case 0:
             var i$1=match$5[1];
             switch(n[0])
              {case 0:
                var i=n[1],match=sign_int(i$1);
                return 0 === match
                        ?_fm_
                        :1 === match
                          ?num_of_big_int(power_int_positive_int(i,i$1))
                          :[2,
                            create_normalized_ratio
                             (t$0,power_int_positive_int(i,- i$1 | 0))];
               case 1:
                var bi=n[1],match$0=sign_int(i$1);
                return 0 === match$0
                        ?_fn_
                        :1 === match$0
                          ?num_of_big_int(power_big_int_positive_int(bi,i$1))
                          :[2,
                            create_normalized_ratio
                             (t$0,power_big_int_positive_int(bi,- i$1 | 0))];
               default:
                var r=n[1],match$1=sign_int(i$1);
                return 0 === match$1
                        ?_fo_
                        :1 === match$1
                          ?[2,power_ratio_positive_int(r,i$1)]
                          :[2,power_ratio_positive_int(inverse_ratio(r),- i$1 | 0)]}
            case 1:
             var bi$1=match$5[1];
             switch(n[0])
              {case 0:
                var i$0=n[1],match$2=bi$1[1];
                return 0 === match$2
                        ?_fp_
                        :1 === match$2
                          ?num_of_big_int(power_int_positive_big_int(i$0,bi$1))
                          :[2,
                            create_normalized_ratio
                             (t$0,power_int_positive_big_int(i$0,minus_big_int(bi$1)))];
               case 1:
                var bi$0=n[1],match$3=bi$1[1];
                return 0 === match$3
                        ?_fq_
                        :1 === match$3
                          ?num_of_big_int(power_big_int_positive_big_int(bi$0,bi$1))
                          :[2,
                            create_normalized_ratio
                             (t$0,
                              power_big_int_positive_big_int(bi$0,minus_big_int(bi$1)))];
               default:
                var r$0=n[1],match$4=bi$1[1];
                if(0 === match$4)return _fr_;
                if(1 === match$4)
                 return [2,power_ratio_positive_big_int(r$0,bi$1)];
                var _R3_=minus_big_int(bi$1);
                return [2,
                        power_ratio_positive_big_int(inverse_ratio(r$0),_R3_)]}
            default:return invalid_arg(_fs_)}},
       is_integer_num=
        function(param)
         {switch(param[0])
           {case 0:return 1;
            case 1:return 1;
            default:var r=param[1];return is_integer_ratio(r)}},
       sign_num=
        function(param)
         {switch(param[0])
           {case 0:var i=param[1];return sign_int(i);
            case 1:var bi=param[1];return bi[1];
            default:var r=param[1];return sign_ratio(r)}},
       eq_num=
        function(a,match)
         {switch(a[0])
           {case 0:
             var _R0_=a[1];
             switch(match[0])
              {case 0:var int2=match[1];return _R0_ === int2?1:0;
               case 1:
                var bi=match[1];return eq_big_int(big_int_of_int(_R0_),bi);
               default:
                var r=match[1];return eq_big_int_ratio(big_int_of_int(_R0_),r)}
            case 1:
             var _R1_=a[1];
             switch(match[0])
              {case 0:
                var i=match[1];return eq_big_int(big_int_of_int(i),_R1_);
               case 1:var bi2=match[1];return eq_big_int(_R1_,bi2);
               default:var r$0=match[1];return eq_big_int_ratio(_R1_,r$0)}
            default:
             var _R2_=a[1];
             switch(match[0])
              {case 0:
                var i$0=match[1];
                return eq_big_int_ratio(big_int_of_int(i$0),_R2_);
               case 1:var bi$0=match[1];return eq_big_int_ratio(bi$0,_R2_);
               default:
                var r2=match[1];
                normalize_ratio(_R2_);
                normalize_ratio(r2);
                var _RZ_=eq_big_int(_R2_[1],r2[1]);
                return _RZ_?eq_big_int(_R2_[2],r2[2]):_RZ_}}},
       symbol$0=function(a,b){return 1 - eq_num(a,b)},
       compare_num=
        function(a,match$0)
         {switch(a[0])
           {case 0:
             var _RW_=a[1];
             switch(match$0[0])
              {case 0:var int2=match$0[1];return compare_int(_RW_,int2);
               case 1:
                var bi=match$0[1];
                return compare_big_int(big_int_of_int(_RW_),bi);
               default:
                var r=match$0[1];
                return compare_big_int_ratio(big_int_of_int(_RW_),r)}
            case 1:
             var _RX_=a[1];
             switch(match$0[0])
              {case 0:
                var i=match$0[1];
                return compare_big_int(_RX_,big_int_of_int(i));
               case 1:var bi2=match$0[1];return compare_big_int(_RX_,bi2);
               default:
                var r$0=match$0[1];return compare_big_int_ratio(_RX_,r$0)}
            default:
             var _RY_=a[1];
             switch(match$0[0])
              {case 0:
                var i$0=match$0[1];
                return - compare_big_int_ratio(big_int_of_int(i$0),_RY_) | 0;
               case 1:
                var bi$0=match$0[1];
                return - compare_big_int_ratio(bi$0,_RY_) | 0;
               default:
                var r2=match$0[1];
                if(verify_null_denominator(_RY_))
                 {var sign_num_r1=_RY_[1][1];
                  if(verify_null_denominator(r2))
                   {var sign_num_r2=r2[1][1];
                    if(1 === sign_num_r1 && -1 === sign_num_r2)return 1;
                    if(-1 === sign_num_r1 && 1 === sign_num_r2)return -1;
                    return 0}
                  return sign_num_r1}
                if(verify_null_denominator(r2))return - r2[1][1] | 0;
                var
                 match=compare_int(_RY_[1][1],r2[1][1]),
                 switcher=match + 1 | 0;
                if(! (2 < switcher >>> 0))
                 switch(switcher)
                  {case 0:return -1;case 1:break;default:return 1}
                if(eq_big_int(_RY_[2],r2[2]))
                 return compare_big_int(_RY_[1],r2[1]);
                var _RV_=mult_big_int(_RY_[2],r2[1]);
                return compare_big_int(mult_big_int(_RY_[1],r2[2]),_RV_)}}},
       lt_num=function(num1,num2){return compare_num(num1,num2) < 0?1:0},
       max_num=function(num1,num2){return lt_num(num1,num2)?num2:num1},
       min_num=
        function(num1,num2){return 0 < compare_num(num1,num2)?num2:num1},
       big_int_of_num=
        function(param)
         {switch(param[0])
           {case 0:var i=param[1];return big_int_of_int(i);
            case 1:var bi=param[1];return bi;
            default:
             var r=param[1];
             normalize_ratio(r);
             return is_integer_ratio(r)?r[1]:failwith(_fj_)}},
       string_of_num=
        function(n)
         {switch(n[0])
           {case 0:var i=n[1],_RU_=[0,i];break;
            case 1:var bi=n[1],_RU_=num_of_big_int(bi);break;
            default:
             var r=n[1],_RU_=is_integer_ratio(r)?num_of_big_int(r[1]):[2,r]}
          switch(_RU_[0])
           {case 0:var i$0=_RU_[1];return caml_string_of_jsbytes("" + i$0);
            case 1:var bi$0=_RU_[1];return s(bi$0);
            default:
             var r$0=_RU_[1];
             normalize_ratio(r$0);
             var _RT_=symbol(_fk_,s(r$0[2]));
             return symbol(s(r$0[1]),_RT_)}},
       num_of_string=
        function(s)
         {try
           {var flag=normalize_ratio_flag[1];
            normalize_ratio_flag[1] = 1;
            try
             {var
               n=index(s,47),
               _RO_=
                sys_big_int_of_string
                 (s,n + 1 | 0,(caml_ml_string_length(s) - n | 0) - 1 | 0),
               _RP_=create_ratio(sys_big_int_of_string(s,0,n),_RO_),
               r=_RP_}
            catch(_RS_)
             {_RS_ = caml_wrap_exception(_RS_);
              if(_RS_ !== Not_found)throw _RS_;
              var r=[0,big_int_of_string(s),t$0,1]}
            normalize_ratio_flag[1] = flag;
            var _RQ_=eq_big_int(r[2],t$0)?num_of_big_int(r[1]):[2,r];
            return _RQ_}
          catch(_RR_)
           {_RR_ = caml_wrap_exception(_RR_);
            if(_RR_[1] === Failure)return failwith(_ft_);
            throw _RR_}},
       abs_num=
        function(param)
         {switch(param[0])
           {case 0:
             var i=param[1];
             return i === -2147483648
                     ?[1,minus_big_int(big_int_of_int(i))]
                     :[0,abs(i)];
            case 1:var bi=param[1];return [1,abs_big_int(bi)];
            default:var r=param[1];return [2,abs_ratio(r)]}},
       _fu_=caml_ldexp_float(1.,-53),
       _fv_=caml_ldexp_float(1.,-1074),
       _fw_=_fu_ * (1. + 2. * _fu_),
       _fx_=1. / _fu_,
       _fy_=0.5 * (_fv_ / (_fu_ * _fu_)),
       _fz_=_fv_ / _fu_,
       _fA_=2. * min_float;
      if(min_float == 0.5 * (1. / _fu_) * _fv_)
       {if(_fA_ == caml_ldexp_float(1.,-1021))
         {if(_fy_ == caml_ldexp_float(1.,-969))
           {if(_fz_ == caml_ldexp_float(1.,-1021))
             {var
               _fB_=
                function(_RL_)
                 {var _RM_=Math.abs(_RL_);
                  if(_fy_ <= _RM_)return _RL_ + _fw_ * _RM_;
                  if(_RM_ < _fz_)return _RL_ + _fv_;
                  var _RN_=_fx_ * _RL_;
                  return (_RN_ + _fw_ * Math.abs(_RN_)) * _fu_},
               _fC_=
                function(_RI_)
                 {var _RJ_=Math.abs(_RI_);
                  if(_fy_ <= _RJ_)return _RI_ - _fw_ * _RJ_;
                  if(_RJ_ < _fz_)return _RI_ - _fv_;
                  var _RK_=_fx_ * _RI_;
                  return (_RK_ - _fw_ * Math.abs(_RK_)) * _fu_},
               _fD_=
                function(_RF_)
                 {var
                   _RG_=upper_bound < _RF_?1:0,
                   _RH_=_RG_?_RF_ < f_max?1:0:_RG_;
                  return _RH_},
               _fE_=
                function(_RB_)
                 {if(_RB_ == 0.)return _fF_;
                  if(_fD_(_RB_))
                   {var
                     _RC_=caml_frexp_float(_RB_),
                     _RD_=caml_int64_of_float(caml_ldexp_float(_RC_[1],53)),
                     _RE_=power_num(_fG_,[0,_RC_[2] - 53 | 0]);
                    return mult_num(num_of_big_int(big_int_of_int64(_RD_)),_RE_)}
                  return failwith(caml_call1(sprintf(_fH_),_RB_))},
               _fI_=-1,
               _fJ_=32,
               _fK_=power_int_positive_int(2,32),
               _fL_=0,
               _fM_=
                function(_Rs_)
                 {function _Rt_(_RA_)
                   {var _Rz_=_fL_,_Ry_=big_int_of_num(floor_num(_RA_));
                    for(;;)
                     {if(ge_big_int(_Ry_,_fK_))
                       {var _Rz_=_Rz_ + 32 | 0,_Ry_=shift_right_big_int(_Ry_,_fJ_);
                        continue}
                      var _Rx_=_fI_,_Rw_=_Ry_;
                      for(;;)
                       {if(0 < _Rw_[1])
                         {var _Rx_=_Rx_ + 1 | 0,_Rw_=shift_right_big_int(_Rw_,1);
                          continue}
                        return _Rz_ + _Rx_ | 0}}}
                  var _Ru_=abs_num(_Rs_);
                  if(lt_num(_Ru_,_fN_))
                   {var _Rv_=- _Rt_(div_num(_fO_,_Ru_)) | 0;
                    return eq_num(power_num(_fP_,[0,_Rv_]),_Ru_)
                            ?_Rv_
                            :_Rv_ - 1 | 0}
                  return _Rt_(_Ru_)},
               _fQ_=
                function(_Ro_)
                 {if(0 <= sign_num(_Ro_))
                   {if(0 === sign_num(_Ro_))return 0.;
                    var _Rp_=_fM_(_Ro_),_Rq_=min(_Rp_ + 1074 | 0,52);
                    if(0 <= _Rq_)
                     {var
                       _Rr_=
                        caml_ldexp_float
                         (caml_int64_to_float
                           (int64_of_big_int
                             (big_int_of_num
                               (floor_num
                                 (mult_num(power_num(_fR_,[0,_Rq_ - _Rp_ | 0]),_Ro_))))),
                          _Rp_ - _Rq_ | 0);
                      return _Rr_ == f_max?max_float:_Rr_}
                    return 0.}
                  throw [0,Assert_failure,_fS_]},
               _fT_=
                function(_Ri_)
                 {if(0 <= sign_num(_Ri_))
                   {if(0 === sign_num(_Ri_))return 0.;
                    var _Rj_=_fM_(_Ri_),_Rk_=min(_Rj_ + 1074 | 0,52);
                    if(0 <= _Rk_)
                     {var
                       _Rl_=mult_num(power_num(_fU_,[0,_Rk_ - _Rj_ | 0]),_Ri_),
                       _Rm_=floor_num(_Rl_),
                       _Rn_=
                        eq_num(_Rl_,_Rm_)
                         ?big_int_of_num(_Rm_)
                         :succ_big_int(big_int_of_num(_Rm_));
                      return caml_ldexp_float
                              (caml_int64_to_float(int64_of_big_int(_Rn_)),
                               _Rj_ - _Rk_ | 0)}
                    return caml_ldexp_float(1.,-1074)}
                  throw [0,Assert_failure,_fV_]},
               _fW_=
                function(_Rh_,_Rg_)
                 {return _Rh_ == upper_bound
                          ?- max_float
                          :_Rh_ == f_max
                            ?_Rh_
                            :0 <= compare_num(_fE_(_Rh_),_Rg_)?_Rh_:_fB_(_Rh_)},
               _fX_=
                function(_Rf_,_Re_)
                 {return _Rf_ == f_max
                          ?max_float
                          :_Rf_ == upper_bound
                            ?_Rf_
                            :0 < compare_num(_fE_(_Rf_),_Re_)?_fC_(_Rf_):_Rf_},
               _fY_=
                function(_Rc_,_Rb_)
                 {var _Rd_=_Rc_ + _Rb_;
                  if(_Rd_ == f_max)return max_float;
                  if(! (_Rb_ < _Rd_ - _Rc_) && ! (_Rc_ < _Rd_ - _Rb_))
                   return _Rd_;
                  return _fC_(_Rd_)},
               symbol$1=
                function(_Q$_,_Q__)
                 {var _Ra_=_Q$_ + _Q__;
                  if(_Ra_ == upper_bound)return - max_float;
                  if(! (_Ra_ - _Q$_ < _Q__) && ! (_Ra_ - _Q__ < _Q$_))
                   return _Ra_;
                  return _fB_(_Ra_)},
               symbol$2=function(_Q9_,_Q8_){return _fY_(_Q9_,- _Q8_)},
               _fZ_=function(_Q7_,_Q6_){return symbol$1(_Q7_,- _Q6_)},
               _f0_=caml_ldexp_float(1.,27) + 1.,
               _f1_=_fC_(caml_ldexp_float(1.,1021)),
               _f2_=_fB_(caml_ldexp_float(1.,-969)),
               _f3_=caml_ldexp_float(1.,995),
               _f4_=
                function(_QZ_,_QY_,_QX_)
                 {var
                   _Q0_=_QZ_ * _f0_,
                   _Q1_=_Q0_ + (_QZ_ - _Q0_),
                   _Q2_=_QZ_ - _Q1_,
                   _Q3_=_QY_ * _f0_,
                   _Q4_=_Q3_ + (_QY_ - _Q3_),
                   _Q5_=_QY_ - _Q4_;
                  return _Q1_
                         *
                         _Q4_
                         -
                         _QX_
                         +
                         _Q1_
                         *
                         _Q5_
                         +
                         _Q4_
                         *
                         _Q2_
                         +
                         _Q2_
                         *
                         _Q5_},
               _f5_=
                function(_QT_,_QS_)
                 {if(_QT_ != 0. && _QS_ != 0.)
                   {var _QU_=_QT_ * _QS_,_QV_=Math.abs(_QU_);
                    if
                     (Math.abs(_QT_)
                      <=
                      _f3_
                      &&
                      Math.abs(_QS_)
                      <=
                      _f3_
                      &&
                      _f2_
                      <=
                      _QV_
                      &&
                      _QV_
                      <=
                      _f1_)
                     return 0. <= _f4_(_QT_,_QS_,_QU_)?_QU_:_fC_(_QU_);
                    if(_QU_ == f_max)return max_float;
                    if(_QU_ == upper_bound)return _QU_;
                    var _QW_=_fE_(_QS_);
                    return _fX_(_QU_,mult_num(_fE_(_QT_),_QW_))}
                  return 0.},
               symbol$3=
                function(_QO_,_QN_)
                 {if(_QO_ != 0. && _QN_ != 0.)
                   {var _QP_=_QO_ * _QN_,_QQ_=Math.abs(_QP_);
                    if
                     (Math.abs(_QO_)
                      <=
                      _f3_
                      &&
                      Math.abs(_QN_)
                      <=
                      _f3_
                      &&
                      _f2_
                      <=
                      _QQ_
                      &&
                      _QQ_
                      <=
                      _f1_)
                     return _f4_(_QO_,_QN_,_QP_) <= 0.?_QP_:_fB_(_QP_);
                    if(_QP_ == upper_bound)return - max_float;
                    if(_QP_ == f_max)return _QP_;
                    var _QR_=_fE_(_QN_);
                    return _fW_(_QP_,mult_num(_fE_(_QO_),_QR_))}
                  return 0.},
               _f6_=
                function(_QL_,_QK_)
                 {if(0. <= _QL_ && 0. < _QK_)
                   {var _QM_=_QL_ / _QK_;
                    return _QM_ == f_max
                            ?max_float
                            :_QM_ == 0.?0.:symbol$3(_QK_,_QM_) <= _QL_?_QM_:_fC_(_QM_)}
                  throw [0,Assert_failure,_f7_]},
               _f8_=
                function(_QI_,_QH_)
                 {if(0. <= _QI_ && 0. < _QH_)
                   {var _QJ_=_QI_ / _QH_;
                    return _QJ_ == f_max
                            ?f_max
                            :_QJ_ == 0.
                              ?_QI_ == 0.?0.:_fv_
                              :_QI_ <= _f5_(_QH_,_QJ_)?_QJ_:_fB_(_QJ_)}
                  throw [0,Assert_failure,_f9_]},
               _f__=
                function(_QG_,_QF_)
                 {return 0. <= _QG_
                          ?0. <= _QF_?_f6_(_QG_,_QF_):- _f8_(_QG_,- _QF_)
                          :_QF_ <= 0.?_f6_(- _QG_,- _QF_):- _f8_(- _QG_,_QF_)},
               _f$_=
                function(_QE_,_QD_)
                 {return 0. <= _QE_
                          ?0. <= _QD_?_f8_(_QE_,_QD_):- _f6_(_QE_,- _QD_)
                          :_QD_ <= 0.?_f8_(- _QE_,- _QD_):- _f6_(- _QE_,_QD_)},
               _ga_=
                function(_Qz_,_Qy_)
                 {var
                   _QA_=_Qz_ * _f0_,
                   _QB_=_QA_ + (_Qz_ - _QA_),
                   _QC_=_Qz_ - _QB_;
                  return _QB_
                         *
                         _QB_
                         -
                         _Qy_
                         +
                         _QB_
                         *
                         _QC_
                         +
                         _QB_
                         *
                         _QC_
                         +
                         _QC_
                         *
                         _QC_},
               _gb_=
                function(_Qv_)
                 {var _Qw_=_Qv_ * _Qv_;
                  if(_f2_ <= _Qw_ && _Qw_ <= _f1_)
                   return 0. <= _ga_(_Qv_,_Qw_)?_Qw_:_fC_(_Qw_);
                  if(_Qw_ == 0.)return 0.;
                  if(_Qw_ == f_max)return max_float;
                  var _Qx_=_fE_(_Qv_);
                  return _fX_(_Qw_,mult_num(_Qx_,_Qx_))},
               _gc_=
                function(_Qs_)
                 {var _Qt_=_Qs_ * _Qs_;
                  if(_f2_ <= _Qt_ && _Qt_ <= _f1_)
                   return _ga_(_Qs_,_Qt_) <= 0.?_Qt_:_fB_(_Qt_);
                  if(_Qt_ == 0.)return _Qs_ == 0.?0.:_fv_;
                  if(_Qt_ == f_max)return _Qt_;
                  var _Qu_=_fE_(_Qs_);
                  return _fW_(_Qt_,mult_num(_Qu_,_Qu_))},
               _gd_=
                function(_Qq_)
                 {if(_Qq_ < 0.)return nan;
                  if(_Qq_ == f_max)return max_float;
                  var _Qr_=Math.sqrt(_Qq_);
                  return _gc_(_Qr_) <= _Qq_?_Qr_:_fC_(_Qr_)},
               _ge_=
                function(_Qo_)
                 {if(_Qo_ < 0.)return nan;
                  if(_Qo_ == f_max)return f_max;
                  var _Qp_=Math.sqrt(_Qo_);
                  return _Qo_ <= _gb_(_Qp_)?_Qp_:_fB_(_Qp_)},
               _gf_=
                function(_Qm_,_Ql_)
                 {if(2 < _Ql_ >>> 0)
                   {if(_Qm_ == 0.)return 0 <= _Ql_?0.:nan;
                    if(_fD_(_Qm_))
                     {var _Qn_=power_num(_fE_(_Qm_),[0,_Ql_]);
                      return 0 <= sign_num(_Qn_)
                              ?_fQ_(_Qn_)
                              :- _fT_(minus_num(_Qn_))}
                    return _Qm_ == f_max
                            ?0 <= _Ql_?max_float:0.
                            :0 === (_Ql_ & 1)?0.:upper_bound}
                  switch(_Ql_)
                   {case 0:return 1.;
                    case 1:return _Qm_;
                    default:return _gb_(_Qm_)}},
               _gg_=
                function(_Qj_,_Qi_)
                 {if(2 < _Qi_ >>> 0)
                   {if(_Qj_ == 0.)return 0 <= _Qi_?0.:nan;
                    if(_fD_(_Qj_))
                     {var _Qk_=power_num(_fE_(_Qj_),[0,_Qi_]);
                      return 0 <= sign_num(_Qk_)
                              ?_fT_(_Qk_)
                              :- _fQ_(minus_num(_Qk_))}
                    return _Qj_ == f_max?f_max:1 === (_Qi_ & 1)?0.:f_max}
                  switch(_Qi_)
                   {case 0:return 1.;
                    case 1:return _Qj_;
                    default:return _gc_(_Qj_)}},
               _gh_=
                function(_Qg_)
                 {if(_Qg_ == 1.)return 0.;
                  var _Qh_=Math.log(_Qg_);
                  return _Qh_ == f_max?max_float:_fC_(_Qh_)},
               _gi_=
                function(_Qe_)
                 {if(_Qe_ == 1.)return 0.;
                  var _Qf_=Math.log(_Qe_);
                  return _Qf_ == upper_bound?- max_float:_fB_(_Qf_)},
               _gj_=[254,f_max,upper_bound],
               _gk_=[254,upper_bound,f_max],
               _gn_=
                function(_Qb_)
                 {var
                   _Qc_=_Qb_[1] == f_max?1:0,
                   _Qd_=_Qc_?_Qb_[2] == upper_bound?1:0:_Qc_;
                  return _Qd_},
               _go_=function(_Qa_){return [254,- _Qa_[2],- _Qa_[1]]},
               _gp_=
                function(_P9_)
                 {var _P__=_P9_[2],_P$_=_P9_[1];
                  if(! (0. <= _P$_) && ! _gn_(_P9_))
                   return _P__ <= 0.
                           ?[254,- _P__,- _P$_]
                           :[254,0.,max(- _P$_,_P__)];
                  return _P9_},
               _gq_=
                function(_P2_,_P1_)
                 {var _P3_=_P1_[2],_P4_=_P1_[1],_P5_=_P2_[2],_P6_=_P2_[1];
                  if(! _gn_(_P2_) && ! _gn_(_P1_))
                   {var
                     _P7_=_P5_ <= _P3_?_P3_:_P5_,
                     _P8_=_P6_ <= _P4_?_P4_:_P6_;
                    return [254,_P8_,_P7_]}
                  return _gj_},
               _gr_=
                function(_PU_,_PT_)
                 {var _PV_=_PT_[2],_PW_=_PT_[1],_PX_=_PU_[2],_PY_=_PU_[1];
                  if(! _gn_(_PU_) && ! _gn_(_PT_))
                   {var
                     _PZ_=_PX_ <= _PV_?_PX_:_PV_,
                     _P0_=_PY_ <= _PW_?_PY_:_PW_;
                    return [254,_P0_,_PZ_]}
                  return _gj_},
               _gs_=
                function(_PR_,_PQ_)
                 {if(! _gn_(_PR_) && ! _gn_(_PQ_))
                   {var _PS_=symbol$1(_PR_[2],_PQ_[2]);
                    return [254,_fY_(_PR_[1],_PQ_[1]),_PS_]}
                  return _gj_},
               _gt_=
                function(_PO_,_PN_)
                 {if(! _gn_(_PO_) && ! _gn_(_PN_))
                   {var _PP_=_fZ_(_PO_[2],_PN_[1]);
                    return [254,symbol$2(_PO_[1],_PN_[2]),_PP_]}
                  return _gj_},
               _gu_=
                function(_Pz_,_Py_)
                 {var _PA_=_Py_[2],_PB_=_Py_[1],_PC_=_Pz_[2],_PD_=_Pz_[1];
                  if(! _gn_(_Pz_) && ! _gn_(_Py_))
                   {if(0. <= _PD_)
                     {var
                       _PE_=0. <= _PA_?symbol$3(_PC_,_PA_):symbol$3(_PD_,_PA_),
                       _PF_=0. <= _PB_?_f5_(_PD_,_PB_):_f5_(_PC_,_PB_);
                      return [254,_PF_,_PE_]}
                    if(_PC_ <= 0.)
                     {var
                       _PG_=_PB_ <= 0.?symbol$3(_PD_,_PB_):symbol$3(_PC_,_PB_),
                       _PH_=_PA_ <= 0.?_f5_(_PC_,_PA_):_f5_(_PD_,_PA_);
                      return [254,_PH_,_PG_]}
                    if(0. <= _PB_)
                     {var _PI_=symbol$3(_PC_,_PA_);
                      return [254,_f5_(_PD_,_PA_),_PI_]}
                    if(_PA_ <= 0.)
                     {var _PJ_=symbol$3(_PD_,_PB_);
                      return [254,_f5_(_PC_,_PB_),_PJ_]}
                    var
                     _PK_=symbol$3(_PC_,_PA_),
                     _PL_=max(symbol$3(_PD_,_PB_),_PK_),
                     _PM_=_f5_(_PC_,_PB_);
                    return [254,min(_f5_(_PD_,_PA_),_PM_),_PL_]}
                  return _gj_},
               _gv_=
                function(_Pt_,_Ps_)
                 {var _Pu_=_Pt_[2],_Pv_=_Pt_[1];
                  if(_gn_(_Pt_))return _gj_;
                  if(0. < _Ps_)
                   {var _Pw_=symbol$3(_Pu_,_Ps_);
                    return [254,_f5_(_Pv_,_Ps_),_Pw_]}
                  if(_Ps_ < 0.)
                   {var _Px_=symbol$3(_Pv_,_Ps_);
                    return [254,_f5_(_Pu_,_Ps_),_Px_]}
                  return _Ps_ == 0.?_gw_:[254,nan,nan]},
               _gx_=function(_Pr_,_Pq_){return _gv_(_Pq_,_Pr_)},
               _gy_=
                function(_Pd_,_Pc_)
                 {var _Pe_=_Pc_[2],_Pf_=_Pc_[1],_Pg_=_Pd_[2],_Ph_=_Pd_[1];
                  if(! _gn_(_Pd_) && ! _gn_(_Pc_))
                   {var switch$0=0;
                    if(_Pf_ != 0. || _Pe_ != 0.)switch$0 = 1;
                    if(switch$0)
                     {if(0. < _Pf_)
                       {var
                         _Pi_=_Pg_ <= 0.?_f$_(_Pg_,_Pe_):_f$_(_Pg_,_Pf_),
                         _Pj_=0. <= _Ph_?_f__(_Ph_,_Pe_):_f__(_Ph_,_Pf_);
                        return [254,_Pj_,_Pi_]}
                      if(_Pe_ < 0.)
                       {var
                         _Pk_=0. <= _Ph_?_f$_(_Ph_,_Pf_):_f$_(_Ph_,_Pe_),
                         _Pl_=_Pg_ <= 0.?_f__(_Pg_,_Pf_):_f__(_Pg_,_Pe_);
                        return [254,_Pl_,_Pk_]}
                      if(_Ph_ == 0. && _Pg_ == 0.)return _gl_;
                      if(_Pf_ == 0.)
                       {var
                         _Pm_=_Pg_ <= 0.?_f$_(_Pg_,_Pe_):f_max,
                         _Pn_=0. <= _Ph_?_f__(_Ph_,_Pe_):upper_bound;
                        return [254,_Pn_,_Pm_]}
                      if(_Pe_ == 0.)
                       {var
                         _Po_=0. <= _Ph_?_f$_(_Ph_,_Pf_):f_max,
                         _Pp_=_Pg_ <= 0.?_f__(_Pg_,_Pf_):upper_bound;
                        return [254,_Pp_,_Po_]}
                      return _gk_}}
                  return _gj_},
               _gz_=
                function(_O9_,_O8_)
                 {var _O__=_O9_[2],_O$_=_O9_[1];
                  if(_gn_(_O9_))return _gj_;
                  if(0. < _O8_)
                   {var _Pa_=_f$_(_O__,_O8_);return [254,_f__(_O$_,_O8_),_Pa_]}
                  if(_O8_ < 0.)
                   {var _Pb_=_f$_(_O$_,_O8_);return [254,_f__(_O__,_O8_),_Pb_]}
                  return _gj_},
               _gA_=
                function(_O4_)
                 {var _O5_=_O4_[2],_O6_=_O4_[1];
                  if(_gn_(_O4_))return _gj_;
                  if(! (0. < _O6_) && ! (_O5_ < 0.))
                   return _O6_ == 0.
                           ?_O5_ == 0.?_gj_:[254,_f__(1.,_O5_),f_max]
                           :_O5_ == 0.?[254,upper_bound,_f$_(1.,_O6_)]:_gk_;
                  var _O7_=_f$_(1.,_O6_);
                  return [254,_f__(1.,_O5_),_O7_]},
               _gB_=
                function(_OZ_)
                 {var _O0_=_OZ_[2],_O1_=_OZ_[1];
                  if(! (_O0_ < 0.) && ! _gn_(_OZ_))
                   {var _O2_=_ge_(_O0_),_O3_=_O1_ <= 0.?0.:_gd_(_O1_);
                    return [254,_O3_,_O2_]}
                  return _gj_},
               _gC_=
                function(_ON_,_OM_)
                 {var _OO_=_ON_[2],_OP_=_ON_[1];
                  if(_gn_(_ON_))return _gj_;
                  var _OQ_=_OM_ + 1 | 0;
                  if(3 < _OQ_ >>> 0)
                   {if(1 === (_OM_ & 1))
                     {if(0 < _OM_)
                       {var _OR_=_gg_(_OO_,_OM_);return [254,_gf_(_OP_,_OM_),_OR_]}
                      if(_OP_ == 0. && _OO_ == 0.)return _gj_;
                      if(0. <= _OP_)
                       {var _OS_=_OP_ == 0.?f_max:_gg_(_OP_,_OM_);
                        return [254,_gf_(_OO_,_OM_),_OS_]}
                      if(_OO_ <= 0.)
                       {var
                         _OT_=_gg_(_OP_,_OM_),
                         _OU_=_OO_ == 0.?upper_bound:_gf_(_OO_,_OM_);
                        return [254,_OU_,_OT_]}
                      return _gk_}
                    if(0 < _OM_)
                     {if(0. <= _OP_)
                       {var _OV_=_gg_(_OO_,_OM_);return [254,_gf_(_OP_,_OM_),_OV_]}
                      if(_OO_ <= 0.)
                       {var _OW_=_gg_(_OP_,_OM_);return [254,_gf_(_OO_,_OM_),_OW_]}
                      return [254,0.,_gg_(max(- _OP_,_OO_),_OM_)]}
                    if(_OP_ == 0. && _OO_ == 0.)return _gj_;
                    if(0. <= _OP_)
                     {var _OX_=_OP_ == 0.?f_max:_gg_(_OP_,_OM_);
                      return [254,_gf_(_OO_,_OM_),_OX_]}
                    if(_OO_ <= 0.)
                     {var _OY_=_OO_ == 0.?f_max:_gg_(_OO_,_OM_);
                      return [254,_gf_(_OP_,_OM_),_OY_]}
                    return [254,_gf_(max(- _OP_,_OO_),_OM_),f_max]}
                  switch(_OQ_)
                   {case 0:return _gA_(_ON_);
                    case 1:return _gm_;
                    case 2:return _ON_;
                    default:
                     var _OI_=_ON_[2],_OJ_=_ON_[1];
                     if(_gn_(_ON_))return _gj_;
                     if(0. <= _OJ_)
                      {var _OK_=_gc_(_OI_);return [254,_gb_(_OJ_),_OK_]}
                     if(_OI_ <= 0.)
                      {var _OL_=_gc_(_OJ_);return [254,_gb_(_OI_),_OL_]}
                     return [254,0.,_gc_(max(- _OJ_,_OI_))]}},
               _gD_=
                function(_OG_)
                 {if(_gn_(_OG_))return _gj_;
                  var
                   _OF_=_fB_(Math.exp(_OG_[2])),
                   _OE_=Math.exp(_OG_[1]),
                   _OH_=_OE_ == f_max?max_float:0. < _OE_?_fC_(_OE_):0.;
                  return [254,_OH_,_OF_]},
               _gE_=
                function(_Oz_)
                 {var _OA_=_Oz_[2],_OB_=_Oz_[1];
                  if(! (_OA_ < 0.) && ! _gn_(_Oz_))
                   {var _OC_=_gi_(_OA_),_OD_=_OB_ <= 0.?upper_bound:_gh_(_OB_);
                    return [254,_OD_,_OC_]}
                  return _gj_},
               _gF_=function(_Oy_){return failwith(_gG_)},
               _gH_=function(_Ox_){return failwith(_gI_)},
               _gJ_=
                function(_Os_,_Or_)
                 {var
                   _Ot_=_Or_[2],
                   _Ou_=caml_call1(sprintf(_Os_),_Ot_),
                   _Ov_=_Or_[1],
                   _Ow_=caml_call1(sprintf(_Os_),_Ov_);
                  return caml_call2(sprintf(_gK_),_Ow_,_Ou_)},
               _gL_=
                function(_Oq_,_Op_)
                 {return _Oq_[2] < _Op_?1:_Oq_[1] <= _Op_?0:-1},
               _gM_=function(_Oo_,_On_){return failwith(_gN_)},
               _gO_=function(_Om_){return failwith(_gP_)},
               _gQ_=function(_Ol_){return failwith(_gR_)},
               _gS_=function(_Ok_){return failwith(_gT_)},
               _gU_=function(_Oj_){return failwith(_gV_)},
               _gW_=function(_Oi_){return failwith(_gX_)},
               _gY_=function(_Oh_){return failwith(_gZ_)},
               _g0_=function(_Og_){return failwith(_g1_)},
               _g2_=
                function(_Oc_)
                 {var _Od_=0.;
                  return fold_left$0
                          (function(_Of_,_Oe_){return max(_Of_,_fZ_(_Oe_[2],_Oe_[1]))},
                           _Od_,
                           _Oc_)},
               itlist=
                function(f,l,b)
                 {if(l)
                   {var t=l[2],h=l[1];return caml_call2(f,h,itlist(f,t,b))}
                  return b},
               insert=
                function(x,l)
                 {var lis=l;
                  for(;;)
                   {if(lis)
                     {var t=lis[2],h=lis[1],_Oa_=0 === caml_compare(x,h)?1:0;
                      if(! _Oa_){var lis=t;continue}
                      var _Ob_=_Oa_}
                    else
                     var _Ob_=0;
                    return _Ob_?l:[0,x,l]}},
               union$0=function(l1,l2){return itlist(insert,l1,l2)},
               assoc=
                function(a,param)
                 {var param$0=param;
                  for(;;)
                   {if(param$0)
                     {var t=param$0[2],match=param$0[1],v=match[2],k=match[1];
                      if(caml_equal(k,a))return v;
                      var param$0=t;
                      continue}
                    throw Not_found}},
               rev_assoc=
                function(a,param)
                 {var param$0=param;
                  for(;;)
                   {if(param$0)
                     {var t=param$0[2],match=param$0[1],k=match[2],v=match[1];
                      if(caml_equal(k,a))return v;
                      var param$0=t;
                      continue}
                    throw Not_found}},
               assoc_eq=
                function(eq,a,param)
                 {var param$0=param;
                  for(;;)
                   {if(param$0)
                     {var t=param$0[2],match=param$0[1],v=match[2],k=match[1];
                      if(caml_call2(eq,k,a))return v;
                      var param$0=t;
                      continue}
                    throw Not_found}},
               zip=
                function(s1,s2)
                 {if(s1)
                   {if(s2)
                     {var t2=s2[2],h2=s2[1],t1=s1[2],h1=s1[1];
                      return [0,[0,h1,h2],zip(t1,t2)]}}
                  else
                   if(! s2)return 0;
                  return failwith(_g3_)},
               unzip=
                function(param)
                 {if(param)
                   {var
                     t=param[2],
                     match=param[1],
                     b=match[2],
                     a=match[1],
                     match$0=unzip(t),
                     r2=match$0[2],
                     r1=match$0[1];
                    return [0,[0,a,r1],[0,b,r2]]}
                  return _g4_},
               init_list=
                function(n,f)
                 {var n$2=n - 1 | 0,n$0=n$2,acc=0;
                  for(;;)
                   {if(0 <= n$0)
                     {var
                       acc$0=[0,caml_call1(f,n$0),acc],
                       n$1=n$0 - 1 | 0,
                       n$0=n$1,
                       acc=acc$0;
                      continue}
                    return acc}},
               is_none=function(param){return param?0:1},
               option_default=
                function(v,param){if(param){var x=param[1];return x}return v},
               option_value=
                function(param)
                 {if(param){var x=param[1];return x}return failwith(_g5_)},
               print_list=
                function(fp,sep)
                 {function print(param)
                   {var param$0=param;
                    for(;;)
                     {if(param$0)
                       {var _N__=param$0[2],_N$_=param$0[1];
                        if(_N__)
                         {var rest=_N__[2],s2=_N__[1];
                          caml_call1(fp,_N$_);
                          caml_call1(sep,0);
                          var param$1=[0,s2,rest],param$0=param$1;
                          continue}
                        return caml_call1(fp,_N$_)}
                      return 0}}
                  return print},
               starts_with=
                function(str,prefix)
                 {var n=caml_ml_string_length(prefix);
                  return caml_ml_string_length(str) < n
                          ?0
                          :caml_string_equal(sub$0(str,0,n),prefix)},
               concat_env_paths=
                function(paths)
                 {var paths$0=paths;
                  for(;;)
                   {if(paths$0)
                     {var rest=paths$0[2],path=paths$0[1],path$0=trim(path);
                      if(caml_string_equal(path$0,_g7_))
                       {var paths$0=rest;continue}
                      return symbol(path$0,symbol(_g8_,concat_env_paths(rest)))}
                    return _g9_}},
               load_and_close_channel=
                function(do_close,ic)
                 {function lf(ichan,a)
                   {try
                     {var _N8_=lf(ic,[0,input_line(ic),a]);return _N8_}
                    catch(_N9_)
                     {_N9_ = caml_wrap_exception(_N9_);
                      if(_N9_ === End_of_file)return a;
                      throw _N9_}}
                  var rs=lf(ic,0);
                  if(do_close)caml_ml_close_channel(ic);
                  return rev(rs)},
               load_file=
                function(filename)
                 {var ic=open_in(filename);
                  return load_and_close_channel(1,ic)},
               run_cmd=
                function(cmd)
                 {var
                   match=open_process(cmd),
                   oc=match[2],
                   ic=match[1],
                   s=load_and_close_channel(0,ic);
                  close_process([0,ic,oc]);
                  return s},
               write_to_file=
                function(fname,writer,arg)
                 {var oc=open_out(fname);
                  function _N4_(param){return caml_ml_flush(oc)}
                  var
                   fmt=
                    make_formatter
                     (function(_N5_,_N6_,_N7_)
                       {return output_substring(oc,_N5_,_N6_,_N7_)},
                      _N4_),
                   result=caml_call2(writer,fmt,arg);
                  pp_print_flush(fmt,0);
                  close_out(oc);
                  return result},
               write_to_string=
                function(writer,arg)
                 {var buf=create(100),fmt=formatter_of_buffer(buf);
                  caml_call2(writer,fmt,arg);
                  pp_print_flush(fmt,0);
                  return contents(buf)},
               write_to_string_result=
                function(writer,arg)
                 {var
                   buf=create(100),
                   fmt=formatter_of_buffer(buf),
                   result=caml_call2(writer,fmt,arg);
                  pp_print_flush(fmt,0);
                  return [0,contents(buf),result]},
               get_dir=
                function(dir_name)
                 {function make(path)
                   {return caml_sys_file_exists(path)
                            ?caml_sys_is_directory(path)?0:failwith(symbol(_g__,path))
                            :(make(dirname$2(path)),unix_mkdir(path,511))}
                  make(dir_name);
                  return dir_name},
               tmp_dir=[0,_g$_],
               get_tmp_dir=function(param){return get_dir(tmp_dir[1])},
               asinh_I=
                function(x)
                 {var
                   sqrt=_ge_(symbol$1(symbol$3(x[2],x[2]),1.)),
                   _N3_=_gi_(symbol$1(x[2],sqrt)),
                   sqrt$0=_gd_(_fY_(_f5_(x[1],x[1]),1.));
                  return [254,_gh_(_fY_(x[1],sqrt$0)),_N3_]},
               acosh_I=
                function(x)
                 {if(x[2] < 1.)return failwith(_ha_);
                  var
                   sqrt=_ge_(_fZ_(symbol$3(x[2],x[2]),1.)),
                   _N1_=_gi_(symbol$1(x[2],sqrt));
                  if(x[1] <= 1.)
                   var _N2_=0.;
                  else
                   var
                    sqrt$0=_gd_(symbol$2(_f5_(x[1],x[1]),1.)),
                    _N2_=_gh_(_fY_(x[1],sqrt$0));
                  return [254,_N2_,_N1_]},
               atanh_I=
                function(x)
                 {if(! (x[2] < -1.) && ! (1. < x[1]))
                   {if(1. <= x[2])
                     var _NX_=f_max;
                    else
                     var
                      _N0_=symbol$2(1.,x[2]),
                      t$0=_f$_(symbol$1(1.,x[2]),_N0_),
                      _NX_=symbol$3(0.5,_gi_(t$0));
                    if(x[1] <= -1.)
                     var _NY_=upper_bound;
                    else
                     var
                      _NZ_=_fZ_(1.,x[1]),
                      t=_f__(_fY_(1.,x[1]),_NZ_),
                      _NY_=_f5_(0.5,_gh_(t));
                    return [254,_NY_,_NX_]}
                  return failwith(_hb_)},
               p2=
                function(f)
                 {var match=caml_frexp_float(f),q=match[2],s=match[1];
                  return s == 0.5
                          ?caml_ldexp_float(1.,q - 2 | 0)
                          :caml_ldexp_float(1.,q - 1 | 0)},
               floor_power2=
                function(f)
                 {var match=caml_classify_float(f);
                  switch(match)
                   {case 2:return f;
                    case 3:return f;
                    case 4:return f;
                    default:return f < 0.?- p2(- f):p2(f)}},
               floor_power2_I=
                function(x)
                 {var _NW_=floor_power2(x[2]);
                  return [254,floor_power2(x[1]),_NW_]},
               goldberg_ulp=
                function(param)
                 {var e_min=param[2],prec=param[1];
                  function ulp(f)
                   {var match=caml_frexp_float(f),e=match[2];
                    return caml_ldexp_float(1.,max(e,e_min + 1 | 0) - prec | 0)}
                  return function(f)
                   {var match=caml_classify_float(f);
                    return 2 <= match?f:f < 0.?- ulp(- f):ulp(f)}},
               goldberg_ulp_I=
                function(pars,x)
                 {var
                   _NT_=x[2],
                   _NU_=caml_call1(goldberg_ulp(pars),_NT_),
                   _NV_=x[1];
                  return [254,caml_call1(goldberg_ulp(pars),_NV_),_NU_]},
               sub2_I=
                function(param)
                 {var y=param[2],x=param[1],switch$0=0;
                  if(0.5 * x[2] <= y[1] && y[1] <= 2. * x[2])switch$0 = 1;
                  var switch$1=0;
                  if(! switch$0)
                   {var switch$2=0;
                    if(2. * x[2] <= y[1] && y[1] <= 0.5 * x[2])switch$2 = 1;
                    if(! switch$2){var _NR_=_fZ_(x[2],y[1]);switch$1 = 1}}
                  if(! switch$1)var _NR_=0.;
                  var switch$3=0;
                  if(0.5 * x[1] <= y[2] && y[2] <= 2. * x[1])switch$3 = 1;
                  var switch$4=0;
                  if(! switch$3)
                   {var switch$5=0;
                    if(2. * x[1] <= y[2] && y[2] <= 0.5 * x[1])switch$5 = 1;
                    if(! switch$5){var _NS_=symbol$2(x[1],y[2]);switch$4 = 1}}
                  if(! switch$4)var _NS_=0.;
                  return [254,_NS_,_NR_]},
               abs_err_I=
                function(param)
                 {var x=param[2],t=param[1];
                  return t[2] <= x[1]
                          ?_gm_
                          :x[2] <= t[1]?neg_one_I:neg_one_one_I},
               log_out=[0,0],
               log_fmt=[0,0],
               log_level=[0,-364068301],
               close=
                function(param)
                 {var _NQ_=log_out[1];
                  if(_NQ_)
                   {var c=_NQ_[1];
                    close_out(c);
                    log_out[1] = 0;
                    log_fmt[1] = 0;
                    return 0}
                  return 0},
               append$0=
                function(str)
                 {var _NP_=log_fmt[1];
                  if(_NP_)
                   {var fmt=_NP_[1];
                    pp_print_string(fmt,str);
                    return pp_print_newline(fmt,0)}
                  return 0},
               open_log=
                function(opt,fname)
                 {if(opt)var sth=opt[1],base_dir=sth;else var base_dir=_hd_;
                  close(0);
                  try
                   {var
                     base_log_dir=get_dir(base_dir),
                     log_name=cc(base_log_dir,fname),
                     c=open_out(log_name);
                    log_out[1] = [0,c];
                    log_fmt[1] = [0,formatter_of_out_channel(c)];
                    var _NO_=0;
                    return _NO_}
                  catch(exn)
                   {exn = caml_wrap_exception(exn);
                    if(exn[1] === Failure)
                     {var
                       str=exn[2],
                       _NN_=cc(base_dir,fname),
                       msg=caml_call3(sprintf$0(_hc_),str,_NN_,base_dir);
                      return pp_print_string(fmt$0,msg)}
                    throw exn}},
               level_of_int=
                function(n)
                 {return 0 < n
                          ?1 === n?83322498:2 === n?815031438:-364068301
                          :858743897},
               int_of_level=
                function(level)
                 {return 815031438 <= level
                          ?858743897 <= level?0:2
                          :83322498 <= level?1:3},
               set_log_level=function(level){log_level[1] = level;return 0},
               warning_str=
                function(str)
                 {var str$0=symbol(_he_,str);
                  append$0(str$0);
                  pp_print_string(fmt$0,str$0);
                  return pp_print_newline(fmt$0,0)},
               error_str=
                function(str)
                 {var str$0=symbol(_hf_,str);
                  append$0(str$0);
                  pp_print_string(fmt$0,str$0);
                  return pp_print_newline(fmt$0,0)},
               report=
                function(level,fmt$0)
                 {return ksprintf
                          (function(str)
                            {append$0(str);
                             var _NM_=int_of_level(log_level[1]);
                             return 0 < caml_int_compare(int_of_level(level),_NM_)
                                     ?0
                                     :(pp_print_string(fmt,str),pp_print_newline(fmt,0))},
                           fmt$0)},
               warning=function(fmt){return ksprintf(warning_str,fmt)},
               error$0=function(fmt){return ksprintf(error_str,fmt)},
               _hg_=caml_check_bound(argv,0)[1],
               msg=caml_call1(sprintf(_hh_),_hg_),
               param_table=create$0(0,100),
               short_names=create$0(0,100),
               input_files_ref=[0,0],
               base_dir_ref=[0,_hi_],
               loaded_cfg_files=[0,0],
               find_option=
                function(default$0,p)
                 {try
                   {var _NK_=find(param_table,p);return _NK_}
                  catch(_NL_)
                   {_NL_ = caml_wrap_exception(_NL_);
                    if(_NL_ === Not_found)
                     {if(default$0){var d=default$0[1];return d}
                      return failwith(symbol(_hj_,p))}
                    throw _NL_}},
               set_option=
                function(opt,_NJ_,name,value)
                 {if(opt)var sth=opt[1],init=sth;else var init=0;
                  if(_NJ_)
                   var sth$0=_NJ_[1],short$0=sth$0;
                  else
                   var short$0=_hn_;
                  if(caml_string_notequal(short$0,_hk_))
                   if(mem$0(short_names,short$0))
                    {var old=find(short_names,short$0);
                     failwith(caml_call3(sprintf$0(_hl_),short$0,old,name))}
                   else
                    replace(short_names,short$0,name);
                  if(! init && ! mem$0(param_table,name))
                   return failwith(caml_call2(sprintf$0(_hm_),name,value));
                  return replace(param_table,name,value)},
               comment=regexp(_ho_),
               parse_config_file=
                function(opt,fname)
                 {if(opt)var sth=opt[1],init=sth;else var init=0;
                  caml_call1(report(858743897,_hp_),fname);
                  var
                   arg_list=[0,0],
                   doc_comment=[0,_hq_],
                   short_name=[0,_hr_],
                   expr=regexp(_hs_),
                   short_regexp=regexp(_ht_);
                  function add_option(param,value,short$0,doc)
                   {var param$0=trim(param),value$0=trim(value);
                    set_option([0,init],[0,short$0],param$0,value$0);
                    var
                     doc$0=
                      caml_string_notequal(short$0,_hu_)
                       ?symbol(_hw_,symbol(short$0,_hv_))
                       :_hB_,
                     doc_str=symbol(doc$0,doc),
                     _Nx_=arg_list[1],
                     _Ny_=0,
                     _Nz_=0,
                     _NA_=
                      [4,
                       function(_NI_){return set_option(_Nz_,_Ny_,param$0,_NI_)}];
                    arg_list[1]
                    =
                    [0,[0,symbol(_hx_,param$0),_NA_,doc_str],_Nx_];
                    var _NB_=caml_string_notequal(short$0,_hy_);
                    if(_NB_)
                     {var
                       _NC_=arg_list[1],
                       _ND_=0,
                       _NE_=0,
                       _NF_=
                        [4,
                         function(_NH_){return set_option(_NE_,_ND_,param$0,_NH_)}];
                      arg_list[1] = [0,[0,symbol(_hA_,short$0),_NF_,_hz_],_NC_];
                      var _NG_=0}
                    else
                     var _NG_=_NB_;
                    return _NG_}
                  function parse_lines(c,lines)
                   {var c$0=c,lines$0=lines;
                    for(;;)
                     {if(lines$0)
                       {var rest=lines$0[2],line=lines$0[1],line$0=trim(line);
                        if(! caml_string_equal(line$0,_hF_))
                         if(string_match(comment,line$0,0))
                          {if(starts_with(line$0,_hG_))
                            doc_comment[1]
                            =
                            sub$0(line$0,2,caml_ml_string_length(line$0) - 2 | 0)}
                         else
                          if(starts_with(line$0,_hH_))
                           {if(string_match(short_regexp,line$0,0))
                             {var n2=2;
                              if(last_search_result[1].length - 1 <= 2)
                               var _Ns_=invalid_arg(_eG_);
                              else
                               {var
                                 b=caml_check_bound(last_search_result[1],2)[1 + n2],
                                 e=caml_check_bound(last_search_result[1],3)[4];
                                if(-1 === b)throw Not_found;
                                var _Ns_=sub$0(line$0,b,e - b | 0)}
                              short_name[1] = _Ns_}}
                          else
                           {var
                             _Nv_=doc_comment[1],
                             _Nw_=short_name[1],
                             num=2,
                             start=string_match(expr,line$0,0)?match_end(0):0,
                             accu=0,
                             start$0=start,
                             n=num;
                            for(;;)
                             {if(caml_ml_string_length(line$0) <= start$0)
                               var _Nr_=accu;
                              else
                               if(1 === n)
                                var _Nr_=[0,string_after(line$0,start$0),accu];
                               else
                                {var match=opt_search_forward(expr,line$0,start$0);
                                 if(match)
                                  var
                                   pos=match[1],
                                   match$0=
                                    start$0 < match_end(0)
                                     ?[0,pos]
                                     :start$0 < caml_ml_string_length(line$0)
                                       ?opt_search_forward(expr,line$0,start$0 + 1 | 0)
                                       :0;
                                 else
                                  var match$0=0;
                                 if(match$0)
                                  {var
                                    pos$0=match$0[1],
                                    n$0=n - 1 | 0,
                                    start$1=match_end(0),
                                    accu$0=[0,sub$0(line$0,start$0,pos$0 - start$0 | 0),accu],
                                    accu=accu$0,
                                    start$0=start$1,
                                    n=n$0;
                                   continue}
                                 var _Nr_=[0,string_after(line$0,start$0),accu]}
                              var strs=rev(_Nr_),switch$0=0;
                              if(strs)
                               {var _Nt_=strs[2],_Nu_=strs[1];
                                if(_Nt_)
                                 if(_Nt_[2])
                                  switch$0 = 1;
                                 else
                                  {var value=_Nt_[1];add_option(_Nu_,value,_Nw_,_Nv_)}
                                else
                                 add_option(_Nu_,_hE_,_Nw_,_Nv_)}
                              else
                               switch$0 = 1;
                              if(switch$0)
                               {caml_call3(error$0(_hC_),fname,c$0,line$0);
                                failwith(symbol(_hD_,fname))}
                              short_name[1] = _hI_;
                              doc_comment[1] = _hJ_;
                              break}}
                        var c$1=c$0 + 1 | 0,c$0=c$1,lines$0=rest;
                        continue}
                      return 0}}
                  try
                   {var _Np_=load_file(fname),lines=_Np_}
                  catch(_Nq_){var lines=failwith(symbol(_hK_,fname))}
                  parse_lines(1,lines);
                  loaded_cfg_files[1]
                  =
                  append(loaded_cfg_files[1],[0,fname,0]);
                  return rev(arg_list[1])},
               stob=
                function(opt,str)
                 {if(opt)var sth=opt[1],name=sth;else var name=_hR_;
                  try
                   {var _Nn_=bool_of_string(str);return _Nn_}
                  catch(_No_)
                   {return failwith(caml_call2(sprintf$0(_hQ_),str,name))}},
               stoi=
                function(opt,str)
                 {if(opt)var sth=opt[1],name=sth;else var name=_hT_;
                  try
                   {var _Nl_=caml_int_of_string(str);return _Nl_}
                  catch(_Nm_)
                   {return failwith(caml_call2(sprintf$0(_hS_),str,name))}},
               stof=
                function(opt,str)
                 {if(opt)var sth=opt[1],name=sth;else var name=_hV_;
                  try
                   {var _Nj_=caml_float_of_string(str);return _Nj_}
                  catch(_Nk_)
                   {return failwith(caml_call2(sprintf$0(_hU_),str,name))}},
               get_string_option=function(name){return find_option(0,name)},
               get_bool_option=
                function(name){return stob([0,name],find_option(0,name))},
               get_int_option=
                function(name){return stoi([0,name],find_option(0,name))},
               get_float_option=
                function(name){return stof([0,name],find_option(0,name))},
               is_option_defined=
                function(name)
                 {try
                   {find_option(0,name);var _Nh_=1;return _Nh_}
                  catch(_Ni_)
                   {_Ni_ = caml_wrap_exception(_Ni_);
                    if(_Ni_[1] === Failure)return 0;
                    throw _Ni_}},
               base_dir=function(param){return base_dir_ref[1]},
               debug=function(param){return get_bool_option(_hW_)},
               proof_flag=function(param){return get_bool_option(_hX_)},
               fail_on_exception=function(param){return get_bool_option(_hY_)},
               clear_all=
                function(param)
                 {clear(param_table);
                  clear(short_names);
                  loaded_cfg_files[1] = 0;
                  base_dir_ref[1] = _h1_;
                  input_files_ref[1] = 0;
                  return 0},
               numerator=
                function(param)
                 {switch(param[0])
                   {case 0:var n=param[1];return big_int_of_int(n);
                    case 1:var n$0=param[1];return n$0;
                    default:var r=param[1];return r[1]}},
               denominator=
                function(param)
                 {if(2 === param[0]){var r=param[1];return r[2]}return t$0},
               split_at=
                function(str,ch)
                 {var n=caml_ml_string_length(str);
                  try
                   {var _Nf_=index(str,ch),i=_Nf_}
                  catch(_Ng_)
                   {_Ng_ = caml_wrap_exception(_Ng_);
                    if(_Ng_ !== Not_found)throw _Ng_;
                    var i=-1}
                  if(0 <= i && ! (n <= i))
                   {var _Ne_=sub$0(str,i + 1 | 0,(n - i | 0) - 1 | 0);
                    return [0,sub$0(str,0,i),_Ne_]}
                  return [0,str,_id_]},
               starts_with$0=
                function(str,prefix)
                 {var
                   len_str=caml_ml_string_length(str),
                   len_p=caml_ml_string_length(prefix);
                  return len_str < len_p
                          ?0
                          :caml_string_equal(sub$0(str,0,len_p),prefix)},
               num_of_float_string=
                function(str)
                 {var
                   _Nc_=starts_with$0(str,_ii_),
                   hex=_Nc_ || starts_with$0(str,_ij_),
                   match=split_at(str,112),
                   s2=match[2],
                   s1=match[1];
                  if(caml_string_notequal(s2,_ie_))
                   var match$1=[0,s1,2,s2];
                  else
                   var
                    match$0=split_at(str,101),
                    s2$0=match$0[2],
                    s1$0=match$0[1],
                    match$1=
                     caml_string_notequal(s2$0,_if_)
                      ?[0,s1$0,10,s2$0]
                      :[0,s1$0,10,_ig_];
                  var
                   s_exp=match$1[3],
                   base=match$1[2],
                   s_significand=match$1[1],
                   match$2=split_at(s_significand,46),
                   s_frac=match$2[2],
                   s_int=match$2[1],
                   n=caml_ml_string_length(s_frac);
                  if(0 === n)
                   var exp_shift=0;
                  else
                   {var switch$0=0;
                    if(0 === hex)
                     if(10 === base)var exp_shift=n;else switch$0 = 1;
                    else
                     if(2 === base)var exp_shift=n * 4 | 0;else switch$0 = 1;
                    if(switch$0)var exp_shift=failwith(_ih_)}
                  var
                   num1=sub_num(num_of_string(s_exp),[0,exp_shift]),
                   _Nd_=num_of_string(symbol(s_int,s_frac));
                  if
                   (!
                    (compare_num(num1,num2) <= 0)
                    &&
                    !
                    (0 <= compare_num(num1,num2$0)))
                   return mult_num(_Nd_,power_num([0,base],num1));
                  return failwith(_ic_)},
               num_of_float=
                function(x)
                 {var match=caml_classify_float(x);
                  if(2 === match)return _ik_;
                  if(3 <= match)
                   {var msg=caml_call1(sprintf(_il_),x);
                    return fail_on_exception(0)
                            ?failwith(msg)
                            :(warning_str(msg),_im_)}
                  var
                   match$0=caml_frexp_float(x),
                   e=match$0[2],
                   m=match$0[1],
                   t=caml_int64_of_float(caml_ldexp_float(m,53)),
                   _Nb_=power_num(_in_,[0,e - 53 | 0]);
                  return mult_num(num_of_big_int(big_int_of_int64(t)),_Nb_)},
               log_big_int_floor=
                function(b,v)
                 {var b$0=big_int_of_int(b);
                  if(0 < v[1])
                   {var t=t$0,b$1=b$0,k$0=0,k=1;
                    for(;;)
                     {var bi1=mult_big_int(b$1,t);
                      if(0 < compare_big_int(bi1,v))
                       {if(1 === k)return k$0;var b$1=b$0,k=1;continue}
                      var
                       k$1=k + 1 | 0,
                       k$2=k$0 + k | 0,
                       b$2=mult_big_int(b$1,b$0),
                       t=bi1,
                       b$1=b$2,
                       k$0=k$2,
                       k=k$1;
                      continue}}
                  return -1},
               string_of_pos_finite_float_lo=
                function(prec,x)
                 {if(0. < x && 0 < prec)
                   {var
                     match=caml_frexp_float(x),
                     exp=match[2],
                     m=match[1],
                     exp$0=exp - 53 | 0,
                     m$0=
                      big_int_of_int64
                       (caml_int64_of_float(caml_ldexp_float(m,53))),
                     two_exp=shift_left_big_int(t$0,abs(exp$0)),
                     ten=big_int_of_int(10);
                    if(0 <= exp$0)
                     var n=shift_left_big_int(m$0,exp$0),rem$0=rem;
                    else
                     var
                      mask=pred_big_int(two_exp),
                      rem$1=and_big_int(m$0,mask),
                      n$0=shift_right_big_int(m$0,- exp$0 | 0),
                      n=n$0,
                      rem$0=rem$1;
                    if(0 < n[1])
                     {var
                       k=log_big_int_floor(10,n) + 1 | 0,
                       e=k - prec | 0,
                       b=power_big_int_positive_int(ten,abs(e));
                      if(0 <= e)
                       var r=div_big_int(n,b),e$0=e;
                      else
                       var
                        t=mult_big_int(rem$0,b),
                        x$0=shift_right_big_int(t,- exp$0 | 0),
                        r=add_big_int(mult_big_int(n,b),x$0),
                        e$0=e}
                    else
                     var
                      k$0=log_big_int_floor(10,div_big_int(two_exp,rem$0)),
                      b$0=power_big_int_positive_int(ten,k$0 + prec | 0),
                      t$1=mult_big_int(rem$0,b$0),
                      r$0=shift_right_big_int(t$1,- exp$0 | 0),
                      e$2=- (k$0 + prec | 0) | 0,
                      r=r$0,
                      e$0=e$2;
                    var
                     s$0=s(r),
                     e$1=(e$0 + prec | 0) - 1 | 0,
                     _M__=symbol(_io_,sub$0(s$0,1,prec - 1 | 0)),
                     s$1=symbol(sub$0(s$0,0,1),_M__);
                    if(0 === e$1)return s$1;
                    var
                     _M$_=caml_string_of_jsbytes("" + e$1),
                     _Na_=0 < e$1?_ip_:_iq_;
                    return symbol(s$1,symbol(_Na_,_M$_))}
                  throw [0,Assert_failure,_ir_]},
               string_of_pos_finite_float_hi=
                function(prec,x)
                 {if(0. < x && 0 < prec)
                   {var
                     match=caml_frexp_float(x),
                     exp=match[2],
                     m=match[1],
                     exp$0=exp - 53 | 0,
                     m$0=
                      big_int_of_int64
                       (caml_int64_of_float(caml_ldexp_float(m,53))),
                     two_exp=shift_left_big_int(t$0,abs(exp$0)),
                     mask=pred_big_int(two_exp),
                     ten=big_int_of_int(10);
                    if(0 <= exp$0)
                     var n=shift_left_big_int(m$0,exp$0),rem$0=rem;
                    else
                     var
                      rem$1=and_big_int(m$0,mask),
                      n$0=shift_right_big_int(m$0,- exp$0 | 0),
                      n=n$0,
                      rem$0=rem$1;
                    if(0 < n[1])
                     {var
                       k=log_big_int_floor(10,n) + 1 | 0,
                       e=k - prec | 0,
                       b=power_big_int_positive_int(ten,abs(e));
                      if(0 <= e)
                       var
                        match$0=quomod_big_int(n,b),
                        v=match$0[2],
                        r=match$0[1],
                        _M5_=0 !== v[1]?1:0,
                        _M6_=_M5_ || (0 !== rem$0[1]?1:0),
                        r$0=r,
                        e$0=e,
                        flag=_M6_;
                      else
                       var
                        t=mult_big_int(rem$0,b),
                        v$0=and_big_int(t,mask),
                        x$0=shift_right_big_int(t,- exp$0 | 0),
                        flag$0=0 !== v$0[1]?1:0,
                        r$0=add_big_int(mult_big_int(n,b),x$0),
                        e$0=e,
                        flag=flag$0}
                    else
                     var
                      k$0=log_big_int_floor(10,div_big_int(two_exp,rem$0)),
                      b$0=power_big_int_positive_int(ten,k$0 + prec | 0),
                      t$1=mult_big_int(rem$0,b$0),
                      v$1=and_big_int(t$1,mask),
                      r$2=shift_right_big_int(t$1,- exp$0 | 0),
                      flag$1=0 !== v$1[1]?1:0,
                      e$4=- (k$0 + prec | 0) | 0,
                      r$0=r$2,
                      e$0=e$4,
                      flag=flag$1;
                    var r$1=flag?succ_big_int(r$0):r$0,s$0=s(r$1);
                    if(prec < caml_ml_string_length(s$0))
                     var e$1=e$0 + 1 | 0,s$1=sub$0(s$0,0,prec),e$2=e$1;
                    else
                     var s$1=s$0,e$2=e$0;
                    var
                     e$3=(e$2 + prec | 0) - 1 | 0,
                     _M7_=symbol(_is_,sub$0(s$1,1,prec - 1 | 0)),
                     s$2=symbol(sub$0(s$1,0,1),_M7_);
                    if(0 === e$3)return s$2;
                    var
                     _M8_=caml_string_of_jsbytes("" + e$3),
                     _M9_=0 < e$3?_it_:_iu_;
                    return symbol(s$2,symbol(_M9_,_M8_))}
                  throw [0,Assert_failure,_iv_]},
               string_of_float_hi=
                function(prec,f)
                 {var match=caml_classify_float(f);
                  switch(match)
                   {case 2:return _ix_;
                    case 3:return 0. < f?_iy_:_iz_;
                    case 4:return _iA_;
                    default:
                     return 0. < f
                             ?string_of_pos_finite_float_hi(prec,f)
                             :symbol(_iw_,string_of_pos_finite_float_lo(prec,- f))}},
               string_of_float_lo=
                function(prec,f)
                 {var match=caml_classify_float(f);
                  switch(match)
                   {case 2:return _iC_;
                    case 3:return 0. < f?_iD_:_iE_;
                    case 4:return _iF_;
                    default:
                     return 0. < f
                             ?string_of_pos_finite_float_lo(prec,f)
                             :symbol(_iB_,string_of_pos_finite_float_hi(prec,- f))}},
               is_power_of_two=
                function(n)
                 {var n$0=abs_num(n);
                  if(is_integer_num(n$0) && symbol$0(n$0,_iG_))
                   {var
                     k=big_int_of_num(n$0),
                     pred_k=pred_big_int(k),
                     r=and_big_int(k,pred_k);
                    return eq_big_int(r,rem)}
                  return 0},
               next_float=
                function(x)
                 {var match=caml_classify_float(x);
                  switch(match)
                   {case 2:return caml_ldexp_float(1.,-1074);
                    case 3:return x == f_max?x:nan;
                    case 4:return nan;
                    default:
                     var bits=caml_int64_bits_of_float(x);
                     return x < 0.
                             ?caml_int64_float_of_bits(pred(bits))
                             :caml_int64_float_of_bits(succ(bits))}},
               u=power_int_positive_int(2,32),
               acc=-1,
               p$0=32,
               acc$0=0,
               log2_num=
                function(r)
                 {function log2(r)
                   {var k$3=big_int_of_num(floor_num(r)),acc$3=acc$0,k$1=k$3;
                    for(;;)
                     {if(ge_big_int(k$1,u))
                       {var
                         k$2=shift_right_big_int(k$1,p$0),
                         acc$4=acc$3 + 32 | 0,
                         acc$3=acc$4,
                         k$1=k$2;
                        continue}
                      var acc$1=acc,k=k$1;
                      for(;;)
                       {if(0 < k[1])
                         {var
                           k$0=shift_right_big_int(k,1),
                           acc$2=acc$1 + 1 | 0,
                           acc$1=acc$2,
                           k=k$0;
                          continue}
                        return acc$3 + acc$1 | 0}}}
                  var r$0=abs_num(r);
                  if(lt_num(r$0,_iH_))
                   {var t=- log2(div_num(_iI_,r$0)) | 0;
                    return eq_num(power_num(_iJ_,[0,t]),r$0)?t:t - 1 | 0}
                  return log2(r$0)},
               float_of_pos_num_lo=
                function(r)
                 {if(0 <= sign_num(r))
                   {if(0 === sign_num(r))return 0.;
                    var n=log2_num(r),k=min(n + 1074 | 0,52);
                    if(0 <= k)
                     {var
                       m=
                        big_int_of_num
                         (floor_num(mult_num(power_num(_iK_,[0,k - n | 0]),r))),
                       f=caml_int64_to_float(int64_of_big_int(m)),
                       x=caml_ldexp_float(f,n - k | 0);
                      return x == f_max?max_float:x}
                    return 0.}
                  throw [0,Assert_failure,_iL_]},
               float_of_pos_num_hi=
                function(r)
                 {if(0 <= sign_num(r))
                   {if(0 === sign_num(r))return 0.;
                    var n=log2_num(r),k=min(n + 1074 | 0,52);
                    if(0 <= k)
                     {var
                       t=mult_num(power_num(_iM_,[0,k - n | 0]),r),
                       m0=floor_num(t),
                       m=
                        eq_num(t,m0)
                         ?big_int_of_num(m0)
                         :succ_big_int(big_int_of_num(m0)),
                       f=caml_int64_to_float(int64_of_big_int(m));
                      return caml_ldexp_float(f,n - k | 0)}
                    return caml_ldexp_float(1.,-1074)}
                  throw [0,Assert_failure,_iN_]},
               interval_of_num=
                function(n)
                 {var
                   _M3_=
                    0 <= sign_num(n)
                     ?float_of_pos_num_hi(n)
                     :- float_of_pos_num_lo(minus_num(n)),
                   _M4_=
                    0 <= sign_num(n)
                     ?float_of_pos_num_lo(n)
                     :- float_of_pos_num_hi(minus_num(n));
                  return [254,_M4_,_M3_]},
               check_float=
                function(v)
                 {var match=caml_classify_float(v);
                  return 3 === match?_iO_:4 <= match?_iP_:_iQ_},
               check_interval=
                function(x)
                 {var c1=check_float(x[2]);
                  return caml_string_equal(c1,_iR_)?check_float(x[1]):c1},
               real_type=[0,max_int],
               is_subtype=
                function(type1,type2){return type1[1] <= type2[1]?1:0},
               is_no_rnd=function(rnd){return 0 === rnd[5][1]?1:0},
               eps_delta_from_bits=
                function(bits)
                 {if(32 <= bits)
                   {if(64 === bits)return _iY_;
                    if(128 === bits)return _iZ_;
                    if(! (33 <= bits))return _i1_}
                  else
                   {if(0 === bits)return _i2_;if(16 === bits)return _i3_}
                  return failwith
                          (symbol(_i0_,caml_string_of_jsbytes("" + bits)))},
               type_precision=
                function(t)
                 {var match=eps_delta_from_bits(t[1]),eps=match[1];
                  return - eps | 0},
               type_min_exp=
                function(t)
                 {var match=eps_delta_from_bits(t[1]),delta=match[2];
                  return delta},
               max_value_from_bits=
                function(bits)
                 {var switch$0=0;
                  if(32 <= bits)
                   if(64 === bits)
                    var p=52,emax=1023;
                   else
                    if(128 === bits)
                     var p=112,emax=16383;
                    else
                     if(33 <= bits)switch$0 = 1;else var p=23,emax=127;
                  else
                   if(0 === bits)
                    var p=0,emax=0;
                   else
                    if(16 === bits)var p=10,emax=15;else switch$0 = 1;
                  if(switch$0)
                   var
                    _M2_=
                     failwith(symbol(_i4_,caml_string_of_jsbytes("" + bits))),
                    p=_M2_[1],
                    emax=_M2_[2];
                  return (2. - caml_ldexp_float(1.,- p | 0))
                         *
                         caml_ldexp_float(1.,emax)},
               string_to_rnd_type=
                function(str)
                 {if(caml_string_notequal(str,_i5_))
                   {var switch$0=0;
                    if
                     (caml_string_notequal(str,_i6_)
                      &&
                      caml_string_notequal(str,_i7_))
                     {if(caml_string_notequal(str,_i8_))
                       {if(caml_string_notequal(str,_i9_))
                         {var switch$1=0;
                          if(caml_string_notequal(str,_i__))
                           {if(caml_string_notequal(str,_i$_))
                             {if(caml_string_notequal(str,_ja_))
                               return failwith(symbol(_jb_,str));
                              switch$1 = 1}}
                          else
                           switch$1 = 1;
                          if(switch$1)return _jc_}
                        return _jd_}
                      switch$0 = 1}
                    if(! switch$0)return _jf_}
                  return _je_},
               create_rounding=
                function(bits,rnd,c)
                 {var
                   fp_type=[0,bits],
                   match=string_to_rnd_type(rnd),
                   rnd_type=match[2],
                   dir_flag=match[1],
                   match$0=eps_delta_from_bits(bits),
                   delta=match$0[2],
                   eps=match$0[1],
                   _M0_=0,
                   _M1_=dir_flag?2. * c:c;
                  return [0,
                          max_value_from_bits(bits),
                          eps,
                          delta,
                          _M1_,
                          fp_type,
                          rnd_type,
                          _M0_]},
               _ji_=[0,[0,_jh_,create_rounding(128,_jg_,1.)],0],
               _jl_=[0,[0,_jk_,create_rounding(128,_jj_,1.)],_ji_],
               _jo_=[0,[0,_jn_,create_rounding(128,_jm_,1.)],_jl_],
               _jr_=[0,[0,_jq_,create_rounding(128,_jp_,1.)],_jo_],
               _ju_=[0,[0,_jt_,create_rounding(64,_js_,1.)],_jr_],
               _jx_=[0,[0,_jw_,create_rounding(64,_jv_,1.)],_ju_],
               _jA_=[0,[0,_jz_,create_rounding(64,_jy_,1.)],_jx_],
               _jD_=[0,[0,_jC_,create_rounding(64,_jB_,1.)],_jA_],
               _jG_=[0,[0,_jF_,create_rounding(32,_jE_,1.)],_jD_],
               _jJ_=[0,[0,_jI_,create_rounding(32,_jH_,1.)],_jG_],
               _jM_=[0,[0,_jL_,create_rounding(32,_jK_,1.)],_jJ_],
               _jP_=[0,[0,_jO_,create_rounding(32,_jN_,1.)],_jM_],
               _jS_=[0,[0,_jR_,create_rounding(16,_jQ_,1.)],_jP_],
               _jV_=[0,[0,_jU_,create_rounding(16,_jT_,1.)],_jS_],
               _jY_=[0,[0,_jX_,create_rounding(16,_jW_,1.)],_jV_],
               rounding_table=[0,[0,_j0_,create_rounding(16,_jZ_,1.)],_jY_],
               string_to_rounding=
                function(name)
                 {try
                   {var _MY_=assoc(name,rounding_table);return _MY_}
                  catch(_MZ_)
                   {_MZ_ = caml_wrap_exception(_MZ_);
                    if(_MZ_ === Not_found)
                     return failwith(symbol(_j2_,symbol(name,_j1_)));
                    throw _MZ_}},
               rounding_type_to_string=
                function(rnd_type)
                 {switch(rnd_type)
                   {case 0:return _j3_;
                    case 1:return _j4_;
                    case 2:return _j5_;
                    default:return _j6_}},
               rounding_to_string=
                function(rnd)
                 {try
                   {var _MW_=rev_assoc(rnd,rounding_table);return _MW_}
                  catch(_MX_)
                   {_MX_ = caml_wrap_exception(_MX_);
                    if(_MX_ === Not_found)
                     {var
                       _MR_=rnd[3],
                       _MS_=rnd[2],
                       _MT_=rnd[4],
                       _MU_=rounding_type_to_string(rnd[6]),
                       _MV_=rnd[5][1];
                      return caml_call5(sprintf(_j7_),_MV_,_MU_,_MT_,_MS_,_MR_)}
                    throw _MX_}},
               get_eps=
                function(exp)
                 {if(0 === exp)return 0.;
                  var f=caml_ldexp_float(1.,exp);
                  return f == 0.?caml_ldexp_float(1.,-1074):f},
               _j8_=0,
               mk_pos_bin_float=function(_MP_,_MQ_){return [0,_j8_,_MP_,_MQ_]},
               bf0=mk_pos_bin_float(rem,0),
               num_of_bin_float=
                function(x)
                 {var _MO_=power_num(_j9_,[0,x[3]]),v=mult_num([1,x[2]],_MO_);
                  return x[1]?minus_num(v):v},
               bin_float_of_num=
                function(p,rnd,r)
                 {if(0 < p)
                   {var
                     half=div_num(_j$_,_j__),
                     next=
                      function(m,e)
                       {switch(m[0])
                         {case 0:
                           var
                            i=m[1],
                            t=
                             i === 2147483647
                              ?[1,succ_big_int(big_int_of_int(i))]
                              :[0,i + 1 | 0];
                           break;
                          case 1:var bi=m[1],t=num_of_big_int(succ_big_int(bi));break;
                          default:var r=m[1],t=[2,add_int_ratio(1,r)]}
                        return eq_num(t,power_num(_ka_,[0,p]))
                                ?[0,div_num(t,_kb_),e + 1 | 0]
                                :[0,t,e]},
                     bin_float_of_pos_num=
                      function(rnd,r$3)
                       {var
                         n=log2_num(r$3),
                         k=(n + 1 | 0) - p | 0,
                         n$0=mult_num(power_num(_kc_,[0,- k | 0]),r$3);
                        switch(n$0[0])
                         {case 0:var low=n$0;break;
                          case 1:var low=n$0;break;
                          default:
                           var r$2=n$0[1];
                           if(0 === r$2[2][1])
                            var _MJ_=failwith_zero(_fh_);
                           else
                            if(0 === sign_ratio(r$2))
                             var _MJ_=rem;
                            else
                             var
                              _ME_=abs_big_int(r$2[2]),
                              _MJ_=
                               report_sign_ratio(r$2,div_big_int(abs_big_int(r$2[1]),_ME_));
                           var low=num_of_big_int(_MJ_)}
                        if(eq_num(low,n$0))
                         var m=low,e=k;
                        else
                         if(1 === rnd)
                          var _ML_=next(low,k),m=_ML_[1],e=_ML_[2];
                         else
                          if(0 === rnd)
                           {var
                             d=sub_num(n$0,low),
                             match=compare_num(d,half),
                             switcher=match + 1 | 0,
                             switch$0=0;
                            if(2 < switcher >>> 0)
                             switch$0 = 1;
                            else
                             {var switch$1=0;
                              switch(switcher)
                               {case 0:var _MN_=[0,low,k];break;
                                case 1:switch$0 = 1;switch$1 = 1;break;
                                default:var _MN_=next(low,k)}
                              if(! switch$1)var m=_MN_[1],e=_MN_[2]}
                            if(switch$0)
                             {switch(low[0])
                               {case 0:
                                 var
                                  i2$1=n2[1],
                                  r$0=caml_mod(low[1],i2$1),
                                  r$1=0 <= r$0?r$0:0 < i2$1?r$0 + i2$1 | 0:r$0 - i2$1 | 0,
                                  _MK_=[0,r$1];
                                 break;
                                case 1:
                                 var
                                  i2$2=n2[1],
                                  _MI_=low[1],
                                  bi2=big_int_of_int(i2$2),
                                  _MK_=num_of_big_int(quomod_big_int(_MI_,bi2)[2]);
                                 break;
                                default:
                                 switch(low[0])
                                  {case 0:
                                    var
                                     _MF_=low[1],
                                     i2=n2[1],
                                     q=caml_div(_MF_,i2),
                                     r=caml_mod(_MF_,i2),
                                     q$0=0 <= r?q:0 < i2?q - 1 | 0:q + 1 | 0,
                                     _MH_=[0,q$0];
                                    break;
                                   case 1:
                                    var
                                     i2$0=n2[1],
                                     _MG_=low[1],
                                     _MH_=num_of_big_int(div_big_int(_MG_,big_int_of_int(i2$0)));
                                    break;
                                   default:
                                    var
                                     r1=low[1],
                                     i=n2[1],
                                     r2=ratio_of_int(i),
                                     _MH_=
                                      num_of_big_int
                                       (report_sign_ratio
                                         (r2,floor_ratio(div_ratio(r1,abs_ratio(r2)))))}
                                 var _MK_=sub_num(low,mult_num(n2,_MH_))}
                              if(0 === sign_num(_MK_))
                               var m=low,e=k;
                              else
                               var _MM_=next(low,k),m=_MM_[1],e=_MM_[2]}}
                          else
                           var m=low,e=k;
                        return mk_pos_bin_float(big_int_of_num(m),e)},
                     match=sign_num(r);
                    if(0 === match)return bf0;
                    if(1 === match)return bin_float_of_pos_num(rnd,r);
                    var switch$0=0;
                    if(0 !== rnd)
                     {var switcher=rnd - 1 | 0,switch$1=0;
                      switch(switcher)
                       {case 0:var _MD_=2;break;
                        case 1:var _MD_=1;break;
                        default:switch$1 = 1}
                      if(! switch$1){var rnd$0=_MD_;switch$0 = 1}}
                    if(! switch$0)var rnd$0=rnd;
                    var x=bin_float_of_pos_num(rnd$0,minus_num(r));
                    return [0,1 - x[1],x[2],x[3]]}
                  throw [0,Assert_failure,_kd_]},
               round_num=
                function(rnd,n)
                 {var f=bin_float_of_num(- rnd[2] | 0,rnd[6],n);
                  return num_of_bin_float(f)},
               is_exact_fp_const=
                function(rnd,n){return eq_num(round_num(rnd,n),n)},
               of_int=function(i){return [0,[0,i]]},
               of_float=function(f){return [0,num_of_float(f)]},
               is_rat=function(param){return 0 === param[0]?1:0},
               to_interval=
                function(param)
                 {if(0 === param[0]){var n=param[1];return interval_of_num(n)}
                  var v=param[1];
                  return v},
               to_float=
                function(param)
                 {if(0 === param[0])
                   {var n$2=param[1];
                    switch(n$2[0])
                     {case 0:var i=n$2[1];return i;
                      case 1:
                       var bi=n$2[1],n=num_bits_big_int(bi);
                       if(63 < n)
                        {var
                          n$0=n - 55 | 0,
                          top=shift_right_big_int(bi,n$0),
                          exact=eq_big_int(bi,shift_left_big_int(top,n$0));
                         return caml_ldexp_float
                                 (round_big_int_to_float(top,exact),n$0)}
                       return caml_int64_to_float(int64_of_big_int(bi));
                      default:
                       var r=n$2[1],p=r[1],q=r[2];
                       if(0 === q[1])
                        {var match=p[1],switcher=match + 1 | 0;
                         if(2 < switcher >>> 0)throw [0,Assert_failure,_fl_];
                         switch(switcher)
                          {case 0:return upper_bound;
                           case 1:return nan;
                           default:return f_max}}
                       if(0 === p[1])return 0.;
                       var np=num_bits_big_int(p),nq=num_bits_big_int(q);
                       if(! (53 < np) && ! (53 < nq))
                        {var _MC_=caml_int64_to_float(int64_of_big_int(q));
                         return caml_int64_to_float(int64_of_big_int(p)) / _MC_}
                       var ap=abs_big_int(p),n$1=55 - (np - nq | 0) | 0;
                       if(0 <= n$1)
                        var p$0=shift_left_big_int(ap,n$1),q$0=q;
                       else
                        var q$1=shift_left_big_int(q,- n$1 | 0),p$0=ap,q$0=q$1;
                       var
                        match$0=quomod_big_int(p$0,q$0),
                        rem=match$0[2],
                        quo=match$0[1],
                        f=round_big_int_to_float(quo,0 === rem[1]?1:0),
                        f$0=caml_ldexp_float(f,- n$1 | 0);
                       return 0 <= p[1]?f$0:- f$0}}
                  var v=param[1];
                  return 0.5 * (v[1] + v[2])},
               to_num=
                function(param)
                 {if(0 === param[0]){var n=param[1];return n}
                  return failwith(_kg_)},
               to_int=
                function(c)
                 {var param=to_num(c);
                  switch(param[0])
                   {case 0:var i=param[1];return i;
                    case 1:var bi=param[1];return int_of_big_int(bi);
                    default:
                     var r=param[1];
                     if(is_integer_ratio(r) && is_int_big_int(r[1]))
                      return int_of_big_int(r[1]);
                     return failwith(_fi_)}},
               low_bound_to_num=
                function(param)
                 {if(0 === param[0]){var n=param[1];return n}
                  var v=param[1];
                  return num_of_float(v[1])},
               high_bound_to_num=
                function(param)
                 {if(0 === param[0]){var n=param[1];return n}
                  var v=param[1];
                  return num_of_float(v[2])},
               mk_neg=function(a){return [3,0,a]},
               mk_abs=function(a){return [3,1,a]},
               mk_sqrt=function(a){return [3,3,a]},
               mk_sin=function(a){return [3,4,a]},
               mk_cos=function(a){return [3,5,a]},
               mk_sinh=function(a){return [3,12,a]},
               mk_cosh=function(a){return [3,13,a]},
               mk_add=function(a,b){return [4,2,a,b]},
               mk_sub=function(a,b){return [4,3,a,b]},
               mk_mul=function(a,b){return [4,4,a,b]},
               mk_div=function(a,b){return [4,5,a,b]},
               mk_abs_err=function(t,x){return [4,8,t,x]},
               mk_floor_power2=function(a){return [3,18,a]},
               mk_ulp=
                function(param,x)
                 {var
                   e_min=param[2],
                   prec=param[1],
                   p=[0,of_int(prec)],
                   e=[0,of_int(e_min)];
                  return [5,1,[0,p,[0,e,[0,x,0]]]]},
               mk_int_const=function(i){return [0,of_int(i)]},
               mk_num_const=function(n){return [0,[0,n]]},
               mk_float_const=function(f){return [0,of_float(f)]},
               mk_interval_const=
                function(v)
                 {if(v[1] == v[2])
                   var _MB_=of_float(v[1]);
                  else
                   {var switch$0=0;
                    if(v[1] < v[2] && upper_bound < v[2] && v[1] < f_max)
                     {var _MB_=[1,v];switch$0 = 1}
                    if(! switch$0)var _MB_=failwith(symbol(_kf_,_gJ_(_ke_,v)))}
                  return [0,_MB_]},
               const_0=mk_int_const(0),
               const_1=mk_int_const(1),
               const_2=mk_int_const(2);
              mk_int_const(3);
              mk_int_const(4);
              mk_int_const(5);
              var
               u_op_name=
                function(param)
                 {switch(param)
                   {case 0:return _kh_;
                    case 1:return _ki_;
                    case 2:return _kj_;
                    case 3:return _kk_;
                    case 4:return _kl_;
                    case 5:return _km_;
                    case 6:return _kn_;
                    case 7:return _ko_;
                    case 8:return _kp_;
                    case 9:return _kq_;
                    case 10:return _kr_;
                    case 11:return _ks_;
                    case 12:return _kt_;
                    case 13:return _ku_;
                    case 14:return _kv_;
                    case 15:return _kw_;
                    case 16:return _kx_;
                    case 17:return _ky_;
                    default:return _kz_}},
               bin_op_name=
                function(param)
                 {switch(param)
                   {case 0:return _kA_;
                    case 1:return _kB_;
                    case 2:return _kC_;
                    case 3:return _kD_;
                    case 4:return _kE_;
                    case 5:return _kF_;
                    case 6:return _kG_;
                    case 7:return _kH_;
                    default:return _kI_}},
               gen_op_name=function(param){return 0 === param?_kJ_:_kK_},
               eq=
                function(e1,e2)
                 {var e1$0=e1,e2$0=e2;
                  for(;;)
                   {switch(e1$0[0])
                     {case 0:
                       if(0 === e2$0[0])
                        {var c2=e2$0[1],c1=e1$0[1];
                         if(0 === c1[0])
                          {var _Mt_=c1[1];
                           if(0 === c2[0]){var n2=c2[1];return eq_num(_Mt_,n2)}}
                         else
                          {var _Mu_=c1[1];
                           if(0 !== c2[0])
                            {var
                              v2=c2[1],
                              _Mv_=_Mu_[1] == v2[1]?1:0,
                              _Mw_=_Mv_?_Mu_[2] == v2[2]?1:0:_Mv_;
                             return _Mw_}}
                         return 0}
                       break;
                      case 1:
                       if(1 === e2$0[0])
                        {var v2$0=e2$0[1],v1=e1$0[1];
                         return caml_string_equal(v1,v2$0)}
                       break;
                      case 2:
                       if(2 === e2$0[0])
                        {var a2=e2$0[2],r2=e2$0[1],a1=e1$0[2],r1=e1$0[1];
                         if(caml_equal(r1,r2)){var e1$0=a1,e2$0=a2;continue}}
                       break;
                      case 3:
                       if(3 === e2$0[0])
                        {var a2$0=e2$0[2],t2=e2$0[1],a1$0=e1$0[2],t1=e1$0[1];
                         if(t1 === t2){var e1$0=a1$0,e2$0=a2$0;continue}}
                       break;
                      case 4:
                       if(4 === e2$0[0])
                        {var
                          b2=e2$0[3],
                          a2$1=e2$0[2],
                          t2$0=e2$0[1],
                          b1=e1$0[3],
                          a1$1=e1$0[2],
                          t1$0=e1$0[1];
                         if(t1$0 === t2$0)
                          {var _Mx_=eq(a1$1,a2$1);
                           if(_Mx_){var e1$0=b1,e2$0=b2;continue}
                           return _Mx_}}
                       break;
                      default:
                       if(5 === e2$0[0])
                        {var as2=e2$0[2],t2$1=e2$0[1],as1=e1$0[2],t1$1=e1$0[1];
                         if(t1$1 === t2$1)
                          {var _My_=1,_Mz_=zip(as1,as2);
                           return itlist
                                   (function(param,x)
                                     {var a2=param[2],a1=param[1],_MA_=eq(a1,a2),x$0=_MA_?x:_MA_;
                                      return x$0},
                                    _Mz_,
                                    _My_)}}}
                    return 0}},
               ExprHashtbl=Make([0,eq,hash]),
               vars_in_expr=
                function(e)
                 {var e$0=e;
                  for(;;)
                   switch(e$0[0])
                    {case 0:return 0;
                     case 1:var v=e$0[1];return [0,v,0];
                     case 2:var e$1=e$0[2],e$0=e$1;continue;
                     case 3:var e$2=e$0[2],e$0=e$2;continue;
                     case 4:
                      var a2=e$0[3],a1=e$0[2],_Ms_=vars_in_expr(a2);
                      return union$0(vars_in_expr(a1),_Ms_);
                     default:
                      var args=e$0[2],vs=map$0(vars_in_expr,args);
                      return itlist(union$0,vs,0)}},
               is_ref_var=
                function(param)
                 {if(1 === param[0])
                   {var v=param[1];if(starts_with(v,_kL_))return 1}
                  return 0},
               mk_ref_var=
                function(i)
                 {return [1,symbol(_kM_,caml_string_of_jsbytes("" + i))]},
               index_of_ref_var=
                function(param)
                 {if(1 === param[0])
                   {var v=param[1];
                    if(starts_with(v,_kO_))
                     {var last=caml_ml_string_length(v),switch$0=0,first=4;
                      if(! (last <= 4) && ! (last <= 4))
                       {var _Mr_=sub$0(v,first,min(last,last) - 4 | 0);
                        switch$0 = 1}
                      if(! switch$0)var _Mr_=_g6_;
                      return caml_int_of_string(_Mr_)}}
                  return failwith(_kN_)},
               expr_ref_list_of_expr=
                function(ex)
                 {var
                   hc=caml_call1(ExprHashtbl[1],128),
                   hi=caml_call1(ExprHashtbl[1],128);
                  function get_count(ex)
                   {try
                     {var _Mp_=caml_call2(ExprHashtbl[7],hc,ex);return _Mp_}
                    catch(_Mq_)
                     {_Mq_ = caml_wrap_exception(_Mq_);
                      if(_Mq_ === Not_found)return 0;
                      throw _Mq_}}
                  function get_index(ex)
                   {try
                     {var _Mn_=caml_call2(ExprHashtbl[7],hi,ex);return _Mn_}
                    catch(_Mo_)
                     {_Mo_ = caml_wrap_exception(_Mo_);
                      if(_Mo_ === Not_found)return -1;
                      throw _Mo_}}
                  function count(ex)
                   {var ex$0=ex;
                    for(;;)
                     {var _Mm_=1 + get_count(ex$0) | 0;
                      caml_call3(ExprHashtbl[10],hc,ex$0,_Mm_);
                      switch(ex$0[0])
                       {case 2:var ex$1=ex$0[2],ex$0=ex$1;continue;
                        case 3:var ex$2=ex$0[2],ex$0=ex$2;continue;
                        case 4:
                         var ex$3=ex$0[3],arg1=ex$0[2];
                         count(arg1);
                         var ex$0=ex$3;
                         continue;
                        case 5:var args=ex$0[2];return iter$0(count,args);
                        default:return 0}}}
                  function find_common(acc,ex)
                   {if(1 < ex[0])
                     {switch(ex[0])
                       {case 2:
                         var
                          arg=ex[2],
                          rnd=ex[1],
                          match$0=find_common(acc,arg),
                          arg$0=match$0[2],
                          acc$1=match$0[1],
                          match=[0,acc$1,[2,rnd,arg$0]];
                         break;
                        case 3:
                         var
                          arg$1=ex[2],
                          op=ex[1],
                          match$1=find_common(acc,arg$1),
                          arg$2=match$1[2],
                          acc$2=match$1[1],
                          match=[0,acc$2,[3,op,arg$2]];
                         break;
                        case 4:
                         var
                          arg2=ex[3],
                          arg1=ex[2],
                          op$0=ex[1],
                          match$2=find_common(acc,arg1),
                          arg1$0=match$2[2],
                          acc$3=match$2[1],
                          match$3=find_common(acc$3,arg2),
                          arg2$0=match$3[2],
                          acc$4=match$3[1],
                          match=[0,acc$4,[4,op$0,arg1$0,arg2$0]];
                         break;
                        case 5:
                         var
                          args=ex[2],
                          op$1=ex[1],
                          _Ml_=[0,acc,0],
                          match$4=
                           fold_left
                            (function(param,arg)
                              {var
                                args=param[2],
                                acc=param[1],
                                match=find_common(acc,arg),
                                arg$0=match[2],
                                acc$0=match[1];
                               return [0,acc$0,[0,arg$0,args]]},
                             _Ml_,
                             args),
                          args$0=match$4[2],
                          acc$5=match$4[1],
                          match=[0,acc$5,[5,op$1,rev(args$0)]];
                         break;
                        default:var match=failwith(_kP_)}
                      var ex$0=match[2],acc$0=match[1],i=get_index(ex);
                      if(0 <= i)return [0,acc$0,mk_ref_var(i)];
                      if(2 <= get_count(ex))
                       {var i$0=length(acc$0);
                        caml_call3(ExprHashtbl[5],hi,ex,i$0);
                        return [0,[0,ex$0,acc$0],mk_ref_var(i$0)]}
                      return [0,acc$0,ex$0]}
                    return [0,acc,ex]}
                  count(ex);
                  var match=find_common(0,ex),ex$0=match[2],acc=match[1];
                  return rev([0,ex$0,acc])},
               results=create$0(0,100),
               bad_chars=regexp(_kQ_),
               fix_name=
                function(name)
                 {var res=global_replace(bad_chars,_kR_,name);
                  try
                   {var
                     t=find(results,res),
                     res$0=
                      caml_string_equal(t,name)?res:fix_name(symbol(_kS_,name));
                    return res$0}
                  catch(_Mk_)
                   {_Mk_ = caml_wrap_exception(_Mk_);
                    if(_Mk_ === Not_found){add(results,res,name);return res}
                    throw _Mk_}},
               Make$0=
                function(Printer)
                 {function print_fmt(opt,fmt,expr)
                   {if(opt)var sth=opt[1],margin=sth;else var margin=max_int;
                    pp_print_flush(fmt,0);
                    var m=fmt[6];
                    pp_set_margin(fmt,margin);
                    caml_call2(Printer[1],fmt,expr);
                    pp_print_flush(fmt,0);
                    return pp_set_margin(fmt,m)}
                  function print_std(margin,expr)
                   {return print_fmt(margin,fmt,expr)}
                  function print_str(margin,expr)
                   {return write_to_string
                            (function(_Mi_,_Mj_){return print_fmt(margin,_Mi_,_Mj_)},
                             expr)}
                  return [0,print_fmt,print_std,print_str]},
               print=
                function(fmt,expr)
                 {switch(expr[0])
                   {case 0:
                     var c=expr[1];
                     if(0 === c[0])
                      {var n=c[1];
                       if(is_integer_num(n) && 0 <= sign_num(n))
                        {var _L7_=string_of_num(n);
                         return caml_call2(fprintf$0(fmt),_kT_,_L7_)}
                       var _L8_=string_of_num(n);
                       return caml_call2(fprintf$0(fmt),_kU_,_L8_)}
                     var v=c[1],_L9_=v[2],_L__=v[1];
                     return caml_call3(fprintf$0(fmt),_kV_,_L__,_L9_);
                    case 1:
                     var v$0=expr[1];return caml_call2(fprintf$0(fmt),_kW_,v$0);
                    case 2:
                     var arg=expr[2],rnd=expr[1],_L$_=rounding_to_string(rnd);
                     return caml_call4(fprintf$0(fmt),_kX_,_L$_,print,arg);
                    case 3:
                     var arg$0=expr[2],op=expr[1];
                     switch(op)
                      {case 0:return caml_call3(fprintf$0(fmt),_kY_,print,arg$0);
                       case 1:return caml_call3(fprintf$0(fmt),_kZ_,print,arg$0);
                       case 2:return caml_call3(fprintf$0(fmt),_k0_,print,arg$0);
                       case 3:return caml_call3(fprintf$0(fmt),_k1_,print,arg$0);
                       case 4:return caml_call3(fprintf$0(fmt),_k2_,print,arg$0);
                       case 5:return caml_call3(fprintf$0(fmt),_k3_,print,arg$0);
                       case 6:return caml_call3(fprintf$0(fmt),_k4_,print,arg$0);
                       case 7:return caml_call3(fprintf$0(fmt),_k5_,print,arg$0);
                       case 8:return caml_call3(fprintf$0(fmt),_k6_,print,arg$0);
                       case 9:return caml_call3(fprintf$0(fmt),_k7_,print,arg$0);
                       case 10:return caml_call3(fprintf$0(fmt),_k8_,print,arg$0);
                       case 11:return caml_call3(fprintf$0(fmt),_k9_,print,arg$0);
                       case 12:return caml_call3(fprintf$0(fmt),_k__,print,arg$0);
                       case 13:return caml_call3(fprintf$0(fmt),_k$_,print,arg$0);
                       case 14:return caml_call3(fprintf$0(fmt),_la_,print,arg$0);
                       case 15:return caml_call3(fprintf$0(fmt),_lb_,print,arg$0);
                       case 16:return caml_call3(fprintf$0(fmt),_lc_,print,arg$0);
                       case 17:return caml_call3(fprintf$0(fmt),_ld_,print,arg$0);
                       default:return caml_call3(fprintf$0(fmt),_le_,print,arg$0)}
                    case 4:
                     var arg2=expr[3],arg1=expr[2],op$0=expr[1];
                     switch(op$0)
                      {case 0:
                        return caml_call5(fprintf$0(fmt),_lf_,print,arg1,print,arg2);
                       case 1:
                        return caml_call5(fprintf$0(fmt),_lg_,print,arg1,print,arg2);
                       case 2:
                        return caml_call5(fprintf$0(fmt),_lh_,print,arg1,print,arg2);
                       case 3:
                        return caml_call5(fprintf$0(fmt),_li_,print,arg1,print,arg2);
                       case 4:
                        return caml_call5(fprintf$0(fmt),_lj_,print,arg1,print,arg2);
                       case 5:
                        return caml_call5(fprintf$0(fmt),_lk_,print,arg1,print,arg2);
                       case 6:
                        return caml_call5(fprintf$0(fmt),_ll_,print,arg1,print,arg2);
                       case 7:
                        return caml_call5(fprintf$0(fmt),_lm_,print,arg1,print,arg2);
                       default:
                        return caml_call5(fprintf$0(fmt),_ln_,print,arg1,print,arg2)}
                    default:
                     var args=expr[2],op$1=expr[1];
                     if(0 === op$1)
                      {if(args)
                        {var _Ma_=args[2];
                         if(_Ma_)
                          {var _Mb_=_Ma_[2];
                           if(_Mb_ && ! _Mb_[2])
                            {var a3=_Mb_[1],a2=_Ma_[1],a1=args[1];
                             return caml_call7
                                     (fprintf$0(fmt),_lp_,print,a1,print,a2,print,a3)}}}}
                     else
                      if(args)
                       {var _Mc_=args[1];
                        if(0 === _Mc_[0])
                         {var _Md_=args[2];
                          if(_Md_)
                           {var _Me_=_Md_[1];
                            if(0 === _Me_[0])
                             {var _Mf_=_Md_[2];
                              if(_Mf_ && ! _Mf_[2])
                               {var
                                 arg$1=_Mf_[1],
                                 e=_Me_[1],
                                 p=_Mc_[1],
                                 _Mg_=to_int(e),
                                 _Mh_=to_int(p);
                                return caml_call5(fprintf$0(fmt),_lq_,_Mh_,_Mg_,print,arg$1)}}}}}
                     return failwith(symbol(_lo_,gen_op_name(op$1)))}},
               InfoPrinter=[0,print],
               print$0=
                function(fmt,expr)
                 {switch(expr[0])
                   {case 0:
                     var c=expr[1],v=to_interval(c),_LV_=v[2],_LW_=v[1];
                     return caml_call3(fprintf$0(fmt),_lr_,_LW_,_LV_);
                    case 1:
                     var v$0=expr[1];
                     if(is_ref_var(expr))
                      {var _LX_=index_of_ref_var(expr);
                       return caml_call2(fprintf$0(fmt),_ls_,_LX_)}
                     var _LY_=fix_name(v$0);
                     return caml_call2(fprintf$0(fmt),_lt_,_LY_);
                    case 2:
                     var rnd=expr[1],rnd_str=rounding_to_string(rnd);
                     return failwith(symbol(_lu_,rnd_str));
                    case 3:
                     var arg=expr[2],op=expr[1];
                     switch(op)
                      {case 0:return caml_call3(fprintf$0(fmt),_lv_,print$0,arg);
                       case 1:return caml_call3(fprintf$0(fmt),_lw_,print$0,arg);
                       case 2:return caml_call3(fprintf$0(fmt),_lx_,print$0,arg);
                       case 3:return caml_call3(fprintf$0(fmt),_ly_,print$0,arg);
                       case 4:return caml_call3(fprintf$0(fmt),_lz_,print$0,arg);
                       case 5:return caml_call3(fprintf$0(fmt),_lA_,print$0,arg);
                       case 6:return caml_call3(fprintf$0(fmt),_lB_,print$0,arg);
                       case 7:return caml_call3(fprintf$0(fmt),_lC_,print$0,arg);
                       case 8:return caml_call3(fprintf$0(fmt),_lD_,print$0,arg);
                       case 9:return caml_call3(fprintf$0(fmt),_lE_,print$0,arg);
                       case 10:return caml_call3(fprintf$0(fmt),_lF_,print$0,arg);
                       case 11:return caml_call3(fprintf$0(fmt),_lG_,print$0,arg);
                       case 12:return caml_call3(fprintf$0(fmt),_lH_,print$0,arg);
                       case 13:return caml_call3(fprintf$0(fmt),_lI_,print$0,arg);
                       case 14:return caml_call3(fprintf$0(fmt),_lJ_,print$0,arg);
                       case 15:return caml_call3(fprintf$0(fmt),_lK_,print$0,arg);
                       case 16:return caml_call3(fprintf$0(fmt),_lL_,print$0,arg);
                       case 17:return caml_call3(fprintf$0(fmt),_lM_,print$0,arg);
                       default:return caml_call3(fprintf$0(fmt),_lN_,print$0,arg)}
                    case 4:
                     var arg2=expr[3],arg1=expr[2],op$0=expr[1];
                     switch(op$0)
                      {case 0:
                        return caml_call5
                                (fprintf$0(fmt),_lO_,print$0,arg1,print$0,arg2);
                       case 1:
                        return caml_call5
                                (fprintf$0(fmt),_lP_,print$0,arg1,print$0,arg2);
                       case 2:
                        return caml_call5
                                (fprintf$0(fmt),_lQ_,print$0,arg1,print$0,arg2);
                       case 3:
                        return caml_call5
                                (fprintf$0(fmt),_lR_,print$0,arg1,print$0,arg2);
                       case 4:
                        return caml_call5
                                (fprintf$0(fmt),_lS_,print$0,arg1,print$0,arg2);
                       case 5:
                        return caml_call5
                                (fprintf$0(fmt),_lT_,print$0,arg1,print$0,arg2);
                       case 6:
                        if(0 === arg2[0])
                         {var _LZ_=arg2[1];
                          if(0 === _LZ_[0])
                           {var n=_LZ_[1];
                            if(is_integer_num(n))
                             {var _L0_=string_of_num(n);
                              return caml_call4(fprintf$0(fmt),_lU_,print$0,arg1,_L0_)}}}
                        return failwith(_lV_);
                       case 7:
                        return caml_call5
                                (fprintf$0(fmt),_lW_,print$0,arg1,print$0,arg2);
                       default:
                        return caml_call5
                                (fprintf$0(fmt),_lX_,print$0,arg1,print$0,arg2)}
                    default:
                     var args=expr[2],op$1=expr[1];
                     if(0 !== op$1 && args)
                      {var _L1_=args[1];
                       if(0 === _L1_[0])
                        {var _L2_=args[2];
                         if(_L2_)
                          {var _L3_=_L2_[1];
                           if(0 === _L3_[0])
                            {var _L4_=_L2_[2];
                             if(_L4_ && ! _L4_[2])
                              {var
                                arg$0=_L4_[1],
                                e=_L3_[1],
                                p=_L1_[1],
                                _L5_=to_int(e),
                                _L6_=to_int(p);
                               return caml_call5
                                       (fprintf$0(fmt),_lZ_,_L6_,_L5_,print$0,arg$0)}}}}}
                     return failwith(symbol(_lY_,gen_op_name(op$1)))}},
               OCamlIntervalPrinter=[0,print$0],
               print$1=
                function(fmt,expr)
                 {switch(expr[0])
                   {case 0:
                     var c=expr[1];
                     if(0 === c[0])
                      {var n=c[1],_LS_=string_of_num(n);
                       return caml_call2(fprintf$0(fmt),_l0_,_LS_)}
                     var
                      v=c[1],
                      a=string_of_num(num_of_float(v[1])),
                      b=string_of_num(num_of_float(v[2]));
                     return caml_call3(fprintf$0(fmt),_l1_,a,b);
                    case 1:
                     var v$0=expr[1];return caml_call2(fprintf$0(fmt),_l2_,v$0);
                    case 2:
                     var arg=expr[2],rnd=expr[1],rnd_str=rounding_to_string(rnd);
                     return caml_call4(fprintf$0(fmt),_l3_,rnd_str,print$1,arg);
                    case 3:
                     var arg$0=expr[2],op=expr[1];
                     switch(op)
                      {case 0:
                        return caml_call3(fprintf$0(fmt),_l4_,print$1,arg$0);
                       case 1:return caml_call3(fprintf$0(fmt),_l5_,print$1,arg$0);
                       case 2:return caml_call3(fprintf$0(fmt),_l6_,print$1,arg$0);
                       case 3:return caml_call3(fprintf$0(fmt),_l7_,print$1,arg$0);
                       case 4:return caml_call3(fprintf$0(fmt),_l8_,print$1,arg$0);
                       case 5:return caml_call3(fprintf$0(fmt),_l9_,print$1,arg$0);
                       case 6:return caml_call3(fprintf$0(fmt),_l__,print$1,arg$0);
                       case 7:return caml_call3(fprintf$0(fmt),_l$_,print$1,arg$0);
                       case 8:return caml_call3(fprintf$0(fmt),_ma_,print$1,arg$0);
                       case 9:return caml_call3(fprintf$0(fmt),_mb_,print$1,arg$0);
                       case 10:
                        return caml_call3(fprintf$0(fmt),_mc_,print$1,arg$0);
                       case 11:
                        return caml_call3(fprintf$0(fmt),_md_,print$1,arg$0);
                       case 12:
                        return caml_call3(fprintf$0(fmt),_me_,print$1,arg$0);
                       case 13:
                        return caml_call3(fprintf$0(fmt),_mf_,print$1,arg$0);
                       case 14:
                        return caml_call3(fprintf$0(fmt),_mg_,print$1,arg$0);
                       case 15:
                        return caml_call3(fprintf$0(fmt),_mh_,print$1,arg$0);
                       case 16:
                        return caml_call3(fprintf$0(fmt),_mi_,print$1,arg$0);
                       case 17:
                        return caml_call3(fprintf$0(fmt),_mj_,print$1,arg$0);
                       default:return caml_call3(fprintf$0(fmt),_mk_,print$1,arg$0)}
                    case 4:
                     var arg2=expr[3],arg1=expr[2],op$0=expr[1];
                     switch(op$0)
                      {case 0:
                        return caml_call5
                                (fprintf$0(fmt),_ml_,print$1,arg1,print$1,arg2);
                       case 1:
                        return caml_call5
                                (fprintf$0(fmt),_mm_,print$1,arg1,print$1,arg2);
                       case 2:
                        return caml_call5
                                (fprintf$0(fmt),_mn_,print$1,arg1,print$1,arg2);
                       case 3:
                        return caml_call5
                                (fprintf$0(fmt),_mo_,print$1,arg1,print$1,arg2);
                       case 4:
                        return caml_call5
                                (fprintf$0(fmt),_mp_,print$1,arg1,print$1,arg2);
                       case 5:
                        return caml_call5
                                (fprintf$0(fmt),_mq_,print$1,arg1,print$1,arg2);
                       case 6:
                        return caml_call5
                                (fprintf$0(fmt),_mr_,print$1,arg1,print$1,arg2);
                       default:return failwith(symbol(_ms_,bin_op_name(op$0)))}
                    default:
                     var args=expr[2],op$1=expr[1];
                     if(0 === op$1 && args)
                      {var _LT_=args[2];
                       if(_LT_)
                        {var _LU_=_LT_[2];
                         if(_LU_ && ! _LU_[2])
                          {var a3=_LU_[1],a2=_LT_[1],a1=args[1];
                           return caml_call7
                                   (fprintf$0(fmt),_mu_,print$1,a1,print$1,a2,print$1,a3)}}}
                     return failwith(symbol(_mt_,gen_op_name(op$1)))}},
               FPCorePrinter=[0,print$1],
               print$2=
                function(fmt,expr)
                 {switch(expr[0])
                   {case 0:
                     var c=expr[1],_LN_=to_float(c);
                     return caml_call2(fprintf$0(fmt),_mv_,_LN_);
                    case 1:
                     var v=expr[1],_LO_=fix_name(v);
                     return caml_call2(fprintf$0(fmt),_mw_,_LO_);
                    case 2:
                     var arg=expr[2],rnd=expr[1],_LP_=rounding_to_string(rnd);
                     return caml_call4(fprintf$0(fmt),_mx_,_LP_,print$2,arg);
                    case 3:
                     var arg$0=expr[2],op=expr[1];
                     switch(op)
                      {case 0:
                        return caml_call3(fprintf$0(fmt),_my_,print$2,arg$0);
                       case 1:return caml_call3(fprintf$0(fmt),_mz_,print$2,arg$0);
                       case 2:return caml_call3(fprintf$0(fmt),_mA_,print$2,arg$0);
                       case 3:return caml_call3(fprintf$0(fmt),_mB_,print$2,arg$0);
                       case 4:return caml_call3(fprintf$0(fmt),_mC_,print$2,arg$0);
                       case 5:return caml_call3(fprintf$0(fmt),_mD_,print$2,arg$0);
                       case 6:return caml_call3(fprintf$0(fmt),_mE_,print$2,arg$0);
                       case 7:return caml_call3(fprintf$0(fmt),_mF_,print$2,arg$0);
                       case 8:return caml_call3(fprintf$0(fmt),_mG_,print$2,arg$0);
                       case 9:return caml_call3(fprintf$0(fmt),_mH_,print$2,arg$0);
                       case 10:
                        return caml_call3(fprintf$0(fmt),_mI_,print$2,arg$0);
                       case 11:
                        return caml_call3(fprintf$0(fmt),_mJ_,print$2,arg$0);
                       case 12:
                        return caml_call3(fprintf$0(fmt),_mK_,print$2,arg$0);
                       case 13:
                        return caml_call3(fprintf$0(fmt),_mL_,print$2,arg$0);
                       case 14:
                        return caml_call3(fprintf$0(fmt),_mM_,print$2,arg$0);
                       case 15:
                        return caml_call3(fprintf$0(fmt),_mN_,print$2,arg$0);
                       case 16:
                        return caml_call3(fprintf$0(fmt),_mO_,print$2,arg$0);
                       case 17:
                        return caml_call3(fprintf$0(fmt),_mP_,print$2,arg$0);
                       default:return caml_call3(fprintf$0(fmt),_mQ_,print$2,arg$0)}
                    case 4:
                     var arg2=expr[3],arg1=expr[2],op$0=expr[1];
                     switch(op$0)
                      {case 0:
                        return caml_call5
                                (fprintf$0(fmt),_mR_,print$2,arg1,print$2,arg2);
                       case 1:
                        return caml_call5
                                (fprintf$0(fmt),_mS_,print$2,arg1,print$2,arg2);
                       case 2:
                        return caml_call5
                                (fprintf$0(fmt),_mT_,print$2,arg1,print$2,arg2);
                       case 3:
                        return caml_call5
                                (fprintf$0(fmt),_mU_,print$2,arg1,print$2,arg2);
                       case 4:
                        return caml_call5
                                (fprintf$0(fmt),_mV_,print$2,arg1,print$2,arg2);
                       case 5:
                        return caml_call5
                                (fprintf$0(fmt),_mW_,print$2,arg1,print$2,arg2);
                       case 6:
                        return caml_call5
                                (fprintf$0(fmt),_mX_,print$2,arg1,print$2,arg2);
                       case 7:
                        return caml_call5
                                (fprintf$0(fmt),_mY_,print$2,arg1,print$2,arg2);
                       default:
                        return caml_call5
                                (fprintf$0(fmt),_mZ_,print$2,arg1,print$2,arg2)}
                    default:
                     var args=expr[2],op$1=expr[1];
                     if(0 === op$1 && args)
                      {var _LQ_=args[2];
                       if(_LQ_)
                        {var _LR_=_LQ_[2];
                         if(_LR_ && ! _LR_[2])
                          {var a3=_LR_[1],a2=_LQ_[1],a1=args[1];
                           return caml_call7
                                   (fprintf$0(fmt),_m1_,print$2,a1,print$2,a2,print$2,a3)}}}
                     return failwith(symbol(_m0_,gen_op_name(op$1)))}},
               CPrinter=[0,print$2],
               print$3=
                function(fmt,expr)
                 {switch(expr[0])
                   {case 0:
                     var c=expr[1];
                     if(0 === c[0])
                      {var n=c[1],ns=s(numerator(n)),ds=s(denominator(n));
                       return caml_call3(fprintf$0(fmt),_m2_,ns,ds)}
                     return failwith(_m3_);
                    case 1:
                     var v=expr[1],_LK_=fix_name(v);
                     return caml_call2(fprintf$0(fmt),_m4_,_LK_);
                    case 2:
                     var rnd=expr[1],rnd_str=rounding_to_string(rnd);
                     return failwith(symbol(_m5_,rnd_str));
                    case 3:
                     var arg=expr[2],op=expr[1];
                     if(4 <= op)return failwith(symbol(_m6_,u_op_name(op)));
                     switch(op)
                      {case 0:return caml_call3(fprintf$0(fmt),_m7_,print$3,arg);
                       case 1:return caml_call3(fprintf$0(fmt),_m8_,print$3,arg);
                       case 2:return caml_call3(fprintf$0(fmt),_m9_,print$3,arg);
                       default:return caml_call3(fprintf$0(fmt),_m__,print$3,arg)}
                    case 4:
                     var arg2=expr[3],arg1=expr[2],op$0=expr[1];
                     switch(op$0)
                      {case 0:
                        return caml_call5
                                (fprintf$0(fmt),_m$_,print$3,arg1,print$3,arg2);
                       case 1:
                        return caml_call5
                                (fprintf$0(fmt),_na_,print$3,arg1,print$3,arg2);
                       case 2:
                        return caml_call5
                                (fprintf$0(fmt),_nb_,print$3,arg1,print$3,arg2);
                       case 3:
                        return caml_call5
                                (fprintf$0(fmt),_nc_,print$3,arg1,print$3,arg2);
                       case 4:
                        return caml_call5
                                (fprintf$0(fmt),_nd_,print$3,arg1,print$3,arg2);
                       case 5:
                        return caml_call5
                                (fprintf$0(fmt),_ne_,print$3,arg1,print$3,arg2);
                       case 6:
                        return caml_call5
                                (fprintf$0(fmt),_nf_,print$3,arg1,print$3,arg2);
                       default:return failwith(symbol(_ng_,bin_op_name(op$0)))}
                    default:
                     var args=expr[2],op$1=expr[1];
                     if(0 === op$1 && args)
                      {var _LL_=args[2];
                       if(_LL_)
                        {var _LM_=_LL_[2];
                         if(_LM_ && ! _LM_[2])
                          {var a3=_LM_[1],a2=_LL_[1],a1=args[1];
                           return caml_call7
                                   (fprintf$0(fmt),_ni_,print$3,a1,print$3,a2,print$3,a3)}}}
                     return failwith(symbol(_nh_,gen_op_name(op$1)))}},
               Z3PythonPrinter=[0,print$3],
               print$4=
                function(fmt,expr)
                 {switch(expr[0])
                   {case 0:
                     var c=expr[1],v=to_interval(c),_LF_=v[2],_LG_=v[1];
                     return caml_call3(fprintf$0(fmt),_nj_,_LG_,_LF_);
                    case 1:
                     var v$0=expr[1],_LH_=fix_name(v$0);
                     return caml_call2(fprintf$0(fmt),_nk_,_LH_);
                    case 2:
                     var rnd=expr[1],rnd_str=rounding_to_string(rnd);
                     return failwith(symbol(_nl_,rnd_str));
                    case 3:
                     var arg=expr[2],op=expr[1];
                     switch(op)
                      {case 0:return caml_call3(fprintf$0(fmt),_nm_,print$4,arg);
                       case 1:return caml_call3(fprintf$0(fmt),_nn_,print$4,arg);
                       case 2:return caml_call3(fprintf$0(fmt),_no_,print$4,arg);
                       case 3:return caml_call3(fprintf$0(fmt),_np_,print$4,arg);
                       case 4:return caml_call3(fprintf$0(fmt),_nq_,print$4,arg);
                       case 5:return caml_call3(fprintf$0(fmt),_nr_,print$4,arg);
                       case 6:return caml_call3(fprintf$0(fmt),_ns_,print$4,arg);
                       case 7:return caml_call3(fprintf$0(fmt),_nt_,print$4,arg);
                       case 8:return caml_call3(fprintf$0(fmt),_nu_,print$4,arg);
                       case 9:return caml_call3(fprintf$0(fmt),_nv_,print$4,arg);
                       case 10:return caml_call3(fprintf$0(fmt),_nw_,print$4,arg);
                       case 11:return caml_call3(fprintf$0(fmt),_nx_,print$4,arg);
                       case 12:return caml_call3(fprintf$0(fmt),_ny_,print$4,arg);
                       case 13:return caml_call3(fprintf$0(fmt),_nz_,print$4,arg);
                       case 14:return caml_call3(fprintf$0(fmt),_nA_,print$4,arg);
                       case 15:return caml_call3(fprintf$0(fmt),_nB_,print$4,arg);
                       case 16:return caml_call3(fprintf$0(fmt),_nC_,print$4,arg);
                       case 17:return caml_call3(fprintf$0(fmt),_nD_,print$4,arg);
                       default:return caml_call3(fprintf$0(fmt),_nE_,print$4,arg)}
                    case 4:
                     var arg2=expr[3],arg1=expr[2],op$0=expr[1];
                     switch(op$0)
                      {case 0:
                        return caml_call5
                                (fprintf$0(fmt),_nF_,print$4,arg1,print$4,arg2);
                       case 1:
                        return caml_call5
                                (fprintf$0(fmt),_nG_,print$4,arg1,print$4,arg2);
                       case 2:
                        return caml_call5
                                (fprintf$0(fmt),_nH_,print$4,arg1,print$4,arg2);
                       case 3:
                        return caml_call5
                                (fprintf$0(fmt),_nI_,print$4,arg1,print$4,arg2);
                       case 4:
                        return caml_call5
                                (fprintf$0(fmt),_nJ_,print$4,arg1,print$4,arg2);
                       case 5:
                        return caml_call5
                                (fprintf$0(fmt),_nK_,print$4,arg1,print$4,arg2);
                       case 6:
                        if(0 === arg2[0])
                         {var _LI_=arg2[1];
                          if(0 === _LI_[0])
                           {var n=_LI_[1];
                            if(is_integer_num(n))
                             {var _LJ_=string_of_num(n);
                              return caml_call4(fprintf$0(fmt),_nL_,print$4,arg1,_LJ_)}}}
                        return failwith(_nM_);
                       case 7:
                        return caml_call5
                                (fprintf$0(fmt),_nN_,print$4,arg1,print$4,arg2);
                       default:
                        return caml_call5
                                (fprintf$0(fmt),_nO_,print$4,arg1,print$4,arg2)}
                    default:
                     var op$1=expr[1];
                     return failwith(symbol(_nP_,gen_op_name(op$1)))}},
               GelpiaPrinter=[0,print$4],
               Info=Make$0(InfoPrinter),
               eval_float_expr=
                function(vars)
                 {function eval$0(expr)
                   {switch(expr[0])
                     {case 0:var c=expr[1];return to_float(c);
                      case 1:var v=expr[1];return caml_call1(vars,v);
                      case 2:
                       return failwith(symbol(_nQ_,caml_call2(Info[3],0,expr)));
                      case 3:
                       var arg=expr[2],op=expr[1],x=eval$0(arg);
                       switch(op)
                        {case 0:return - x;
                         case 1:return Math.abs(x);
                         case 2:return 1. / x;
                         case 3:return Math.sqrt(x);
                         case 4:return Math.sin(x);
                         case 5:return Math.cos(x);
                         case 6:return Math.tan(x);
                         case 7:return Math.asin(x);
                         case 8:return Math.acos(x);
                         case 9:return Math.atan(x);
                         case 10:return Math.exp(x);
                         case 11:return Math.log(x);
                         case 12:return caml_sinh_float(x);
                         case 13:return caml_cosh_float(x);
                         case 14:return caml_tanh_float(x);
                         case 15:return Math.log(x + Math.sqrt(x * x + 1.));
                         case 16:return Math.log(x + Math.sqrt(x * x - 1.));
                         case 17:return 0.5 * Math.log((1. + x) / (1. - x));
                         default:return floor_power2(x)}
                      case 4:
                       var
                        arg2=expr[3],
                        arg1=expr[2],
                        op$0=expr[1],
                        t=eval$0(arg1),
                        x$0=eval$0(arg2);
                       switch(op$0)
                        {case 0:return max(t,x$0);
                         case 1:return min(t,x$0);
                         case 2:return t + x$0;
                         case 3:return t - x$0;
                         case 4:return t * x$0;
                         case 5:return t / x$0;
                         case 6:return Math.pow(t,x$0);
                         case 7:
                          var switch$0=0;
                          if(0.5 * t <= x$0 && x$0 <= 2. * t)switch$0 = 1;
                          if(! switch$0)
                           {var switch$1=0;
                            if(! (2. * t <= x$0) || ! (x$0 <= 0.5 * t))switch$1 = 1;
                            if(switch$1)return t - x$0}
                          return 0.;
                         default:return t <= x$0?1.:x$0 <= - t?-1.:0.}
                      default:
                       var args=expr[2],op$1=expr[1],match=map$0(eval$0,args);
                       if(0 === op$1 && match)
                        {var _LD_=match[2];
                         if(_LD_)
                          {var _LE_=_LD_[2];
                           if(_LE_ && ! _LE_[2])
                            {var c$0=_LE_[1],b=_LD_[1],a=match[1];return a * b + c$0}}}
                       return failwith(symbol(_nR_,gen_op_name(op$1)))}}
                  return eval$0},
               eval_float_const_expr=
                eval_float_expr(function(v){return failwith(symbol(_nS_,v))}),
               eval_num_expr=
                function(vars)
                 {function eval$0(param)
                   {switch(param[0])
                     {case 0:
                       var c=param[1];
                       try
                        {var _Lz_=to_num(c);return _Lz_}
                       catch(_LC_)
                        {_LC_ = caml_wrap_exception(_LC_);
                         if(_LC_[1] === Failure)return failwith(_nT_);
                         throw _LC_}
                      case 1:var v=param[1];return caml_call1(vars,v);
                      case 2:
                       var arg=param[2],rnd=param[1];
                       return round_num(rnd,eval$0(arg));
                      case 3:
                       var arg$0=param[2],op=param[1],x=eval$0(arg$0);
                       if(3 <= op)return failwith(symbol(_nU_,u_op_name(op)));
                       switch(op)
                        {case 0:return minus_num(x);
                         case 1:return abs_num(x);
                         default:return div_num(one,x)}
                      case 4:
                       var
                        arg2=param[3],
                        arg1=param[2],
                        op$0=param[1],
                        x1=eval$0(arg1),
                        x2=eval$0(arg2);
                       switch(op$0)
                        {case 0:return max_num(x1,x2);
                         case 1:return min_num(x1,x2);
                         case 2:return add_num(x1,x2);
                         case 3:return sub_num(x1,x2);
                         case 4:return mult_num(x1,x2);
                         case 5:return div_num(x1,x2);
                         case 6:return power_num(x1,x2);
                         default:return failwith(symbol(_nV_,bin_op_name(op$0)))}
                      default:
                       var args=param[2],op$1=param[1],match=map$0(eval$0,args);
                       if(0 === op$1 && match)
                        {var _LA_=match[2];
                         if(_LA_)
                          {var _LB_=_LA_[2];
                           if(_LB_ && ! _LB_[2])
                            {var c$0=_LB_[1],b=_LA_[1],a=match[1];
                             return add_num(mult_num(a,b),c$0)}}}
                       return failwith(symbol(_nW_,gen_op_name(op$1)))}}
                  return eval$0},
               eval_num_const_expr=
                eval_num_expr(function(v){return failwith(symbol(_nX_,v))}),
               eval_interval_expr=
                function(vars)
                 {function eval$0(expr)
                   {switch(expr[0])
                     {case 0:var c=expr[1];return to_interval(c);
                      case 1:var v=expr[1];return caml_call1(vars,v);
                      case 2:
                       return failwith(symbol(_nY_,caml_call2(Info[3],0,expr)));
                      case 3:
                       var arg=expr[2],op=expr[1],x=eval$0(arg);
                       switch(op)
                        {case 0:return _go_(x);
                         case 1:return _gp_(x);
                         case 2:return _gA_(x);
                         case 3:return _gB_(x);
                         case 4:return _gF_(x);
                         case 5:return _gH_(x);
                         case 6:return _gO_(x);
                         case 7:return _gQ_(x);
                         case 8:return _gS_(x);
                         case 9:return _gU_(x);
                         case 10:return _gD_(x);
                         case 11:return _gE_(x);
                         case 12:return _gW_(x);
                         case 13:return _gY_(x);
                         case 14:return _g0_(x);
                         case 15:return asinh_I(x);
                         case 16:return acosh_I(x);
                         case 17:return atanh_I(x);
                         default:return floor_power2_I(x)}
                      case 4:
                       var arg2=expr[3],arg1=expr[2],op$0=expr[1],x1=eval$0(arg1);
                       switch(op$0)
                        {case 0:return _gq_(x1,eval$0(arg2));
                         case 1:return _gr_(x1,eval$0(arg2));
                         case 2:return _gs_(x1,eval$0(arg2));
                         case 3:return _gt_(x1,eval$0(arg2));
                         case 4:
                          return eq(arg1,arg2)?_gC_(x1,2):_gu_(x1,eval$0(arg2));
                         case 5:return _gy_(x1,eval$0(arg2));
                         case 6:
                          return _gM_(x1,caml_call1(eval_float_const_expr,arg2));
                         case 7:return sub2_I([0,x1,eval$0(arg2)]);
                         default:return abs_err_I([0,x1,eval$0(arg2)])}
                      default:
                       var args=expr[2],op$1=expr[1],match=map$0(eval$0,args);
                       if(0 === op$1 && match)
                        {var _Lx_=match[2];
                         if(_Lx_)
                          {var _Ly_=_Lx_[2];
                           if(_Ly_ && ! _Ly_[2])
                            {var c$0=_Ly_[1],b=_Lx_[1],a=match[1];
                             return _gs_(_gu_(a,b),c$0)}}}
                       return failwith(symbol(_nZ_,gen_op_name(op$1)))}}
                  return eval$0},
               eval_interval_const_expr=
                eval_interval_expr
                 (function(v){return failwith(symbol(_n0_,v))}),
               eval_const_expr=
                function(e)
                 {var _Lv_=caml_call2(Info[3],0,e);
                  caml_call1(report(-364068301,_n1_),_Lv_);
                  var
                   n=caml_call1(eval_num_const_expr,e),
                   _Lw_=string_of_num(n);
                  caml_call1(report(-364068301,_n2_),_Lw_);
                  return [0,n]},
               all_variables=
                function(t)
                 {var _Lu_=t[3];return map$0(function(v){return v[1]},_Lu_)},
               all_active_variables=
                function(t)
                 {var
                   vars=vars_in_expr(t[2]),
                   param$0=all_variables(t),
                   accu=0,
                   param=param$0;
                  for(;;)
                   {if(param)
                     {var l=param[2],x=param[1];
                      if(mem(x,vars))
                       {var accu$0=[0,x,accu],accu=accu$0,param=l;continue}
                      var param=l;
                      continue}
                    return rev(accu)}},
               find_variable=
                function(t,name)
                 {var param=t[3];
                  for(;;)
                   {if(param)
                     {var l=param[2],x=param[1];
                      if(caml_string_equal(x[1],name))return x;
                      var param=l;
                      continue}
                    throw Not_found}},
               variable_type=function(t,name){return find_variable(t,name)[2]},
               variable_interval=
                function(t,name)
                 {var
                   var$0=find_variable(t,name),
                   _Lt_=to_interval(var$0[4])[2];
                  return [254,to_interval(var$0[3])[1],_Lt_]},
               variable_num_interval=
                function(t,name)
                 {var
                   var$0=find_variable(t,name),
                   low=low_bound_to_num(var$0[3]),
                   high=high_bound_to_num(var$0[4]);
                  return [0,low,high]},
               constraints_of_task=
                function(t)
                 {var
                   _Lm_=t[4],
                   _Ln_=map$0(function(_Ls_){return _Ls_[2]},_Lm_);
                  function _Lo_(name){return find_variable(t,name)[5]}
                  function _Lp_(_Lr_){return variable_num_interval(t,_Lr_)}
                  return [0,
                          function(_Lq_){return variable_interval(t,_Lq_)},
                          _Lp_,
                          _Lo_,
                          _Ln_]},
               _n3_=create$0(0,10),
               _n4_=create$0(0,10),
               env$0=[0,create$0(0,10),_n4_,_n3_,0,0],
               reset$0=
                function(param)
                 {report(-364068301,_n5_);
                  clear(env$0[1]);
                  clear(env$0[2]);
                  clear(env$0[3]);
                  env$0[4] = 0;
                  env$0[5] = 0;
                  return 0},
               find_constant=function(name){return find(env$0[1],name)},
               find_variable$0=function(name){return find(env$0[2],name)},
               find_definition=function(name){return find(env$0[3],name)},
               apply_raw_rounding=
                function(rnd,expr)
                 {switch(expr[0])
                   {case 0:return [2,rnd,expr];
                    case 1:return [2,rnd,expr];
                    case 2:return expr;
                    case 3:
                     var arg=expr[2],op=expr[1],e1=apply_raw_rounding(rnd,arg);
                     return [2,rnd,[3,op,e1]];
                    case 4:
                     var _Lk_=expr[1];
                     if(caml_string_notequal(_Lk_,_n6_))
                      {var
                        arg2=expr[3],
                        arg1=expr[2],
                        e1$0=apply_raw_rounding(rnd,arg1),
                        e2=apply_raw_rounding(rnd,arg2);
                       return [2,rnd,[4,_Lk_,e1$0,e2]]}
                     var
                      arg2$0=expr[3],
                      arg1$0=expr[2],
                      e1$1=apply_raw_rounding(rnd,arg1$0);
                     return [2,rnd,[4,_n7_,e1$1,arg2$0]];
                    default:
                     var
                      args=expr[2],
                      op$0=expr[1],
                      es=
                       map$0
                        (function(_Ll_){return apply_raw_rounding(rnd,_Ll_)},args);
                     return [2,rnd,[5,op$0,es]]}},
               transform_raw_expr=
                function(param)
                 {switch(param[0])
                   {case 0:
                     var name=param[1];
                     try
                      {var def=find_definition(name),_Lg_=def[2];return _Lg_}
                     catch(_Lh_)
                      {_Lh_ = caml_wrap_exception(_Lh_);
                       if(_Lh_ === Not_found)
                        try
                         {var var$0=find_variable$0(name),_Lf_=[1,var$0[2]];
                          return _Lf_}
                        catch(_Li_)
                         {_Li_ = caml_wrap_exception(_Li_);
                          if(_Li_ === Not_found)
                           try
                            {var c=find_constant(name),_Le_=[0,c[2]];return _Le_}
                           catch(_Lj_)
                            {_Lj_ = caml_wrap_exception(_Lj_);
                             if(_Lj_ === Not_found)
                              return failwith(caml_call1(sprintf(_n8_),name));
                             throw _Lj_}
                          throw _Li_}
                       throw _Lh_}
                    case 1:var n=param[1];return mk_num_const(n);
                    case 2:
                     var arg=param[2],rnd=param[1],e1=transform_raw_expr(arg);
                     return [2,rnd,e1];
                    case 3:
                     var
                      arg$0=param[2],
                      str=param[1],
                      e1$0=transform_raw_expr(arg$0),
                      switch$0=caml_string_compare(str,_n9_);
                     if(0 <= switch$0)
                      {if(! (0 < switch$0))return [3,13,e1$0];
                       if(! caml_string_notequal(str,_n__))return [3,10,e1$0];
                       if(! caml_string_notequal(str,_n$_))return [3,18,e1$0];
                       if(! caml_string_notequal(str,_oa_))return [3,2,e1$0];
                       if(! caml_string_notequal(str,_ob_))return [3,11,e1$0];
                       if(! caml_string_notequal(str,_oc_))return [3,4,e1$0];
                       if(! caml_string_notequal(str,_od_))return [3,12,e1$0];
                       if(! caml_string_notequal(str,_oe_))return [3,3,e1$0];
                       if(! caml_string_notequal(str,_of_))return [3,6,e1$0];
                       if(! caml_string_notequal(str,_og_))return [3,14,e1$0]}
                     else
                      {if(! caml_string_notequal(str,_oi_))return [3,0,e1$0];
                       if(! caml_string_notequal(str,_oj_))return [3,1,e1$0];
                       if(! caml_string_notequal(str,_ok_))return [3,8,e1$0];
                       if(! caml_string_notequal(str,_ol_))return [3,16,e1$0];
                       if(! caml_string_notequal(str,_om_))return [3,7,e1$0];
                       if(! caml_string_notequal(str,_on_))return [3,15,e1$0];
                       if(! caml_string_notequal(str,_oo_))return [3,9,e1$0];
                       if(! caml_string_notequal(str,_op_))return [3,17,e1$0];
                       if(! caml_string_notequal(str,_oq_))return [3,5,e1$0]}
                     return failwith(symbol(_oh_,str));
                    case 4:
                     var
                      arg2=param[3],
                      arg1=param[2],
                      str$0=param[1],
                      e1$1=transform_raw_expr(arg1),
                      e2=transform_raw_expr(arg2);
                     if(caml_string_notequal(str$0,_or_))
                      {if(caml_string_notequal(str$0,_os_))
                        {if(caml_string_notequal(str$0,_ot_))
                          {if(caml_string_notequal(str$0,_ou_))
                            {if(caml_string_notequal(str$0,_ov_))
                              {if(caml_string_notequal(str$0,_ow_))
                                return caml_string_notequal(str$0,_ox_)
                                        ?caml_string_notequal(str$0,_oy_)
                                          ?caml_string_notequal(str$0,_oz_)
                                            ?failwith(symbol(_oA_,str$0))
                                            :[4,7,e1$1,e2]
                                          :[4,1,e1$1,e2]
                                        :[4,0,e1$1,e2];
                               var
                                lo_bound=to_interval(eval_const_expr(e1$1)),
                                hi_bound=to_interval(eval_const_expr(e2));
                               return mk_interval_const([254,lo_bound[1],hi_bound[2]])}
                             return [4,6,e1$1,e2]}
                           return [4,5,e1$1,e2]}
                         return [4,3,e1$1,e2]}
                       return [4,2,e1$1,e2]}
                     return [4,4,e1$1,e2];
                    default:
                     var
                      args=param[2],
                      str$1=param[1],
                      es=map$0(transform_raw_expr,args);
                     return caml_string_notequal(str$1,_oB_)
                             ?failwith(symbol(_oC_,str$1))
                             :[5,0,es]}},
               add_constant=
                function(name,raw)
                 {if(mem$0(env$0[1],name))
                   return failwith(symbol(_oE_,symbol(name,_oD_)));
                  var
                   expr=transform_raw_expr(raw),
                   c=[0,name,eval_const_expr(expr)];
                  return add(env$0[1],name,c)},
               is_same_bounds=
                function(lo,hi)
                 {try
                   {var a=to_num(lo),b=to_num(hi),_Lc_=eq_num(a,b);return _Lc_}
                  catch(_Ld_){return 0}},
               add_variable_with_uncertainty=
                function(var_type,name,param)
                 {var uncertainty=param[3],hi=param[2],lo=param[1];
                  if(mem$0(env$0[2],name))
                   return failwith(symbol(_oG_,symbol(name,_oF_)));
                  var
                   lo_expr=transform_raw_expr(lo),
                   hi_expr=transform_raw_expr(hi),
                   u_expr=transform_raw_expr(uncertainty),
                   lo_bound=eval_const_expr(lo_expr),
                   hi_bound=eval_const_expr(hi_expr);
                  if
                   (caml_equal(var_type,real_type)
                    &&
                    is_same_bounds(lo_bound,hi_bound))
                   {caml_call1(report(815031438,_oH_),name);
                    return add_constant(name,lo)}
                  var
                   _La_=eval_const_expr(u_expr),
                   _Lb_=eval_const_expr(hi_expr),
                   v=[0,var_type,name,eval_const_expr(lo_expr),_Lb_,_La_];
                  return add(env$0[2],name,v)},
               add_definition=
                function(name,raw)
                 {if(mem$0(env$0[3],name))
                   return failwith(symbol(_oK_,symbol(name,_oJ_)));
                  var expr=transform_raw_expr(raw),d=[0,name,expr];
                  add(env$0[3],name,d);
                  return expr},
               add_constraint=
                function(name,raw)
                 {switch(raw[0])
                   {case 0:
                     var
                      r2=raw[2],
                      r1=raw[1],
                      _K9_=transform_raw_expr(r2),
                      c=[0,transform_raw_expr(r1),_K9_];
                     break;
                    case 1:
                     var
                      r2$0=raw[2],
                      r1$0=raw[1],
                      _K__=transform_raw_expr(r2$0),
                      c=[1,transform_raw_expr(r1$0),_K__];
                     break;
                    default:
                     var
                      r2$1=raw[2],
                      r1$1=raw[1],
                      _K$_=transform_raw_expr(r2$1),
                      c=[2,transform_raw_expr(r1$1),_K$_]}
                  env$0[4] = append(env$0[4],[0,[0,name,c],0]);
                  return 0},
               add_expression_with_name=
                function(name,raw)
                 {var expr=add_definition(name,raw);
                  env$0[5] = append(env$0[5],[0,[0,name,expr],0]);
                  return 0},
               TODO=[248,_oM_,caml_fresh_oo_id(0)],
               yytransl_const=_oN_.slice(),
               yytransl_block=_oO_.slice(),
               yytablesize=812,
               _oP_=
                function(caml_parser_env)
                 {throw [0,YYexit,peek_val(caml_parser_env,0)]},
               _oQ_=
                function(caml_parser_env)
                 {throw [0,YYexit,peek_val(caml_parser_env,0)]},
               _oR_=
                function(caml_parser_env)
                 {var
                   _3=peek_val(caml_parser_env,3),
                   _5=peek_val(caml_parser_env,1);
                  return [4,_oS_,_3,_5]},
               _oT_=
                function(caml_parser_env)
                 {var _3=peek_val(caml_parser_env,1);return [3,_oU_,_3]},
               _oV_=
                function(caml_parser_env)
                 {var
                   _3=peek_val(caml_parser_env,3),
                   _5=peek_val(caml_parser_env,1);
                  return [4,_oW_,_3,_5]},
               _oX_=
                function(caml_parser_env)
                 {peek_val(caml_parser_env,3);
                  peek_val(caml_parser_env,1);
                  throw TODO},
               _oY_=
                function(caml_parser_env)
                 {var _3=peek_val(caml_parser_env,1);return [3,_oZ_,_3]},
               _o0_=
                function(caml_parser_env)
                 {var _3=peek_val(caml_parser_env,1);return [3,_o1_,_3]},
               _o2_=
                function(caml_parser_env)
                 {var _3=peek_val(caml_parser_env,1);return [3,_o3_,_3]},
               _o4_=
                function(caml_parser_env)
                 {var _3=peek_val(caml_parser_env,1);return [3,_o5_,_3]},
               _o6_=
                function(caml_parser_env)
                 {var _3=peek_val(caml_parser_env,1);return [3,_o7_,_3]},
               _o8_=
                function(caml_parser_env)
                 {var _3=peek_val(caml_parser_env,1);return [3,_o9_,_3]},
               _o__=
                function(caml_parser_env)
                 {var _3=peek_val(caml_parser_env,1);return [3,_o$_,_3]},
               _pa_=
                function(caml_parser_env)
                 {var _3=peek_val(caml_parser_env,1);return [3,_pb_,_3]},
               _pc_=
                function(caml_parser_env)
                 {var _3=peek_val(caml_parser_env,1);return [3,_pd_,_3]},
               _pe_=
                function(caml_parser_env)
                 {var
                   _3=peek_val(caml_parser_env,3),
                   _5=peek_val(caml_parser_env,1);
                  return [4,_pf_,_3,_5]},
               _pg_=
                function(caml_parser_env)
                 {var
                   _3=peek_val(caml_parser_env,3),
                   _5=peek_val(caml_parser_env,1);
                  return [4,_ph_,_3,_5]},
               _pi_=
                function(caml_parser_env)
                 {var _3=peek_val(caml_parser_env,1);return [3,_pj_,_3]},
               _pk_=
                function(caml_parser_env)
                 {var _3=peek_val(caml_parser_env,1);return [3,_pl_,_3]},
               _pm_=
                function(caml_parser_env)
                 {var _3=peek_val(caml_parser_env,1);return [3,_pn_,_3]},
               _po_=
                function(caml_parser_env)
                 {var _3=peek_val(caml_parser_env,1);return [3,_pp_,_3]},
               _pq_=
                function(caml_parser_env)
                 {var _3=peek_val(caml_parser_env,1);return [3,_pr_,_3]},
               _ps_=
                function(caml_parser_env)
                 {var _3=peek_val(caml_parser_env,1);return [3,_pt_,_3]},
               _pu_=
                function(caml_parser_env)
                 {var
                   _3=peek_val(caml_parser_env,5),
                   _5=peek_val(caml_parser_env,3),
                   _7=peek_val(caml_parser_env,1);
                  return [5,_pv_,[0,_3,[0,_5,[0,_7,0]]]]},
               _pw_=
                function(caml_parser_env)
                 {var _3=peek_val(caml_parser_env,1);return [3,_px_,_3]},
               _py_=
                function(caml_parser_env)
                 {var _3=peek_val(caml_parser_env,1);return [3,_pz_,_3]},
               _pA_=
                function(caml_parser_env)
                 {var _2=peek_val(caml_parser_env,1);return _2},
               _pB_=
                function(caml_parser_env)
                 {var
                   _1=peek_val(caml_parser_env,5),
                   _5=peek_val(caml_parser_env,1);
                  return [4,_pC_,_1,[1,minus_num(num_of_string(_5))]]},
               _pD_=
                function(caml_parser_env)
                 {var
                   _1=peek_val(caml_parser_env,2),
                   _3=peek_val(caml_parser_env,0);
                  return [4,_pE_,_1,[1,num_of_string(_3)]]},
               _pF_=
                function(caml_parser_env)
                 {var _3=peek_val(caml_parser_env,0);return [3,_pG_,_3]},
               _pH_=
                function(caml_parser_env)
                 {var _2=peek_val(caml_parser_env,0);return _2},
               _pI_=
                function(caml_parser_env)
                 {var _2=peek_val(caml_parser_env,0);return [3,_pJ_,_2]},
               _pK_=
                function(caml_parser_env)
                 {var
                   _1=peek_val(caml_parser_env,2),
                   _3=peek_val(caml_parser_env,0);
                  return [4,_pL_,_1,_3]},
               _pM_=
                function(caml_parser_env)
                 {var
                   _1=peek_val(caml_parser_env,2),
                   _3=peek_val(caml_parser_env,0);
                  return [4,_pN_,_1,_3]},
               _pO_=
                function(caml_parser_env)
                 {var
                   _1=peek_val(caml_parser_env,2),
                   _3=peek_val(caml_parser_env,0);
                  return [4,_pP_,_1,_3]},
               _pQ_=
                function(caml_parser_env)
                 {var
                   _1=peek_val(caml_parser_env,2),
                   _3=peek_val(caml_parser_env,0);
                  return [4,_pR_,_1,_3]},
               _pS_=
                function(caml_parser_env)
                 {var
                   _1=peek_val(caml_parser_env,3),
                   _3=peek_val(caml_parser_env,1);
                  return [2,_1,_3]},
               _pT_=
                function(caml_parser_env)
                 {var
                   _1=peek_val(caml_parser_env,0),
                   _K8_=[1,num_of_float_string(_1)];
                  return [2,string_to_rounding(_pU_),_K8_]},
               _pV_=
                function(caml_parser_env)
                 {var
                   _1=peek_val(caml_parser_env,0),
                   _K7_=[1,num_of_float_string(_1)];
                  return [2,string_to_rounding(_pW_),_K7_]},
               _pX_=
                function(caml_parser_env)
                 {var _1=peek_val(caml_parser_env,0);
                  return [1,num_of_float_string(_1)]},
               _pY_=
                function(caml_parser_env)
                 {var _1=peek_val(caml_parser_env,0);return [0,_1]},
               _pZ_=
                function(caml_parser_env)
                 {return string_to_rounding(get_string_option(_p0_))},
               _p1_=
                function(caml_parser_env)
                 {var _1=peek_val(caml_parser_env,0);
                  return create_rounding(_1[1],_1[2],1.)},
               _p2_=
                function(caml_parser_env)
                 {var
                   _3=peek_val(caml_parser_env,3),
                   _5=peek_val(caml_parser_env,1);
                  return create_rounding(caml_int_of_string(_3),_5,1.)},
               _p3_=
                function(caml_parser_env)
                 {var
                   _3=peek_val(caml_parser_env,5),
                   _5=peek_val(caml_parser_env,3),
                   _7=peek_val(caml_parser_env,1),
                   _K6_=caml_float_of_string(_7);
                  return create_rounding(caml_int_of_string(_3),_5,_K6_)},
               _p4_=
                function(caml_parser_env){return create_rounding(0,_p5_,1.)},
               _p6_=
                function(caml_parser_env)
                 {var
                   _3=peek_val(caml_parser_env,9),
                   rnd=peek_val(caml_parser_env,7),
                   _7=peek_val(caml_parser_env,5),
                   _9=peek_val(caml_parser_env,3),
                   _11=peek_val(caml_parser_env,1),
                   delta=caml_int_of_string(_11),
                   eps=caml_int_of_string(_9),
                   c=caml_float_of_string(_7),
                   bits=caml_int_of_string(_3),
                   _K5_=string_to_rnd_type(rnd)[2];
                  return [0,
                          max_value_from_bits(bits),
                          eps,
                          delta,
                          c,
                          [0,bits],
                          _K5_,
                          0]},
               _p7_=
                function(caml_parser_env)
                 {var _2=peek_val(caml_parser_env,0);return symbol(_p8_,_2)},
               _p9_=
                function(caml_parser_env)
                 {var _1=peek_val(caml_parser_env,0);return _1},
               _p__=
                function(caml_parser_env)
                 {var
                   raw=peek_val(caml_parser_env,0),
                   name=
                    symbol
                     (_oL_,
                      caml_string_of_jsbytes("" + (length(env$0[5]) + 1 | 0)));
                  return add_expression_with_name(name,raw)},
               _p$_=
                function(caml_parser_env)
                 {var
                   _1=peek_val(caml_parser_env,3),
                   _2=peek_val(caml_parser_env,2),
                   _4=peek_val(caml_parser_env,0);
                  return add_expression_with_name
                          (_1,apply_raw_rounding(_2,_4))},
               _qa_=
                function(caml_parser_env)
                 {var
                   _1=peek_val(caml_parser_env,2),
                   _3=peek_val(caml_parser_env,0);
                  return add_expression_with_name(_1,_3)},
               _qb_=
                function(caml_parser_env)
                 {peek_val(caml_parser_env,2);
                  peek_val(caml_parser_env,1);
                  peek_val(caml_parser_env,0);
                  return 0},
               _qc_=function(caml_parser_env){return 0},
               _qd_=
                function(caml_parser_env)
                 {var _2=peek_val(caml_parser_env,1);return _2},
               _qe_=
                function(caml_parser_env)
                 {var
                   _1=peek_val(caml_parser_env,2),
                   _3=peek_val(caml_parser_env,0);
                  return [1,_3,_1]},
               _qf_=
                function(caml_parser_env)
                 {var
                   _1=peek_val(caml_parser_env,2),
                   _3=peek_val(caml_parser_env,0);
                  return [0,_3,_1]},
               _qg_=
                function(caml_parser_env)
                 {var
                   _1=peek_val(caml_parser_env,2),
                   _3=peek_val(caml_parser_env,0);
                  return [1,_1,_3]},
               _qh_=
                function(caml_parser_env)
                 {var
                   _1=peek_val(caml_parser_env,2),
                   _3=peek_val(caml_parser_env,0);
                  return [0,_1,_3]},
               _qi_=
                function(caml_parser_env)
                 {var
                   _1=peek_val(caml_parser_env,2),
                   _3=peek_val(caml_parser_env,0);
                  return [2,_1,_3]},
               _qj_=
                function(caml_parser_env)
                 {var
                   _1=peek_val(caml_parser_env,3),
                   rnd=peek_val(caml_parser_env,2),
                   f=peek_val(caml_parser_env,0);
                  switch(f[0])
                   {case 0:
                     var
                      e2=f[2],
                      e1=f[1],
                      _K1_=apply_raw_rounding(rnd,e2),
                      _K4_=[0,apply_raw_rounding(rnd,e1),_K1_];
                     break;
                    case 1:
                     var
                      e2$0=f[2],
                      e1$0=f[1],
                      _K2_=apply_raw_rounding(rnd,e2$0),
                      _K4_=[1,apply_raw_rounding(rnd,e1$0),_K2_];
                     break;
                    default:
                     var
                      e2$1=f[2],
                      e1$1=f[1],
                      _K3_=apply_raw_rounding(rnd,e2$1),
                      _K4_=[2,apply_raw_rounding(rnd,e1$1),_K3_]}
                  return add_constraint(_1,_K4_)},
               _qk_=
                function(caml_parser_env)
                 {var
                   _1=peek_val(caml_parser_env,2),
                   _3=peek_val(caml_parser_env,0);
                  return add_constraint(_1,_3)},
               _ql_=
                function(caml_parser_env)
                 {peek_val(caml_parser_env,2);
                  peek_val(caml_parser_env,1);
                  peek_val(caml_parser_env,0);
                  return 0},
               _qm_=function(caml_parser_env){return 0},
               _qn_=
                function(caml_parser_env)
                 {var
                   _1=peek_val(caml_parser_env,3),
                   _2=peek_val(caml_parser_env,2),
                   _4=peek_val(caml_parser_env,0);
                  return add_definition(_1,apply_raw_rounding(_2,_4))},
               _qo_=
                function(caml_parser_env)
                 {var
                   _1=peek_val(caml_parser_env,2),
                   _3=peek_val(caml_parser_env,0);
                  return add_definition(_1,_3)},
               _qp_=
                function(caml_parser_env)
                 {peek_val(caml_parser_env,2);
                  peek_val(caml_parser_env,1);
                  peek_val(caml_parser_env,0);
                  return 0},
               _qq_=function(caml_parser_env){return 0},
               _qr_=
                function(caml_parser_env)
                 {var _1=peek_val(caml_parser_env,0);return [0,_1]},
               _qs_=function(caml_parser_env){return real_type},
               _qt_=function(caml_parser_env){return real_type},
               _qu_=
                function(caml_parser_env)
                 {var str=get_string_option(_qv_);
                  return caml_string_notequal(str,_iS_)
                          ?caml_string_notequal(str,_iT_)
                            ?caml_string_notequal(str,_iU_)
                              ?caml_string_notequal(str,_iV_)
                                ?caml_string_notequal(str,_iW_)
                                  ?failwith(symbol(_iX_,str))
                                  :real_type
                                :[0,64]
                              :[0,32]
                            :[0,16]
                          :[0,128]},
               _qw_=
                function(caml_parser_env)
                 {var
                   var_type=peek_val(caml_parser_env,7),
                   name=peek_val(caml_parser_env,6),
                   lo=peek_val(caml_parser_env,3),
                   hi=peek_val(caml_parser_env,1);
                  return add_variable_with_uncertainty
                          (var_type,name,[0,lo,hi,_oI_])},
               _qx_=
                function(caml_parser_env)
                 {var
                   _1=peek_val(caml_parser_env,9),
                   _2=peek_val(caml_parser_env,8),
                   _5=peek_val(caml_parser_env,5),
                   _7=peek_val(caml_parser_env,3),
                   _10=peek_val(caml_parser_env,0);
                  return add_variable_with_uncertainty(_1,_2,[0,_5,_7,_10])},
               _qy_=
                function(caml_parser_env)
                 {peek_val(caml_parser_env,2);
                  peek_val(caml_parser_env,1);
                  peek_val(caml_parser_env,0);
                  return 0},
               _qz_=function(caml_parser_env){return 0},
               _qA_=
                function(caml_parser_env)
                 {var
                   _1=peek_val(caml_parser_env,2),
                   _3=peek_val(caml_parser_env,0);
                  return add_constant(_1,_3)},
               _qB_=
                function(caml_parser_env)
                 {peek_val(caml_parser_env,2);
                  peek_val(caml_parser_env,1);
                  peek_val(caml_parser_env,0);
                  return 0},
               _qC_=function(caml_parser_env){return 0},
               _qD_=function(caml_parser_env){return 0},
               _qE_=function(caml_parser_env){return 0},
               _qF_=
                function(caml_parser_env)
                 {peek_val(caml_parser_env,0);return 0},
               _qG_=
                function(caml_parser_env)
                 {peek_val(caml_parser_env,0);return 0},
               _qH_=
                function(caml_parser_env)
                 {peek_val(caml_parser_env,0);return 0},
               _qI_=
                function(caml_parser_env)
                 {peek_val(caml_parser_env,0);return 0},
               _qJ_=
                function(caml_parser_env)
                 {peek_val(caml_parser_env,0);return 0},
               _qK_=
                function(caml_parser_env)
                 {peek_val(caml_parser_env,1);
                  peek_val(caml_parser_env,0);
                  return 0},
               _qL_=function(caml_parser_env){return 0},
               _qM_=
                function(caml_parser_env)
                 {peek_val(caml_parser_env,0);
                  var
                   _KZ_=0,
                   _K0_=env$0[2],
                   vars=
                    fold
                     (function(param,v,vs)
                       {return [0,[0,v[2],v[1],v[3],v[4],v[5]],vs]},
                      _K0_,
                      _KZ_),
                   acc=0,
                   param=env$0[5];
                  for(;;)
                   {if(param)
                     {var
                       param$0=param[2],
                       match=param[1],
                       e=match[2],
                       name=match[1],
                       t=[0,name,e,vars,env$0[4]],
                       acc$0=[0,t,acc],
                       acc=acc$0,
                       param=param$0;
                      continue}
                    var tasks=rev(acc);
                    reset$0(0);
                    return tasks}},
               _qN_=
                function(caml_parser_env)
                 {var
                   _2=peek_val(caml_parser_env,2),
                   _4=peek_val(caml_parser_env,0);
                  return append(_2,_4)},
               _qO_=function(caml_parser_env){return 0},
               _qP_=
                function(caml_parser_env)
                 {var
                   _2=peek_val(caml_parser_env,2),
                   _4=peek_val(caml_parser_env,0);
                  return append(_2,_4)},
               _qQ_=
                function(caml_parser_env)
                 {var _1=peek_val(caml_parser_env,0);return _1},
               yyact=
                [0,
                 function(param){return failwith(_qR_)},
                 _qQ_,
                 _qP_,
                 _qO_,
                 _qN_,
                 _qM_,
                 _qL_,
                 _qK_,
                 _qJ_,
                 _qI_,
                 _qH_,
                 _qG_,
                 _qF_,
                 _qE_,
                 _qD_,
                 _qC_,
                 _qB_,
                 _qA_,
                 _qz_,
                 _qy_,
                 _qx_,
                 _qw_,
                 _qu_,
                 _qt_,
                 _qs_,
                 _qr_,
                 _qq_,
                 _qp_,
                 _qo_,
                 _qn_,
                 _qm_,
                 _ql_,
                 _qk_,
                 _qj_,
                 _qi_,
                 _qh_,
                 _qg_,
                 _qf_,
                 _qe_,
                 _qd_,
                 _qc_,
                 _qb_,
                 _qa_,
                 _p$_,
                 _p__,
                 _p9_,
                 _p7_,
                 _p6_,
                 _p4_,
                 _p3_,
                 _p2_,
                 _p1_,
                 _pZ_,
                 _pY_,
                 _pX_,
                 _pV_,
                 _pT_,
                 _pS_,
                 _pQ_,
                 _pO_,
                 _pM_,
                 _pK_,
                 _pI_,
                 _pH_,
                 _pF_,
                 _pD_,
                 _pB_,
                 _pA_,
                 _py_,
                 _pw_,
                 _pu_,
                 _ps_,
                 _pq_,
                 _po_,
                 _pm_,
                 _pk_,
                 _pi_,
                 _pg_,
                 _pe_,
                 _pc_,
                 _pa_,
                 _o__,
                 _o8_,
                 _o6_,
                 _o4_,
                 _o2_,
                 _o0_,
                 _oY_,
                 _oX_,
                 _oV_,
                 _oT_,
                 _oR_,
                 _oQ_,
                 _oP_],
               yytables=
                [0,
                 yyact,
                 yytransl_const,
                 yytransl_block,
                 yylhs,
                 yylen,
                 yydefred,
                 yydgoto,
                 yysindex,
                 yyrindex,
                 yygindex,
                 yytablesize,
                 yytable,
                 yycheck,
                 parse_error,
                 yynames_const,
                 yynames_block],
               tasks=
                function(lexfun,lexbuf)
                 {return yyparse(yytables,1,lexfun,lexbuf)},
               expr=
                function(lexfun,lexbuf)
                 {return yyparse(yytables,2,lexfun,lexbuf)},
               SyntaxError=[248,_qS_,caml_fresh_oo_id(0)],
               table=create$0(0,100);
              iter$0
               (function(param)
                 {var v=param[2],k=param[1];return add(table,k,v)},
                _qT_);
              var
               resolve_id=
                function(str)
                 {try
                   {var _KX_=find(table,str);return _KX_}
                  catch(_KY_)
                   {_KY_ = caml_wrap_exception(_KY_);
                    if(_KY_ === Not_found)return [0,str];
                    throw _KY_}},
               token=
                function(lexbuf)
                 {a:
                  for(;;)
                   {var ocaml_lex_state$0=0;
                    for(;;)
                     {var
                       ocaml_lex_state=
                        caml_lex_engine(tbl,ocaml_lex_state$0,lexbuf);
                      if(0 <= ocaml_lex_state)
                       {lexbuf[11] = lexbuf[12];
                        var _KW_=lexbuf[12];
                        lexbuf[12]
                        =
                        [0,_KW_[1],_KW_[2],_KW_[3],lexbuf[4] + lexbuf[6] | 0]}
                      if(28 < ocaml_lex_state >>> 0)
                       {caml_call1(lexbuf[1],lexbuf);
                        var ocaml_lex_state$0=ocaml_lex_state;
                        continue}
                      switch(ocaml_lex_state)
                       {case 0:continue a;
                        case 1:
                         var lcp=lexbuf[12];
                         lexbuf[12] = [0,lcp[1],lcp[2] + 1 | 0,lcp[4],lcp[4]];
                         continue a;
                        case 2:
                         var str=sub_lexeme(lexbuf,lexbuf[5],lexbuf[6]);
                         return [2,sub$0(str,0,caml_ml_string_length(str) - 1 | 0)];
                        case 3:
                         var str$0=sub_lexeme(lexbuf,lexbuf[5],lexbuf[6]);
                         return [3,
                                 sub$0(str$0,0,caml_ml_string_length(str$0) - 1 | 0)];
                        case 4:
                         var str$1=sub_lexeme(lexbuf,lexbuf[5],lexbuf[6]);
                         return [1,str$1];
                        case 5:return 4;
                        case 6:return 5;
                        case 7:return 6;
                        case 8:return 7;
                        case 9:return 8;
                        case 10:return 9;
                        case 11:return 2;
                        case 12:return 1;
                        case 13:return 3;
                        case 14:return 10;
                        case 15:return 11;
                        case 16:return 12;
                        case 17:return 13;
                        case 18:return 14;
                        case 19:return 15;
                        case 20:return 16;
                        case 21:return 17;
                        case 22:return 18;
                        case 23:return 19;
                        case 24:return 21;
                        case 25:return 31;
                        case 26:
                         var str$2=sub_lexeme(lexbuf,lexbuf[5],lexbuf[6]);
                         return resolve_id(str$2);
                        case 27:throw [0,SyntaxError,symbol(_qU_,lexeme(lexbuf))];
                        default:return 0}}}},
               print_position=
                function(param,lexbuf)
                 {var
                   pos=lexbuf[12],
                   lex=lexeme(lexbuf),
                   cend=(pos[4] - pos[3] | 0) + 1 | 0,
                   cstart=cend - caml_ml_string_length(lex) | 0,
                   _KU_=pos[2],
                   _KV_=caml_string_equal(pos[1],_qV_)?_qW_:symbol(pos[1],_qY_);
                  return caml_call5(sprintf(_qX_),_KV_,_KU_,cstart,cend,lex)},
               parse_with_errors=
                function(lexbuf,parse)
                 {try
                   {var _KT_=caml_call2(parse,token,lexbuf);return _KT_}
                  catch(exn)
                   {exn = caml_wrap_exception(exn);
                    if(exn[1] === SyntaxError)
                     {var msg=exn[2];
                      caml_call3(error$0(_qZ_),print_position,lexbuf,msg);
                      throw Parse_error}
                    if(exn === Parse_error)
                     {caml_call2(error$0(_q0_),print_position,lexbuf);
                      throw Parse_error}
                    throw exn}},
               create_env_from_task=
                function(task)
                 {reset$0(0);
                  env$0[5] = [0,[0,task[1],task[2]],0];
                  env$0[4] = task[4];
                  var _KS_=task[3];
                  return iter$0
                          (function(v)
                            {var var$0=[0,v[2],v[1],v[3],v[4],v[5]];
                             return add(env$0[2],v[1],var$0)},
                           _KS_)},
               parse_expr=
                function(str)
                 {var raw=parse_with_errors(from_string(str),expr);
                  return transform_raw_expr(raw)},
               proof=[0,0,0,0],
               save_proof=
                function(dir,fname)
                 {var
                   tmp=get_dir(dir),
                   name=cc(tmp,fname),
                   oc=open_out_gen(_o_,438,name);
                  caml_output_value(oc,proof,0);
                  return close_out(oc)},
               add_proof_step=
                function(i,op,args)
                 {var step=[0,i,op,args];
                  proof[2] = append(proof[2],[0,step,0]);
                  return 0},
               add_proof_opt=
                function(opt){proof[3] = append(proof[3],[0,opt,0]);return 0},
               new_proof=
                function(task)
                 {var
                   _KP_=task[3],
                   vars=
                    map$0
                     (function(v)
                       {var
                         _KQ_=high_bound_to_num(v[4]),
                         _KR_=low_bound_to_num(v[3]);
                        return [0,v[1],_KR_,_KQ_]},
                      _KP_);
                  proof[1] = vars;
                  proof[2] = 0;
                  proof[3] = 0;
                  return 0},
               add_const_step=
                function(i,c)
                 {var op=[1,c],args=[0,0,0,0];
                  return add_proof_step(i,op,args)},
               add_opt_approx=
                function(indices,bounds,total)
                 {return add_proof_opt([0,0,bounds,indices,total])},
               add_opt_exact=
                function(bound,e_exp,total)
                 {return add_proof_opt([0,1,[0,bound,[0,e_exp,0]],0,total])},
               maxima=
                function(cmd)
                 {function try_name(counter)
                   {var counter$0=counter;
                    for(;;)
                     {var name=temp_file_name(temp_dir_name$1,prefix,suffix);
                      try
                       {caml_sys_close(caml_sys_open(name,_c9_,384));return name}
                      catch(e)
                       {e = caml_wrap_exception(e);
                        if(e[1] === Sys_error)
                         {if(1000 <= counter$0)throw e;
                          var counter$1=counter$0 + 1 | 0,counter$0=counter$1;
                          continue}
                        throw e}}}
                  var
                   tmp=try_name(0),
                   s=symbol(_q4_,symbol(cmd,symbol(_q3_,tmp)));
                  if(0 === caml_sys_system_command(s))
                   {var fd=open_in(tmp),data=input_line(fd);
                    caml_ml_close_channel(fd);
                    caml_sys_remove(tmp);
                    return data}
                  return failwith(symbol(_q5_,cmd))},
               simplify=
                function(task,e)
                 {try
                   {var
                     str=symbol(_ra_,symbol(caml_call2(Info[3],0,e),_q$_)),
                     out=maxima(str);
                    try
                     {create_env_from_task(task);
                      var _KN_=parse_expr(out),_KO_=_KN_}
                    catch(exn)
                     {exn = caml_wrap_exception(exn);
                      if(exn[1] === Failure)
                       {var msg=exn[2];
                        caml_call1(error$0(_q6_),out);
                        var _KO_=failwith(msg)}
                      else
                       {caml_call1(error$0(_q7_),out);var _KO_=failwith(_q8_)}}
                    return _KO_}
                  catch(exn)
                   {exn = caml_wrap_exception(exn);
                    if(exn[1] === Failure)
                     {var msg$0=exn[2];caml_call1(error$0(_q9_),msg$0);return e}
                    error$0(_q__);
                    return e}},
               get_tol=
                function(name,default$0)
                 {var tol=get_float_option(name);
                  return tol < 0.
                          ?(caml_call3(warning(_rb_),name,tol,default$0),default$0)
                          :tol},
               default_opt_pars=
                function(param)
                 {var
                   _KI_=get_int_option(_rc_),
                   _KJ_=get_int_option(_rd_),
                   _KK_=get_tol(_re_,0.01),
                   _KL_=get_tol(_rf_,0.),
                   _KM_=get_tol(_rg_,0.01);
                  return [0,get_tol(_rh_,0.01),_KM_,_KL_,_KK_,_KJ_,_KI_]},
               get_float=
                function(default$0,strs,name)
                 {var n=caml_ml_string_length(name),r=regexp(name);
                  function find(param)
                   {var param$0=param;
                    for(;;)
                     {if(param$0)
                       {var t=param$0[2],str=param$0[1];
                        try
                         {var _KF_=search_forward(r,str,0),i=_KF_}
                        catch(_KH_)
                         {_KH_ = caml_wrap_exception(_KH_);
                          if(_KH_ !== Not_found)throw _KH_;
                          var i=-1,_KG_=_KH_}
                        if(0 === i)return caml_float_of_string(string_after(str,n));
                        var param$0=t;
                        continue}
                      if(is_none(default$0))throw Not_found;
                      return option_value(default$0)}}
                  return find(strs)},
               Out=Make$0(OCamlIntervalPrinter),
               counter=[0,0],
               min_max_expr=
                function(pars,max_only,cs,e)
                 {if(debug(0))
                   {var _Ki_=pars[5],_Kj_=pars[2],_Kk_=pars[1],_Kl_=pars[4];
                    caml_call4(report(-364068301,_rM_),_Kl_,_Kk_,_Kj_,_Ki_)}
                  var base=base_dir(0),tmp=get_tmp_dir(0);
                  counter[1]++;
                  var
                   _Km_=counter[1],
                   name=caml_call1(sprintf$0(_rN_),_Km_),
                   in_name=cc(tmp,name),
                   out_name=cc(tmp,_rO_);
                  function gen(fmt)
                   {function nl(_KE_){return pp_print_newline(fmt,_KE_)}
                    function p(str){pp_print_string(fmt,str);return nl(0)}
                    return function(param)
                     {var
                       e=param[2],
                       cs=param[1],
                       vs$1=vars_in_expr(e),
                       var_bounds=map$0(cs[1],vs$1);
                      p(_ri_);
                      p(_rj_);
                      p(_rk_);
                      var
                       n=length(var_bounds),
                       strs$1=
                        map$0
                         (function(b)
                           {var _KC_=b[2],_KD_=b[1];
                            return caml_call2(sprintf$0(_rC_),_KD_,_KC_)},
                          var_bounds);
                      nl(0);
                      p(caml_call1(sprintf$0(_rD_),n));
                      var i=0,strs=strs$1;
                      for(;;)
                       {if(strs)
                         {var strs$0=strs[2],str=strs[1];
                          p(caml_call2(sprintf$0(_rA_),i,str));
                          var i$0=i + 1 | 0,i=i$0,strs=strs$0;
                          continue}
                        p(_rB_);
                        p(_rE_);
                        nl(0);
                        p(_rG_);
                        var i$1=0,vs=vs$1;
                        for(;;)
                         {if(vs)
                           {var vs$0=vs[2],v=vs[1],_Kz_=fix_name(v);
                            p(caml_call2(sprintf$0(_rF_),_Kz_,i$1));
                            var i$2=i$1 + 1 | 0,i$1=i$2,vs=vs$0;
                            continue}
                          var es=expr_ref_list_of_expr(e),n$0=length(es);
                          iteri
                           (function(i,expr)
                             {if(i < (n$0 - 1 | 0))
                               {var _KA_=caml_call1(Out[1],[0,max_int]);
                                return caml_call4(fprintf$0(fmt),_rH_,i,_KA_,expr)}
                              var _KB_=caml_call1(Out[1],[0,max_int]);
                              return caml_call3(fprintf$0(fmt),_rI_,_KB_,expr)},
                            es);
                          nl(0);
                          var alg=get_string_option(_rJ_);
                          if(caml_string_notequal(alg,_rK_))
                           return failwith(caml_call1(sprintf$0(_rL_),alg));
                          p(_rl_);
                          p(_rm_);
                          var _Kr_=pars[4],_Ks_=pars[3];
                          p(caml_call2(sprintf$0(_rn_),_Ks_,_Kr_));
                          var _Kt_=pars[5],_Ku_=pars[2],_Kv_=pars[1];
                          p(caml_call3(sprintf$0(_ro_),_Kv_,_Ku_,_Kt_));
                          p(_rp_);
                          p(_rq_);
                          p(_rr_);
                          if(max_only)
                           {p(_rs_);p(_rt_);p(_ru_)}
                          else
                           {var _Kw_=pars[5],_Kx_=pars[2],_Ky_=pars[1];
                            p(caml_call3(sprintf$0(_rw_),_Ky_,_Kx_,_Kw_));
                            p(_rx_);
                            p(_ry_);
                            p(_rz_)}
                          return p(_rv_)}}}}
                  write_to_file(in_name,gen,[0,cs,e]);
                  function quote(s){return symbol(_rQ_,symbol(s,_rP_))}
                  var
                   str=get_string_option(_rR_),
                   _Kn_=quote(base),
                   str$0=global_replace(regexp(_rS_),_Kn_,str),
                   _Ko_=quote(out_name),
                   str$1=global_replace(regexp(_rT_),_Ko_,str$0),
                   _Kp_=quote(in_name),
                   cmd=global_replace(regexp(_rU_),_Kp_,str$1);
                  run_cmd(cmd);
                  var
                   out=run_cmd(out_name),
                   fmin=get_float(0,out,_rV_),
                   fmax=get_float(0,out,_rW_),
                   iter_max=get_float(_rY_,out,_rX_) | 0,
                   iter_min=get_float(_r0_,out,_rZ_) | 0,
                   lower_max=get_float([0,upper_bound],out,_r1_),
                   lower_min=get_float([0,f_max],out,_r2_),
                   rmin=[0,fmin,lower_min,iter_min,0.],
                   rmax=[0,fmax,lower_max,iter_max,0.];
                  if(debug(0))
                   {if(Math.abs(fmax) < Math.abs(fmin))
                     var opt=Math.abs(fmin),subopt=Math.abs(fmin - lower_min);
                    else
                     var opt=Math.abs(fmax),subopt=Math.abs(fmax - lower_max);
                    var _Kq_=max(iter_max,iter_min);
                    caml_call3(report(-364068301,_r3_),iter_min,iter_max,_Kq_);
                    caml_call2(report(-364068301,_r4_),fmin,lower_min);
                    caml_call2(report(-364068301,_r5_),fmax,lower_max);
                    caml_call2
                     (report(-364068301,_r6_),subopt,subopt / opt * 100.)}
                  return [0,rmin,rmax]},
               Out$0=Make$0(GelpiaPrinter),
               gen=
                function(fmt)
                 {function p(str)
                   {pp_print_string(fmt,str);return pp_print_newline(fmt,0)}
                  return function(param)
                   {var
                     expr=param[3],
                     cs=param[2],
                     pars=param[1],
                     var_names=vars_in_expr(expr),
                     bounds=map$0(cs[1],var_names),
                     _Ke_=0.,
                     domain_size=
                      itlist
                       (function(b,r){return max(r,Math.abs(b[2] - b[1]))},
                        bounds,
                        _Ke_),
                     x_tol=domain_size * pars[3] + pars[4],
                     timeout=max(pars[6] / 1000 | 0,1);
                    p(caml_call1(sprintf$0(_r7_),x_tol));
                    var _Kb_=pars[2];
                    p(caml_call1(sprintf$0(_r8_),_Kb_));
                    var _Kc_=pars[1];
                    p(caml_call1(sprintf$0(_r9_),_Kc_));
                    p(caml_call1(sprintf$0(_r__),timeout));
                    var _Kd_=pars[5];
                    p(caml_call1(sprintf$0(_r$_),_Kd_));
                    var
                     names=
                      map$0(function(name){return symbol(_sc_,name)},var_names),
                     vars=
                      map2
                       (function(name,b)
                         {var _Kf_=b[2],_Kg_=b[1],_Kh_=fix_name(name);
                          return caml_call3(sprintf$0(_sa_),_Kh_,_Kg_,_Kf_)},
                        names,
                        bounds);
                    p(concat(_sb_,vars));
                    return caml_call3(Out$0[1],0,fmt,expr)}},
               name_counter=[0,0],
               Out$1=Make$0(Z3PythonPrinter),
               name_counter$0=[0,0],
               Out$2=Make$0(CPrinter),
               min_max_expr$0=
                function(pars,cs,expr)
                 {var
                   tmp=get_tmp_dir(0),
                   c_name=cc(tmp,_tV_),
                   exe_name=cc(tmp,_tW_),
                   _J5_=0;
                  function gen(fmt)
                   {function p(str)
                     {pp_print_string(fmt,str);return pp_print_newline(fmt,0)}
                    function str_of_array(vs)
                     {var ss=map$0(string_of_float,vs);
                      return symbol(_tp_,symbol(concat(_to_,ss),_tn_))}
                    return function(param)
                     {var
                       expr=param[2],
                       cs=param[1],
                       var_names=vars_in_expr(expr),
                       var_bounds=map$0(cs[1],var_names);
                      p(_tb_);
                      p(_tc_);
                      p(_td_);
                      p(_te_);
                      p(_tg_);
                      var vs=var_names,n=0;
                      for(;;)
                       {if(vs)
                         {var vs$0=vs[2],h=vs[1],_J7_=fix_name(h);
                          p(caml_call2(sprintf$0(_tf_),_J7_,n));
                          var n$0=n + 1 | 0,vs=vs$0,n=n$0;
                          continue}
                        p(_th_);
                        caml_call3(Out$2[1],0,fmt,expr);
                        p(_ti_);
                        p(_tj_);
                        p(_tk_);
                        p(_tl_);
                        p(_tm_);
                        p(_tB_);
                        var _Ka_=length(var_names);
                        p(caml_call2(sprintf$0(_tC_),_J5_,_Ka_));
                        var
                         match=
                          unzip(map$0(function(b){return [0,b[1],b[2]]},var_bounds)),
                         us=match[2],
                         ls=match[1],
                         ms=map2(function(l,u){return (l + u) / 2.},ls,us);
                        p(_tq_);
                        var _J8_=str_of_array(ls);
                        p(caml_call1(sprintf$0(_tr_),_J8_));
                        var _J9_=str_of_array(us);
                        p(caml_call1(sprintf$0(_ts_),_J9_));
                        p(_tt_);
                        var _J__=pars[2];
                        p(caml_call1(sprintf$0(_tu_),_J__));
                        var _J$_=pars[5];
                        p(caml_call1(sprintf$0(_tv_),_J$_));
                        p(_tw_);
                        p(symbol(_ty_,symbol(str_of_array(ms),_tx_)));
                        p(symbol(_tA_,symbol(str_of_array(ms),_tz_)));
                        p(_tD_);
                        p(_tE_);
                        p(_tF_);
                        p(_tG_);
                        p(_tH_);
                        p(_tI_);
                        p(_tJ_);
                        p(_tK_);
                        p(_tL_);
                        p(_tM_);
                        p(_tN_);
                        p(_tO_);
                        p(_tP_);
                        p(_tQ_);
                        p(_tR_);
                        p(_tS_);
                        p(_tT_);
                        return p(_tU_)}}}
                  write_to_file(c_name,gen,[0,cs,expr]);
                  var
                   cc$0=get_string_option(_tX_),
                   cc_lib=get_string_option(_tY_),
                   cmd=caml_call4(sprintf$0(_tZ_),cc$0,exe_name,c_name,cc_lib),
                   out=run_cmd(cmd);
                  if(0 === out)
                   {var out$0=run_cmd(exe_name),_J6_=concat(_t0_,out$0);
                    caml_call1(report(-364068301,_t1_),_J6_);
                    var min=get_float(0,out$0,_t2_),max=get_float(0,out$0,_t3_);
                    return [0,min,max]}
                  var str=symbol(_t5_,concat(_t4_,[0,cmd,out]));
                  return failwith(str)},
               mk_const_interval=function(v){return [254,v,v]},
               opt=
                function(f$0,a$1,x_tol,f_rel_tol,f_abs_tol,max_iters)
                 {var
                   acc$1=0,
                   _JO_=0,
                   doms$0=
                    [0,
                     [0,a$1,map$2(function(i){return (i[1] + i[2]) * 0.5},a$1)],
                     _JO_],
                   counter=[0,0];
                  counter[1] = 0;
                  var
                   upper_bound$0=upper_bound,
                   lower_bound=upper_bound,
                   doms=doms$0,
                   acc=acc$1;
                  a:
                  for(;;)
                   {if(doms)
                     {var rest=doms[2],dom=doms[1],v=caml_call1(f$0,dom[1]);
                      if(v[2] <= lower_bound){var doms=rest;continue}
                      var
                       _JL_=dom[1],
                       d_min=
                        map$2
                         (function(d){var _J4_=d[1];return [254,_J4_,_J4_]},_JL_),
                       _JM_=dom[1],
                       d_max=
                        map$2
                         (function(d){var _J3_=d[2];return [254,_J3_,_J3_]},_JM_),
                       d_mid=map$2(mk_const_interval,dom[2]),
                       v2_min=caml_call1(f$0,d_min),
                       v2_max=caml_call1(f$0,d_max),
                       v2_mid=caml_call1(f$0,d_mid),
                       _JN_=v2_mid[1],
                       v2=max(max(v2_min[1],v2_max[1]),_JN_),
                       lower_bound$0=max(v2,lower_bound);
                      if
                       (!
                        (Math.abs(v[2] - v2)
                         <=
                         f_rel_tol
                         *
                         Math.abs(v2)
                         +
                         f_abs_tol)
                        &&
                        !
                        (_g2_(dom[1]) <= x_tol))
                       {var switch$0=0;
                        if(! (0 <= max_iters) || ! (max_iters <= counter[1]))
                         switch$0 = 1;
                        if(switch$0)
                         {counter[1] = counter[1] + 1 | 0;
                          var
                           _JJ_=dom[1],
                           f=function(i,b){return [0,i,b[2] - b[1]]},
                           l=_JJ_.length - 1;
                          if(0 === l)
                           var w=[0];
                          else
                           {var r=caml_make_vect(l,f(0,_JJ_[1])),_JC_=l - 1 | 0,_JB_=1;
                            if(! (_JC_ < 1))
                             {var i=_JB_;
                              for(;;)
                               {r[1 + i] = f(i,_JJ_[1 + i]);
                                var _JD_=i + 1 | 0;
                                if(_JC_ !== i){var i=_JD_;continue}
                                break}}
                            var w=r}
                          var
                           _JK_=[0,0,upper_bound],
                           match=
                            fold_left$0
                             (function(param,_J2_)
                               {var v2=_J2_[2],j=_J2_[1],v1=param[2],i=param[1];
                                return v2 < v1?[0,i,v1]:[0,j,v2]},
                              _JK_,
                              w),
                           i$7=match[1],
                           bi=caml_check_bound(dom[1],i$7)[1 + i$7],
                           m=caml_array_get(dom[2],i$7),
                           m1=(bi[1] + m) * 0.5,
                           m2=(m + bi[2]) * 0.5,
                           c=copy$0(dom[2]);
                          caml_array_set(c,i$7,m1);
                          var c$0=copy$0(dom[1]);
                          c$0[1 + i$7]
                          =
                          [254,caml_check_bound(c$0,i$7)[1 + i$7][1],m];
                          var d1=[0,c$0,c],c$1=copy$0(dom[2]);
                          caml_array_set(c$1,i$7,m2);
                          var c$2=copy$0(dom[1]);
                          c$2[1 + i$7]
                          =
                          [254,m,caml_check_bound(c$2,i$7)[1 + i$7][2]];
                          var
                           d2=[0,c$2,c$1],
                           acc$0=[0,[0,v2,d1],[0,[0,v2,d2],acc]],
                           upper_bound$2=max(upper_bound$0,lower_bound$0),
                           upper_bound$0=upper_bound$2,
                           lower_bound=lower_bound$0,
                           doms=rest,
                           acc=acc$0;
                          continue}}
                      var
                       upper_bound$1=max(upper_bound$0,v[2]),
                       upper_bound$0=upper_bound$1,
                       lower_bound=lower_bound$0,
                       doms=rest;
                      continue}
                    if(0 === acc)
                     {var counter$0=counter[1];
                      return [0,upper_bound$0,lower_bound,counter$0]}
                    var
                     a=of_list(acc),
                     cmp=
                      function(param,_J1_)
                       {var v2=_J1_[1],v1=param[1];
                        return caml_float_compare(v2,v1)},
                     maxson$0=
                      function(a,cmp)
                       {function maxson(l,i)
                         {var i31=((i + i | 0) + i | 0) + 1 | 0,x=[0,i31];
                          if((i31 + 2 | 0) < l)
                           {var
                             _JU_=i31 + 1 | 0,
                             _JV_=caml_check_bound(a,_JU_)[1 + _JU_];
                            if(cmp(caml_check_bound(a,i31)[1 + i31],_JV_) < 0)
                             x[1] = i31 + 1 | 0;
                            var
                             _JW_=i31 + 2 | 0,
                             _JX_=caml_check_bound(a,_JW_)[1 + _JW_],
                             _JY_=x[1];
                            if(cmp(caml_check_bound(a,_JY_)[1 + _JY_],_JX_) < 0)
                             x[1] = i31 + 2 | 0;
                            return x[1]}
                          if((i31 + 1 | 0) < l)
                           {var
                             _JZ_=i31 + 1 | 0,
                             _J0_=caml_check_bound(a,_JZ_)[1 + _JZ_];
                            if(! (0 <= cmp(caml_check_bound(a,i31)[1 + i31],_J0_)))
                             return i31 + 1 | 0}
                          if(i31 < l)return i31;
                          throw [0,Bottom,i]}
                        return maxson},
                     maxson=maxson$0(a,cmp),
                     trickledown$0=
                      function(maxson,a,cmp)
                       {function trickledown(l,i,e)
                         {var i$0=i;
                          for(;;)
                           {var j=maxson(l,i$0);
                            if(0 < cmp(caml_check_bound(a,j)[1 + j],e))
                             {var _JT_=caml_check_bound(a,j)[1 + j];
                              caml_check_bound(a,i$0)[1 + i$0] = _JT_;
                              var i$0=j;
                              continue}
                            caml_check_bound(a,i$0)[1 + i$0] = e;
                            return 0}}
                        return trickledown},
                     trickledown=trickledown$0(maxson,a,cmp),
                     trickle$0=
                      function(trickledown,a)
                       {function trickle(l,i,e)
                         {try
                           {var _JS_=trickledown(l,i,e);return _JS_}
                          catch(exn)
                           {exn = caml_wrap_exception(exn);
                            if(exn[1] === Bottom)
                             {var i$0=exn[2];
                              caml_check_bound(a,i$0)[1 + i$0] = e;
                              return 0}
                            throw exn}}
                        return trickle},
                     trickle=trickle$0(trickledown,a),
                     bubbledown$0=
                      function(maxson,a)
                       {function bubbledown(l,i)
                         {var i$0=i;
                          for(;;)
                           {var
                             i$1=maxson(l,i$0),
                             _JR_=caml_check_bound(a,i$1)[1 + i$1];
                            caml_check_bound(a,i$0)[1 + i$0] = _JR_;
                            var i$0=i$1;
                            continue}}
                        return bubbledown},
                     bubbledown=bubbledown$0(maxson,a),
                     bubble$0=
                      function(bubbledown)
                       {function bubble(l,i)
                         {try
                           {var _JQ_=bubbledown(l,i);return _JQ_}
                          catch(exn)
                           {exn = caml_wrap_exception(exn);
                            if(exn[1] === Bottom){var i$0=exn[2];return i$0}
                            throw exn}}
                        return bubble},
                     bubble=bubble$0(bubbledown),
                     l$0=a.length - 1,
                     _JF_=((l$0 + 1 | 0) / 3 | 0) - 1 | 0;
                    if(! (_JF_ < 0))
                     {var i$6=_JF_;
                      for(;;)
                       {trickle(l$0,i$6,caml_check_bound(a,i$6)[1 + i$6]);
                        var _JI_=i$6 - 1 | 0;
                        if(0 !== i$6){var i$6=_JI_;continue}
                        break}}
                    var _JG_=l$0 - 1 | 0;
                    if(! (_JG_ < 2))
                     {var i$4=_JG_;
                      b:
                      for(;;)
                       {var e$0=caml_check_bound(a,i$4)[1 + i$4];
                        a[1 + i$4] = caml_check_bound(a,0)[1];
                        var i$5=bubble(i$4,0),i$3=i$5;
                        for(;;)
                         {var father=(i$3 - 1 | 0) / 3 | 0;
                          if(i$3 === father)throw [0,Assert_failure,_L_];
                          if(0 <= cmp(caml_check_bound(a,father)[1 + father],e$0))
                           caml_check_bound(a,i$3)[1 + i$3] = e$0;
                          else
                           {var _JE_=caml_check_bound(a,father)[1 + father];
                            caml_check_bound(a,i$3)[1 + i$3] = _JE_;
                            if(0 < father){var i$3=father;continue}
                            caml_check_bound(a,0)[1] = e$0}
                          var _JH_=i$4 - 1 | 0;
                          if(2 !== i$4){var i$4=_JH_;continue b}
                          break}
                        break}}
                    if(1 < l$0)
                     {var e=caml_check_bound(a,1)[2];
                      a[2] = caml_check_bound(a,0)[1];
                      a[1] = e}
                    var
                     a$0=map$2(function(_JP_){return _JP_[2]},a),
                     i$2=a$0.length - 1 - 1 | 0,
                     i$0=i$2,
                     res=0;
                    for(;;)
                     {if(0 <= i$0)
                       {var
                         res$0=[0,a$0[1 + i$0],res],
                         i$1=i$0 - 1 | 0,
                         i$0=i$1,
                         res=res$0;
                        continue}
                      var doms=res,acc=0;
                      continue a}}},
               eval_expr=
                function(refs,arr,param)
                 {switch(param[0])
                   {case 0:
                     var i=param[1];return caml_check_bound(refs,i)[1 + i];
                    case 1:var c=param[1];return c;
                    case 2:var v=param[1];return caml_check_bound(arr,v)[1 + v];
                    case 3:
                     var n=param[2],arg=param[1];
                     return _gC_(eval_expr(refs,arr,arg),n);
                    case 4:
                     var arg$0=param[2],op=param[1],x=eval_expr(refs,arr,arg$0);
                     switch(op)
                      {case 0:return _go_(x);
                       case 1:return _gp_(x);
                       case 2:return _gA_(x);
                       case 3:return _gB_(x);
                       case 4:return _gF_(x);
                       case 5:return _gH_(x);
                       case 6:return _gO_(x);
                       case 7:return _gQ_(x);
                       case 8:return _gS_(x);
                       case 9:return _gU_(x);
                       case 10:return _gD_(x);
                       case 11:return _gE_(x);
                       case 12:return _gW_(x);
                       case 13:return _gY_(x);
                       case 14:return _g0_(x);
                       case 15:return asinh_I(x);
                       case 16:return acosh_I(x);
                       case 17:return atanh_I(x);
                       default:return floor_power2_I(x)}
                    case 5:
                     var
                      arg2=param[3],
                      arg1=param[2],
                      op$0=param[1],
                      x1=eval_expr(refs,arr,arg1),
                      x2=eval_expr(refs,arr,arg2);
                     switch(op$0)
                      {case 0:return _gq_(x1,x2);
                       case 1:return _gr_(x1,x2);
                       case 2:return _gs_(x1,x2);
                       case 3:return _gt_(x1,x2);
                       case 4:return _gu_(x1,x2);
                       case 5:return _gy_(x1,x2);
                       case 6:return _gM_(x1,x2[2]);
                       case 7:return sub2_I([0,x1,x2]);
                       default:return abs_err_I([0,x1,x2])}
                    case 6:
                     var
                      args=param[2],
                      op$1=param[1],
                      match=
                       map$0(function(_JA_){return eval_expr(refs,arr,_JA_)},args);
                     if(0 === op$1 && match)
                      {var _Jy_=match[2];
                       if(_Jy_)
                        {var _Jz_=_Jy_[2];
                         if(_Jz_ && ! _Jz_[2])
                          {var c$0=_Jz_[1],b=_Jy_[1],a=match[1];
                           return _gs_(_gu_(a,b),c$0)}}}
                     return failwith(symbol(_t8_,gen_op_name(op$1)));
                    default:
                     var arg$1=param[3],e=param[2],p=param[1];
                     return goldberg_ulp_I([0,p,e],eval_expr(refs,arr,arg$1))}},
               eval_expr_list=
                function(refs,vars,i,param)
                 {var i$0=i,param$0=param;
                  for(;;)
                   {if(param$0)
                     {var _Jv_=param$0[2],_Jw_=param$0[1];
                      if(_Jv_)
                       {var _Jx_=eval_expr(refs,vars,_Jw_);
                        caml_check_bound(refs,i$0)[1 + i$0] = _Jx_;
                        var i$1=i$0 + 1 | 0,i$0=i$1,param$0=_Jv_;
                        continue}
                      return eval_expr(refs,vars,_Jw_)}
                    return failwith(_t9_)}},
               min_max_expr$1=
                function(pars,max_only,cs,e)
                 {if(debug(0))
                   {var _Je_=pars[5],_Jf_=pars[2],_Jg_=pars[1],_Jh_=pars[4];
                    caml_call4(report(-364068301,_t__),_Jh_,_Jg_,_Jf_,_Je_)}
                  var
                   var_names=vars_in_expr(e),
                   start_interval=of_list(map$0(cs[1],var_names)),
                   _Ji_=pars[4],
                   _Jj_=pars[3],
                   x_tol=_g2_(start_interval) * _Jj_ + _Ji_,
                   h_vars=create$0(0,8);
                  iteri(function(i,v){return add(h_vars,v,i)},var_names);
                  var _Jk_=expr_ref_list_of_expr(e);
                  function of_expr(ex)
                   {switch(ex[0])
                     {case 0:var c=ex[1];return [1,to_interval(c)];
                      case 1:
                       var v=ex[1];
                       return is_ref_var(ex)
                               ?[0,index_of_ref_var(ex)]
                               :[2,find(h_vars,v)];
                      case 2:return failwith(_t6_);
                      case 3:var arg=ex[2],op=ex[1];return [4,op,of_expr(arg)];
                      case 4:
                       var _Jl_=ex[1],switcher=_Jl_ - 4 | 0;
                       if(! (2 < switcher >>> 0))
                        switch(switcher)
                         {case 0:
                           var arg2$0=ex[3],arg1$0=ex[2];
                           if(eq(arg1$0,arg2$0))return [3,of_expr(arg1$0),2];
                           break;
                          case 1:break;
                          default:
                           var
                            arg2$1=ex[3],
                            arg1$1=ex[2],
                            e=caml_call1(eval_interval_const_expr,arg2$1),
                            n=e[1] | 0;
                           if(0 <= n && e[1] == e[2] && n == e[1])
                            return [3,of_expr(arg1$1),n];
                           return failwith(_t7_)}
                       var arg2=ex[3],arg1=ex[2],_Jm_=of_expr(arg2);
                       return [5,_Jl_,of_expr(arg1),_Jm_];
                      default:
                       var _Jn_=ex[1];
                       if(0 !== _Jn_)
                        {var _Jo_=ex[2];
                         if(_Jo_)
                          {var _Jp_=_Jo_[1];
                           if(0 === _Jp_[0])
                            {var _Jq_=_Jo_[2];
                             if(_Jq_)
                              {var _Jr_=_Jq_[1];
                               if(0 === _Jr_[0])
                                {var _Js_=_Jq_[2];
                                 if(_Js_ && ! _Js_[2])
                                  {var
                                    arg$0=_Js_[1],
                                    e$0=_Jr_[1],
                                    p=_Jp_[1],
                                    _Jt_=of_expr(arg$0),
                                    _Ju_=to_int(e$0);
                                   return [7,to_int(p),_Ju_,_Jt_]}}}}}}
                       var args=ex[2];
                       return [6,_Jn_,map$0(of_expr,args)]}}
                  var
                   es=map$0(of_expr,_Jk_),
                   refs=caml_make_vect(length(es) - 1 | 0,_gl_);
                  function f(arr){return eval_expr_list(refs,arr,0,es)}
                  var
                   match=opt(f,start_interval,x_tol,pars[1],pars[2],pars[5]),
                   iter_max=match[3],
                   lower_max=match[2],
                   fmax=match[1];
                  if(max_only)
                   var fmin=0.,lower_min=0.,iter_min=0;
                  else
                   var
                    f_min=
                     function(arr){return _go_(eval_expr_list(refs,arr,0,es))},
                    match$0=
                     opt(f_min,start_interval,x_tol,pars[1],pars[2],pars[5]),
                    i=match$0[3],
                    lm=match$0[2],
                    fm=match$0[1],
                    lower_min$0=- lm,
                    fmin$0=- fm,
                    fmin=fmin$0,
                    lower_min=lower_min$0,
                    iter_min=i;
                  var
                   rmin=[0,fmin,lower_min,iter_min,0.],
                   rmax=[0,fmax,lower_max,iter_max,0.];
                  return [0,rmin,rmax]},
               optimize_expr=
                function(pars,max_only,cs,expr)
                 {var s$0=get_string_option(_t$_);
                  if(caml_string_notequal(s$0,_ua_))
                   if(caml_string_notequal(s$0,_ub_))
                    if(caml_string_notequal(s$0,_uc_))
                     if(caml_string_notequal(s$0,_ud_))
                      if(caml_string_notequal(s$0,_ue_))
                       var match=failwith(symbol(_uf_,s$0));
                      else
                       {try
                         {var
                           _IW_=caml_call1(eval_interval_expr(cs[1]),expr),
                           bounds=_IW_}
                        catch(_Jb_){var bounds=[254,upper_bound,f_max]}
                        var _IV_=_gJ_(_ug_,bounds);
                        caml_call1(report(-364068301,_uh_),_IV_);
                        if(0 === vars_in_expr(expr))
                         var
                          n=caml_call1(eval_num_const_expr,expr),
                          t=interval_of_num(n),
                          match$0=[0,t[1],t[2]];
                        else
                         {var tmp$0=get_tmp_dir(0);
                          name_counter$0[1]++;
                          var
                           _IS_=name_counter$0[1],
                           py_name=cc(tmp$0,caml_call1(sprintf$0(_s1_),_IS_)),
                           gen$0=
                            function(fmt)
                             {var z3_seed=get_int_option(_sr_);
                              function p(str)
                               {pp_print_string(fmt,str);return pp_print_newline(fmt,0)}
                              function p$0(str)
                               {pp_print_string(fmt,str);return pp_print_flush(fmt,0)}
                              function num_to_z3(n)
                               {var ns=s(numerator(n)),ds=s(denominator(n));
                                return symbol(_sH_,symbol(ns,symbol(_sG_,symbol(ds,_sF_))))}
                              function constraint_vars(c)
                               {if(0 === c[0] && 0 === c[2][0])
                                 {var e=c[1];return vars_in_expr(e)}
                                return failwith(_sL_)}
                              return function(param$1)
                               {var
                                 e=param$1[2],
                                 cs=param$1[1],
                                 vars_cs=map$0(constraint_vars,cs[4]),
                                 l$0=[0,vars_in_expr(e),vars_cs],
                                 var_names=itlist(union$0,l$0,0),
                                 var_bounds=map$0(cs[2],var_names);
                                p(_ss_);
                                p(_st_);
                                p(_su_);
                                var
                                 var_names$0=
                                  map$0
                                   (function(name){return symbol(_s0_,fix_name(name))},
                                    var_names);
                                if(0 === var_names$0)
                                 p(_sQ_);
                                else
                                 {var
                                   param$0=zip(var_names$0,var_bounds),
                                   yes=0,
                                   no=0,
                                   param=param$0;
                                  for(;;)
                                   {if(param)
                                     {var
                                       l=param[2],
                                       x=param[1],
                                       match=x[2],
                                       high=match[2],
                                       low=match[1];
                                      if(eq_num(low,high))
                                       {var yes$0=[0,x,yes],yes=yes$0,param=l;continue}
                                      var no$0=[0,x,no],no=no$0,param=l;
                                      continue}
                                    var
                                     neq_vars=rev(no),
                                     eq_vars=rev(yes),
                                     eqs=
                                      map$0
                                       (function(param)
                                         {var
                                           match=param[2],
                                           low=match[1],
                                           name=param[1],
                                           _Ja_=num_to_z3(low);
                                          return caml_call2(sprintf$0(_sR_),name,_Ja_)},
                                        eq_vars),
                                     constraints=
                                      map$0
                                       (function(param)
                                         {var
                                           match=param[2],
                                           high=match[2],
                                           low=match[1],
                                           name=param[1];
                                          if(eq_num(low,high))
                                           {var _I8_=num_to_z3(high),_I9_=num_to_z3(low);
                                            return caml_call4(sprintf$0(_sS_),name,_I9_,name,_I8_)}
                                          var _I__=num_to_z3(high),_I$_=num_to_z3(low);
                                          return caml_call4(sprintf$0(_sT_),name,_I$_,name,_I__)},
                                        neq_vars),
                                     names=concat(_sU_,var_names$0);
                                    p(caml_call2(sprintf$0(_sV_),names,names));
                                    p(concat(_sW_,eqs));
                                    var _I4_=concat(_sX_,constraints);
                                    p(caml_call1(sprintf$0(_sY_),_I4_));
                                    break}}
                                var _I5_=cs[4];
                                if(0 === _I5_)
                                 p(_sM_);
                                else
                                 {p$0(_sN_);
                                  map$0
                                   (function(c$0)
                                     {var switch$0=0;
                                      if(0 === c$0[0])
                                       {var _I6_=c$0[2];
                                        if(0 === _I6_[0])
                                         {var c=_I6_[1],e=c$0[1];
                                          caml_call3(Out$1[1],0,fmt,e);
                                          p$0(_sJ_);
                                          var _I7_=is_rat(c)?num_to_z3(to_num(c)):failwith(_sI_);
                                          p$0(_I7_);
                                          switch$0 = 1}}
                                      if(! switch$0)failwith(_sK_);
                                      return p$0(_sO_)},
                                    _I5_);
                                  p(_sP_)}
                                p$0(_sZ_);
                                caml_call3(Out$1[1],0,fmt,e);
                                var max_str=max_only?_sv_:_sE_,switch$0=0;
                                if
                                 (get_bool_option(_sw_)
                                  &&
                                  caml_string_equal(check_interval(bounds),_sx_))
                                 {var
                                   _IZ_=bounds[2],
                                   _I0_=bounds[1],
                                   bounds_str=caml_call2(sprintf$0(_sy_),_I0_,_IZ_);
                                  switch$0 = 1}
                                if(! switch$0)var bounds_str=_sD_;
                                p(_sz_);
                                var _I1_=pars[6],_I2_=pars[1],_I3_=pars[2];
                                p
                                 (caml_call6
                                   (sprintf$0(_sA_),_I3_,_I2_,_I1_,z3_seed,max_str,bounds_str));
                                p(_sB_);
                                return p(_sC_)}};
                          write_to_file(py_name,gen$0,[0,cs,expr]);
                          try
                           {var _IU_=caml_sys_getenv(_ta_),path$0=_IU_}
                          catch(_IY_)
                           {_IY_ = caml_wrap_exception(_IY_);
                            if(_IY_ !== Not_found)throw _IY_;
                            var path$0=_s2_}
                          var
                           base=cc(base_dir(0),_s3_),
                           z3path=get_string_option(_s4_),
                           python_path=
                            concat_env_paths([0,path$0,[0,base,[0,z3path,0]]]);
                          try
                           {var _IT_=caml_sys_getenv(_s$_),path$1=_IT_}
                          catch(_IX_)
                           {_IX_ = caml_wrap_exception(_IX_);
                            if(_IX_ !== Not_found)throw _IX_;
                            var path$1=_s5_}
                          var
                           z3path$0=get_string_option(_s6_),
                           lib_path=concat_env_paths([0,path$1,[0,z3path$0,0]]),
                           z3python=get_string_option(_s7_),
                           cmd$1=
                            caml_call4
                             (sprintf$0(_s8_),lib_path,python_path,z3python,py_name),
                           out$0=run_cmd(cmd$1),
                           fmin=get_float(0,out$0,_s9_),
                           fmax=get_float(0,out$0,_s__),
                           match$0=[0,fmin,fmax]}
                        var
                         fmax$0=match$0[2],
                         fmin$0=match$0[1],
                         match=
                          [0,
                           [0,fmin$0,f_max,empty_result[3],empty_result[4]],
                           [0,fmax$0,upper_bound,empty_result[3],empty_result[4]]]}
                     else
                      var
                       match$1=min_max_expr$0(pars,cs,expr),
                       fmax$1=match$1[2],
                       fmin$1=match$1[1],
                       match=
                        [0,
                         [0,fmin$1,f_max,empty_result[3],empty_result[4]],
                         [0,fmax$1,upper_bound,empty_result[3],empty_result[4]]];
                    else
                     {var tmp=get_tmp_dir(0);
                      name_counter[1]++;
                      var
                       _IO_=name_counter[1],
                       gelpia_name=cc(tmp,caml_call1(sprintf$0(_sj_),_IO_));
                      write_to_file(gelpia_name,gen,[0,pars,cs,expr]);
                      var _IP_=max_only?_sk_:_sq_;
                      try
                       {var _IN_=caml_sys_getenv(_si_),path=_IN_}
                      catch(_Jd_)
                       {_Jd_ = caml_wrap_exception(_Jd_);
                        if(_Jd_ !== Not_found)throw _Jd_;
                        var path=cc(base_dir(0),_sd_)}
                      var
                       cmd=cc(cc(path,_sf_),_se_),
                       _IQ_=
                        caml_sys_file_exists(cmd)
                         ?cmd
                         :failwith(symbol(cmd,symbol(_sh_,_sg_))),
                       cmd$0=caml_call3(sprintf$0(_sl_),_IQ_,_IP_,gelpia_name),
                       out=run_cmd(cmd$0);
                      try
                       {var
                         min=max_only?0.:get_float(0,out,_sp_),
                         max=get_float(0,out,_so_),
                         _IR_=[0,min,max],
                         match$2=_IR_}
                      catch(_Jc_)
                       {var
                         msg=symbol(_sn_,concat(_sm_,[0,cmd$0,out])),
                         match$2=failwith(msg)}
                      var
                       fmax$2=match$2[2],
                       fmin$2=match$2[1],
                       match=
                        [0,
                         [0,fmin$2,f_max,empty_result[3],empty_result[4]],
                         [0,fmax$2,upper_bound,empty_result[3],empty_result[4]]]}
                   else
                    var match=min_max_expr$1(pars,max_only,cs,expr);
                  else
                   var match=min_max_expr(pars,max_only,cs,expr);
                  var rmax=match[2],rmin=match[1];
                  return [0,rmin,rmax]},
               find_min_max=
                function(pars,cs,expr)
                 {var
                   match=optimize_expr(pars,0,cs,expr),
                   rmax=match[2],
                   rmin=match[1];
                  return [0,rmin[1],rmax[1]]},
               find_max=
                function(pars,cs,expr)
                 {var match=optimize_expr(pars,1,cs,expr),rmax=match[2];
                  return rmax},
               Exceptional_operation=[248,_uj_,caml_fresh_oo_id(0)],
               is_power_of_2_or_0=
                function(e)
                 {if(0 === e[0])
                   {var c=e[1];
                    if(is_rat(c))
                     {var n=to_num(c),_IM_=eq_num(n,_uk_);
                      return _IM_?_IM_:is_power_of_two(n)}}
                  return 0},
               is_neg_power_of_2=
                function(e)
                 {if(0 === e[0])
                   {var c=e[1];
                    if(is_rat(c))
                     {var n=to_num(c);
                      return symbol$0(n,_ul_)?is_power_of_two(div_num(_um_,n)):0}}
                  return 0},
               get_type=
                function(var_type,e)
                 {var e$0=e;
                  for(;;)
                   switch(e$0[0])
                    {case 0:
                      var c=e$0[1];
                      if(is_rat(c))
                       {var
                         n=to_num(c),
                         rnd32=string_to_rounding(_un_),
                         rnd64=string_to_rounding(_uo_);
                        return is_exact_fp_const(rnd32,n)
                                ?rnd32[5]
                                :is_exact_fp_const(rnd64,n)?rnd64[5]:real_type}
                      return real_type;
                     case 1:var name=e$0[1];return caml_call1(var_type,name);
                     case 2:var rnd=e$0[1];return rnd[5];
                     case 3:
                      var arg=e$0[2],op=e$0[1],arg_type=get_type(var_type,arg);
                      return 2 <= op?real_type:arg_type;
                     case 4:
                      var _IL_=e$0[1];
                      if(4 === _IL_)
                       {var arg2=e$0[3],arg1=e$0[2];
                        if(is_power_of_2_or_0(arg1)){var e$0=arg2;continue}
                        if(is_power_of_2_or_0(arg2)){var e$0=arg1;continue}
                        return real_type}
                      if(2 <= _IL_)return real_type;
                      var
                       arg2$0=e$0[3],
                       arg1$0=e$0[2],
                       ty1=get_type(var_type,arg1$0),
                       ty2=get_type(var_type,arg2$0);
                      return is_subtype(ty1,ty2)
                              ?ty2
                              :is_subtype(ty2,ty1)?ty1:real_type;
                     default:return real_type}},
               simplify_rounding=
                function(var_type)
                 {function simplify(e)
                   {switch(e[0])
                     {case 0:return e;
                      case 1:return e;
                      case 2:
                       var
                        arg=e[2],
                        rnd=e[1],
                        arg$0=simplify(arg),
                        ty=get_type(var_type,arg$0);
                       if(is_no_rnd(rnd))return arg$0;
                       if(is_subtype(ty,rnd[5]))return arg$0;
                       switch(arg$0[0])
                        {case 0:
                          var c=arg$0[1];
                          if(is_rat(c))
                           return is_exact_fp_const(rnd,to_num(c))?arg$0:[2,rnd,arg$0];
                          break;
                         case 3:
                          if(3 === arg$0[1])
                           return [2,
                                   [0,rnd[1],rnd[2],0,rnd[4],rnd[5],rnd[6],rnd[7]],
                                   arg$0];
                          break;
                         case 4:
                          switch(arg$0[1])
                           {case 4:
                             var e2$0=arg$0[3],e1$0=arg$0[2],switch$0=0;
                             if(is_power_of_2_or_0(e1$0))
                              {var _IF_=rnd[5];
                               if(is_subtype(get_type(var_type,e2$0),_IF_))switch$0 = 1}
                             var switch$1=0;
                             if(switch$0)
                              switch$1 = 1;
                             else
                              {var switch$2=0;
                               if(is_power_of_2_or_0(e2$0))
                                {var _IG_=rnd[5];
                                 if(is_subtype(get_type(var_type,e1$0),_IG_))
                                  {switch$1 = 1;switch$2 = 1}}
                               if(! switch$2)
                                {var switch$3=0;
                                 if(is_neg_power_of_2(e1$0))
                                  {var _IH_=rnd[5];
                                   if(is_subtype(get_type(var_type,e2$0),_IH_))switch$3 = 1}
                                 var switch$4=0;
                                 if(! switch$3)
                                  {var switch$5=0;
                                   if(is_neg_power_of_2(e2$0))
                                    {var _II_=rnd[5];
                                     if(is_subtype(get_type(var_type,e1$0),_II_))switch$5 = 1}
                                   if(! switch$5)switch$4 = 1}
                                 if(! switch$4)
                                  return proof_flag(0)
                                          ?arg$0
                                          :[2,[0,rnd[1],0,rnd[3],rnd[4],rnd[5],rnd[6],rnd[7]],arg$0]}}
                             if(switch$1)return arg$0;
                             break;
                            case 5:
                             var e2$1=arg$0[3],e1$1=arg$0[2];
                             if(is_power_of_2_or_0(e2$1))
                              {var _IJ_=rnd[5];
                               if
                                (is_subtype(get_type(var_type,e1$1),_IJ_)
                                 &&
                                 !
                                 proof_flag(0))
                                return [2,
                                        [0,rnd[1],0,rnd[3],rnd[4],rnd[5],rnd[6],rnd[7]],
                                        arg$0]}
                             if(is_neg_power_of_2(e2$1))
                              {var _IK_=rnd[5];
                               if(is_subtype(get_type(var_type,e1$1),_IK_))return arg$0}
                             break;
                            case 2:
                            case 3:
                             var e2=arg$0[3],e1=arg$0[2],_ID_=rnd[5];
                             if(is_subtype(get_type(var_type,e1),_ID_))
                              {var _IE_=rnd[5];
                               if
                                (is_subtype(get_type(var_type,e2),_IE_) && ! proof_flag(0))
                                return [2,[0,rnd[1],rnd[2],0,rnd[4],rnd[5],rnd[6],1],arg$0]}
                             return [2,rnd,arg$0]
                            }
                          break
                         }
                       return [2,rnd,arg$0];
                      case 3:
                       var arg$1=e[2],op=e[1],e1$2=simplify(arg$1);
                       return [3,op,e1$2];
                      case 4:
                       var
                        arg2=e[3],
                        arg1=e[2],
                        op$0=e[1],
                        e1$3=simplify(arg1),
                        e2$2=simplify(arg2);
                       return [4,op$0,e1$3,e2$2];
                      default:
                       var args=e[2],op$1=e[1],es=map$0(simplify,args);
                       return [5,op$1,es]}}
                  return simplify},
               check_expr=
                function(vars)
                 {function eval$0(e$0)
                   {switch(e$0[0])
                     {case 0:var c=e$0[1],r=to_interval(c);break;
                      case 1:var v=e$0[1],r=caml_call1(vars,v);break;
                      case 2:
                       var e1=e$0[2],rnd=e$0[1],x=eval$0(e1);
                       if(is_no_rnd(rnd))
                        var r1=x;
                       else
                        var
                         e=get_eps(rnd[2]),
                         d=get_eps(rnd[3]),
                         extra=
                          function(v)
                           {var _IC_=symbol$1(symbol$3(e,Math.abs(v)),d);
                            return symbol$3(rnd[4],_IC_)},
                         over=
                          function(v)
                           {return rnd[1] < Math.abs(v)?v < 0.?upper_bound:f_max:v},
                         _Iu_=extra(x[2]),
                         _Iv_=over(symbol$1(x[2],_Iu_)),
                         _Iw_=extra(x[1]),
                         r1=[254,over(symbol$2(x[1],_Iw_)),_Iv_];
                       var r=r1;
                       break;
                      case 3:
                       var arg=e$0[2],op=e$0[1],x$0=eval$0(arg);
                       switch(op)
                        {case 0:var _Ix_=_go_(x$0);break;
                         case 1:var _Ix_=_gp_(x$0);break;
                         case 2:
                          if(0 === _gL_(x$0,0.))
                           throw [0,Exceptional_operation,e$0,_uq_];
                          var _Ix_=_gA_(x$0);
                          break;
                         case 3:
                          if(x$0[1] < 0.)throw [0,Exceptional_operation,e$0,_ur_];
                          var _Ix_=_gB_(x$0);
                          break;
                         case 4:var _Ix_=_gF_(x$0);break;
                         case 5:var _Ix_=_gH_(x$0);break;
                         case 6:var _Ix_=_gO_(x$0);break;
                         case 7:
                          var switch$0=0;
                          if(x$0[1] < -1. || 1. < x$0[2])
                           switch$0 = 1;
                          else
                           var _Ix_=_gQ_(x$0);
                          if(switch$0)throw [0,Exceptional_operation,e$0,_us_];
                          break;
                         case 8:
                          var switch$1=0;
                          if(x$0[1] < -1. || 1. < x$0[2])
                           switch$1 = 1;
                          else
                           var _Ix_=_gS_(x$0);
                          if(switch$1)throw [0,Exceptional_operation,e$0,_ut_];
                          break;
                         case 9:var _Ix_=_gU_(x$0);break;
                         case 10:var _Ix_=_gD_(x$0);break;
                         case 11:
                          if(x$0[1] <= 0.)throw [0,Exceptional_operation,e$0,_uu_];
                          var _Ix_=_gE_(x$0);
                          break;
                         case 12:var _Ix_=_gW_(x$0);break;
                         case 13:var _Ix_=_gY_(x$0);break;
                         case 14:var _Ix_=_g0_(x$0);break;
                         case 15:var _Ix_=asinh_I(x$0);break;
                         case 16:
                          if(x$0[1] < 1.)throw [0,Exceptional_operation,e$0,_uv_];
                          var _Ix_=acosh_I(x$0);
                          break;
                         case 17:
                          var switch$2=0;
                          if(x$0[1] <= -1. || 1. <= x$0[2])
                           switch$2 = 1;
                          else
                           var _Ix_=atanh_I(x$0);
                          if(switch$2)throw [0,Exceptional_operation,e$0,_uw_];
                          break;
                         default:var _Ix_=floor_power2_I(x$0)}
                       var r=_Ix_;
                       break;
                      case 4:
                       var arg2=e$0[3],arg1=e$0[2],op$0=e$0[1],x1=eval$0(arg1);
                       switch(op$0)
                        {case 0:var _Iy_=_gq_(x1,eval$0(arg2));break;
                         case 1:var _Iy_=_gr_(x1,eval$0(arg2));break;
                         case 2:var _Iy_=_gs_(x1,eval$0(arg2));break;
                         case 3:var _Iy_=_gt_(x1,eval$0(arg2));break;
                         case 4:
                          var _Iy_=eq(arg1,arg2)?_gC_(x1,2):_gu_(x1,eval$0(arg2));
                          break;
                         case 5:
                          var x2=eval$0(arg2);
                          if(0 === _gL_(x2,0.))
                           throw [0,Exceptional_operation,e$0,_ux_];
                          var _Iy_=_gy_(x1,x2);
                          break;
                         case 6:
                          var _Iy_=_gM_(x1,caml_call1(eval_float_const_expr,arg2));
                          break;
                         default:var _Iy_=failwith(symbol(_uy_,bin_op_name(op$0)))}
                       var r=_Iy_;
                       break;
                      default:
                       var
                        args=e$0[2],
                        op$1=e$0[1],
                        xs=map$0(eval$0,args),
                        switch$3=0;
                       if(0 === op$1 && xs)
                        {var _Iz_=xs[2];
                         if(_Iz_)
                          {var _IA_=_Iz_[2];
                           if(_IA_ && ! _IA_[2])
                            {var c$1=_IA_[1],b=_Iz_[1],a=xs[1],_IB_=_gs_(_gu_(a,b),c$1);
                             switch$3 = 1}}}
                       if(! switch$3)
                        var _IB_=failwith(symbol(_uz_,gen_op_name(op$1)));
                       var r=_IB_}
                    var c$0=check_interval(r);
                    if(caml_string_notequal(c$0,_up_))
                     throw [0,Exceptional_operation,e$0,c$0];
                    return r}
                  return eval$0},
               Out$3=Make$0(FPCorePrinter),
               sep=function(fmt,str,param){return pp_print_string(fmt,str)},
               var_bounds_to_pre=
                function(fmt,task)
                 {function print_bounds(v)
                   {var
                     match=variable_num_interval(task,v),
                     b=match[2],
                     a=match[1],
                     _Is_=string_of_num(b),
                     _It_=string_of_num(a);
                    return caml_call4(fprintf$0(fmt),_uN_,_It_,v,_Is_)}
                  var _Iq_=all_variables(task);
                  return caml_call1
                          (print_list
                            (print_bounds,function(_Ir_){return sep(fmt,_uO_,_Ir_)}),
                           _Iq_)},
               constraints_to_pre=
                function(fmt,task)
                 {var
                   _Im_=task[4],
                   formulas=map$0(function(_Ip_){return _Ip_[2]},_Im_);
                  function _In_(_Io_){return sep(fmt,_uP_,_Io_)}
                  return caml_call1
                          (print_list
                            (function(formula)
                              {var print_expr=caml_call1(Out$3[1],[0,max_int]);
                               switch(formula[0])
                                {case 0:
                                  var b=formula[2],a=formula[1];
                                  return caml_call5
                                          (fprintf$0(fmt),_uA_,print_expr,a,print_expr,b);
                                 case 1:
                                  var b$0=formula[2],a$0=formula[1];
                                  return caml_call5
                                          (fprintf$0(fmt),_uB_,print_expr,a$0,print_expr,b$0);
                                 default:
                                  var b$1=formula[2],a$1=formula[1];
                                  return caml_call5
                                          (fprintf$0(fmt),_uC_,print_expr,a$1,print_expr,b$1)}},
                             _In_),
                           formulas)},
               print_list$0=
                function(sep,fmt)
                 {function _Ik_(param){return pp_print_string(fmt,sep)}
                  return print_list
                          (function(_Il_){return pp_print_string(fmt,_Il_)},_Ik_)},
               mk_env=function(vars){return [0,vars,0,0,0,0,0,0]},
               clear_exprs=
                function(env){env[4] = 0;env[6] = 0;env[7] = 0;return 0},
               get_expr_name=
                function(env,opt,expr)
                 {if(opt)var sth=opt[1],suffix=sth;else var suffix=_u2_;
                  try
                   {var _Ig_=[0,assoc_eq(eq,expr,env[6]),1];return _Ig_}
                  catch(_Ih_)
                   {_Ih_ = caml_wrap_exception(_Ih_);
                    if(_Ih_ === Not_found)
                     {var switch$0=0;
                      switch(expr[0])
                       {case 0:
                         var c=expr[1];
                         if(is_rat(c))
                          {var n=to_num(c);
                           try
                            {var _Id_=assoc_eq(eq_num,n,env[3]),index=_Id_}
                           catch(_Ij_)
                            {_Ij_ = caml_wrap_exception(_Ij_);
                             if(_Ij_ !== Not_found)throw _Ij_;
                             env[2] = env[2] + 1 | 0;
                             env[3] = [0,[0,n,env[2]],env[3]];
                             var index=env[2]}
                           var _Ic_=[0,caml_call2(sprintf$0(_u0_),index,suffix),1]}
                         else
                          switch$0 = 1;
                         break;
                        case 1:var v=expr[1],_Ic_=[0,assoc(v,env[1]),1];break;
                        default:switch$0 = 1}
                      if(switch$0)
                       try
                        {var
                          flag$0=0,
                          _If_=assoc_eq(eq,expr,env[7]),
                          name=_If_,
                          flag=flag$0}
                       catch(_Ii_)
                        {_Ii_ = caml_wrap_exception(_Ii_);
                         if(_Ii_ !== Not_found)throw _Ii_;
                         env[4] = env[4] + 1 | 0;
                         env[5] = max(env[5],env[4]);
                         var
                          _Ie_=env[4],
                          tmp_name=caml_call2(sprintf$0(_u1_),_Ie_,suffix),
                          name=tmp_name,
                          flag=0}
                      else
                       var name=_Ic_[1],flag=_Ic_[2];
                      env[6] = [0,[0,expr,name],env[6]];
                      return [0,name,flag]}
                    throw _Ih_}},
               remove_rnd=
                function(expr)
                 {function remove(expr)
                   {var expr$0=expr;
                    for(;;)
                     switch(expr$0[0])
                      {case 0:return expr$0;
                       case 1:return expr$0;
                       case 2:var expr$1=expr$0[2],expr$0=expr$1;continue;
                       case 3:
                        var arg=expr$0[2],op=expr$0[1];return [3,op,remove(arg)];
                       case 4:
                        var
                         arg2=expr$0[3],
                         arg1=expr$0[2],
                         op$0=expr$0[1],
                         _Ib_=remove(arg2);
                        return [4,op$0,remove(arg1),_Ib_];
                       default:
                        var args=expr$0[2],op$1=expr$0[1];
                        return [5,op$1,map$0(remove,args)]}}
                  return remove(expr)},
               print_init_f_and_mps=
                function(env,fmt,opt,_HO_,_HN_,exprs)
                 {if(opt)var sth=opt[1],sth$0=sth;else var sth$0=0;
                  if(_HO_)var sth$1=_HO_[1],sth$2=sth$1;else var sth$2=0;
                  if(_HN_)var sth$3=_HN_[1],sth$4=sth$3;else var sth$4=0;
                  function f(i,e)
                   {var opt=[0,sth$4],sth=i + 1 | 0,_HW_=[0,sth];
                    return write_to_string
                            (function(fmt)
                              {return function(expr)
                                {var mpfi=opt?sth$4:0,index=_HW_?sth:1;
                                 clear_exprs(env);
                                 env[7] = [0,[0,expr,_wC_],0];
                                 var
                                  mp_prefix=mpfi?_wD_:_wP_,
                                  _HX_=env[1],
                                  args=
                                   map$0
                                    (function(param)
                                      {var name=param[2];
                                       return symbol(mp_prefix,symbol(_wE_,name))},
                                     _HX_);
                                 if(mpfi)
                                  var
                                   translate$0=
                                    function(fmt,expr)
                                     {var
                                       match=get_expr_name(env,_vj_,expr),
                                       found_flag=match[2],
                                       name=match[1];
                                      if(found_flag)return name;
                                      var switch$0=0;
                                      switch(expr[0])
                                       {case 0:
                                         var c=expr[1],x=to_interval(c),_H3_=x[2],_H4_=x[1];
                                         caml_call4(fprintf$0(fmt),_vk_,name,_H4_,_H3_);
                                         switch$0 = 1;
                                         break;
                                        case 3:
                                         var arg=expr[2],op=expr[1],arg_name=translate$0(fmt,arg);
                                         switch(op)
                                          {case 0:caml_call3(fprintf$0(fmt),_vm_,name,arg_name);break;
                                           case 1:caml_call3(fprintf$0(fmt),_vn_,name,arg_name);break;
                                           case 2:caml_call3(fprintf$0(fmt),_vo_,name,arg_name);break;
                                           case 3:caml_call3(fprintf$0(fmt),_vp_,name,arg_name);break;
                                           case 4:caml_call3(fprintf$0(fmt),_vq_,name,arg_name);break;
                                           case 5:caml_call3(fprintf$0(fmt),_vr_,name,arg_name);break;
                                           case 10:caml_call3(fprintf$0(fmt),_vt_,name,arg_name);break;
                                           case 11:caml_call3(fprintf$0(fmt),_vu_,name,arg_name);break;
                                           case 18:caml_call3(fprintf$0(fmt),_vv_,name,arg_name);break;
                                           default:failwith(symbol(_vs_,u_op_name(op)))}
                                         switch$0 = 1;
                                         break;
                                        case 4:
                                         var
                                          arg2=expr[3],
                                          arg1=expr[2],
                                          op$0=expr[1],
                                          a1=translate$0(fmt,arg1),
                                          a2=translate$0(fmt,arg2);
                                         switch(op$0)
                                          {case 2:caml_call4(fprintf$0(fmt),_vx_,name,a1,a2);break;
                                           case 3:caml_call4(fprintf$0(fmt),_vy_,name,a1,a2);break;
                                           case 4:caml_call4(fprintf$0(fmt),_vz_,name,a1,a2);break;
                                           case 5:caml_call4(fprintf$0(fmt),_vA_,name,a1,a2);break;
                                           case 7:caml_call4(fprintf$0(fmt),_vB_,name,a1,a2);break;
                                           default:failwith(symbol(_vw_,bin_op_name(op$0)))}
                                         switch$0 = 1;
                                         break;
                                        case 5:
                                         if(0 !== expr[1])
                                          {var _H5_=expr[2];
                                           if(_H5_)
                                            {var _H6_=_H5_[1];
                                             if(0 === _H6_[0])
                                              {var _H7_=_H5_[2];
                                               if(_H7_)
                                                {var _H8_=_H7_[1];
                                                 if(0 === _H8_[0])
                                                  {var _H9_=_H7_[2];
                                                   if(_H9_ && ! _H9_[2])
                                                    {var
                                                      arg$0=_H9_[1],
                                                      e=_H8_[1],
                                                      p=_H6_[1],
                                                      _H__=translate$0(fmt,arg$0),
                                                      _H$_=to_int(e),
                                                      _Ia_=to_int(p);
                                                     caml_call5(fprintf$0(fmt),_vC_,name,_Ia_,_H$_,_H__);
                                                     switch$0 = 1}}}}}}
                                         break
                                        }
                                      if(! switch$0)failwith(_vl_);
                                      return name},
                                   _HY_=translate$0;
                                 else
                                  var
                                   translate=
                                    function(fmt,expr)
                                     {var
                                       match=get_expr_name(env,_u3_,expr),
                                       found_flag=match[2],
                                       name=match[1];
                                      if(found_flag)return name;
                                      switch(expr[0])
                                       {case 3:
                                         var arg=expr[2],op=expr[1],arg_name=translate(fmt,arg);
                                         switch(op)
                                          {case 0:caml_call3(fprintf$0(fmt),_u5_,name,arg_name);break;
                                           case 1:caml_call3(fprintf$0(fmt),_u6_,name,arg_name);break;
                                           case 2:caml_call3(fprintf$0(fmt),_u7_,name,arg_name);break;
                                           case 3:caml_call3(fprintf$0(fmt),_u8_,name,arg_name);break;
                                           case 4:caml_call3(fprintf$0(fmt),_u9_,name,arg_name);break;
                                           case 5:caml_call3(fprintf$0(fmt),_u__,name,arg_name);break;
                                           case 10:caml_call3(fprintf$0(fmt),_va_,name,arg_name);break;
                                           case 11:caml_call3(fprintf$0(fmt),_vb_,name,arg_name);break;
                                           default:failwith(symbol(_u$_,u_op_name(op)))}
                                         break;
                                        case 4:
                                         var
                                          arg2=expr[3],
                                          arg1=expr[2],
                                          op$0=expr[1],
                                          a1=translate(fmt,arg1),
                                          a2=translate(fmt,arg2);
                                         switch(op$0)
                                          {case 0:caml_call4(fprintf$0(fmt),_vc_,name,a1,a2);break;
                                           case 1:caml_call4(fprintf$0(fmt),_vd_,name,a1,a2);break;
                                           case 2:caml_call4(fprintf$0(fmt),_ve_,name,a1,a2);break;
                                           case 3:caml_call4(fprintf$0(fmt),_vf_,name,a1,a2);break;
                                           case 4:caml_call4(fprintf$0(fmt),_vg_,name,a1,a2);break;
                                           case 5:caml_call4(fprintf$0(fmt),_vh_,name,a1,a2);break;
                                           default:failwith(symbol(_vi_,bin_op_name(op$0)))}
                                         break;
                                        default:failwith(_u4_)}
                                      return name},
                                   _HY_=translate;
                                 var
                                  match=write_to_string_result(_HY_,expr),
                                  result_name=match[2],
                                  body=match[1],
                                  _HZ_=1 < index?caml_string_of_jsbytes("" + index):_wO_,
                                  f_name=symbol(_wF_,_HZ_);
                                 function _H0_(_H2_){return print_list$0(_wG_,_H2_)}
                                 var _H1_=symbol(mp_prefix,_wH_);
                                 caml_call5(fprintf$0(fmt),_wI_,f_name,_H1_,_H0_,args);
                                 caml_call2(fprintf$0(fmt),_wJ_,body);
                                 if(caml_string_notequal(result_name,_wK_))
                                  if(mpfi)
                                   caml_call2(fprintf$0(fmt),_wL_,result_name);
                                  else
                                   caml_call2(fprintf$0(fmt),_wN_,result_name);
                                 return caml_call1(fprintf$0(fmt),_wM_)}},
                             e)}
                  var
                   mps=_y_(0,f,exprs),
                   opt$0=[0,sth$0],
                   _HP_=[0,sth$4],
                   _HQ_=[0,sth$2],
                   double$0=opt$0?sth$0:0,
                   single=_HQ_?sth$2:0,
                   mpfi=_HP_?sth$4:0;
                  if(mpfi)
                   var mp_type$0=_wc_,mp_prefix$0=_wb_;
                  else
                   var mp_type$0=mp_type,mp_prefix$0=mp_prefix;
                  var
                   _HE_=env[3],
                   c_names_mp=
                    map$0
                     (function(param)
                       {var i=param[2];return caml_call1(sprintf$0(_wd_),i)},
                      _HE_),
                   _HF_=env[3],
                   c_names_double=
                    map$0
                     (function(param)
                       {var i=param[2];return caml_call1(sprintf$0(_we_),i)},
                      _HF_),
                   _HG_=env[3],
                   c_names_single=
                    map$0
                     (function(param)
                       {var i=param[2];return caml_call1(sprintf$0(_wf_),i)},
                      _HG_);
                  function _HH_(i)
                   {return caml_call1(sprintf$0(_wg_),i + 1 | 0)}
                  var
                   tmp_names=init_list(env[5],_HH_),
                   tmp_vars_flag=0 < env[5]?1:0,
                   constants_flag=0 < length(env[3])?1:0;
                  if(tmp_vars_flag)
                   {var _HI_=function(_HV_){return print_list$0(_wh_,_HV_)};
                    caml_call4(fprintf$0(fmt),_wi_,mp_type$0,_HI_,tmp_names)}
                  if(constants_flag)
                   {var _HJ_=function(_HU_){return print_list$0(_wj_,_HU_)};
                    caml_call4(fprintf$0(fmt),_wk_,mp_type$0,_HJ_,c_names_mp);
                    if(double$0)
                     {var _HK_=function(_HT_){return print_list$0(_wl_,_HT_)};
                      caml_call3(fprintf$0(fmt),_wm_,_HK_,c_names_double)}
                    if(single)
                     {var _HL_=function(_HS_){return print_list$0(_wn_,_HS_)};
                      caml_call3(fprintf$0(fmt),_wo_,_HL_,c_names_single)}}
                  pp_print_newline(fmt,0);
                  caml_call1(fprintf$0(fmt),_wp_);
                  if(tmp_vars_flag)
                   iter$0
                    (function(v)
                      {return caml_call3(fprintf$0(fmt),_wq_,mp_prefix$0,v)},
                     tmp_names);
                  if(constants_flag)
                   iter$0
                    (function(c)
                      {return caml_call3(fprintf$0(fmt),_wr_,mp_prefix$0,c)},
                     c_names_mp);
                  var _HM_=env[3];
                  iter$0
                   (function(param)
                     {var
                       i=param[2],
                       n=param[1],
                       f_const=single?caml_call1(sprintf$0(_ws_),i):_ww_,
                       d_const=double$0?caml_call1(sprintf$0(_wt_),i):_wv_,
                       _HR_=string_of_num(n);
                      return caml_call5
                              (fprintf$0(fmt),_wu_,_HR_,f_const,d_const,i)},
                    _HM_);
                  caml_call1(fprintf$0(fmt),_wx_);
                  pp_print_newline(fmt,0);
                  caml_call1(fprintf$0(fmt),_wy_);
                  if(tmp_vars_flag)
                   iter$0
                    (function(v)
                      {return caml_call3(fprintf$0(fmt),_wz_,mp_prefix$0,v)},
                     tmp_names);
                  if(constants_flag)
                   iter$0
                    (function(c)
                      {return caml_call3(fprintf$0(fmt),_wA_,mp_prefix$0,c)},
                     c_names_mp);
                  caml_call1(fprintf$0(fmt),_wB_);
                  pp_print_newline(fmt,0);
                  return iter$0(caml_call1(fprintf$0(fmt),_wY_),mps)},
               generate_data_functions=
                function(fmt,task,named_exprs)
                 {var
                   vars=all_active_variables(task),
                   bounds=
                    map$0
                     (function(_HD_){return variable_interval(task,_HD_)},vars);
                  if(vars)
                   var task_vars=vars,var_bounds=bounds;
                  else
                   var
                    names=all_variables(task),
                    _Hv_=
                     0 === names?_xA_:[0,variable_interval(task,hd(names)),0],
                    task_vars=task_vars$0,
                    var_bounds=_Hv_;
                  var
                   var_names=
                    map$0
                     (function(s){return symbol(_xh_,fix_name(s))},task_vars),
                   env=mk_env(zip(task_vars,var_names));
                  caml_call1(fprintf$0(fmt),_xi_);
                  caml_call1(fprintf$0(fmt),_xj_);
                  pp_print_newline(fmt,0);
                  var
                   match=unzip(named_exprs),
                   exprs=match[2],
                   expr_names=match[1];
                  print_init_f_and_mps(env,fmt,0,0,_xk_,exprs);
                  pp_print_newline(fmt,0);
                  var
                   low_str=
                    map$0
                     (function(b)
                       {var _HC_=b[1];return caml_call1(sprintf$0(_xl_),_HC_)},
                      var_bounds),
                   high_str=
                    map$0
                     (function(b)
                       {var _HB_=b[2];return caml_call1(sprintf$0(_xm_),_HB_)},
                      var_bounds);
                  function _Ho_(_HA_){return print_list$0(_xn_,_HA_)}
                  caml_call3(fprintf$0(fmt),_xo_,_Ho_,low_str);
                  function _Hp_(_Hz_){return print_list$0(_xp_,_Hz_)}
                  caml_call3(fprintf$0(fmt),_xq_,_Hp_,high_str);
                  var expr_names$0=map$0(sprintf$0(_xr_),expr_names);
                  function _Hq_(_Hy_){return print_list$0(_xs_,_Hy_)}
                  caml_call3(fprintf$0(fmt),_xt_,_Hq_,expr_names$0);
                  var
                   n=length(exprs),
                   f_names=
                    init_list
                     (n,
                      function(i)
                       {var
                         _Hx_=
                          0 === i?_xu_:caml_string_of_jsbytes("" + (i + 1 | 0));
                        return symbol(_xv_,_Hx_)}),
                   _Hr_=length(f_names);
                  caml_call2(fprintf$0(fmt),_xw_,_Hr_);
                  function _Hs_(_Hw_){return print_list$0(_xx_,_Hw_)}
                  caml_call3(fprintf$0(fmt),_xy_,_Hs_,f_names);
                  var
                   _Ht_=remove_rnd(task[2]),
                   _Hu_=caml_call2(Info[3],0,_Ht_);
                  return caml_call2(fprintf$0(fmt),_xz_,_Hu_)},
               dummy_tform=[0,0,const_0,0],
               index$0=[0,0],
               next=function(param){var i=index$0[1];index$0[1]++;return i},
               err_index=[0,0],
               mk=
                function(index,exp)
                 {err_index[1]++;return [0,err_index[1],index,exp]},
               mk_proof_rnd_info=function(rnd){return [0,rnd[5][1],rnd[4]]},
               mk_sym_interval_const=
                function(f)
                 {var t=Math.abs(f),v=[254,- t,t];return mk_interval_const(v)},
               make_stronger=
                function(f){return proof_flag(0)?f == 0.?0.:next_float(f):f},
               make_stronger_i=
                function(v)
                 {if(proof_flag(0))
                   {var
                     _Hl_=next_float(v[2]),
                     _Hm_=v[1],
                     match=caml_classify_float(_Hm_);
                    switch(match)
                     {case 2:var _Hn_=caml_ldexp_float(-1.,-1074);break;
                      case 3:var _Hn_=_Hm_ == upper_bound?_Hm_:nan;break;
                      case 4:var _Hn_=nan;break;
                      default:
                       var
                        bits=caml_int64_bits_of_float(_Hm_),
                        _Hn_=
                         _Hm_ < 0.
                          ?caml_int64_float_of_bits(succ(bits))
                          :caml_int64_float_of_bits(pred(bits))}
                    return [254,_Hn_,_Hl_]}
                  return v},
               cache=[0,0],
               estimate=
                function(cs,e)
                 {if(get_bool_option(_xB_))
                   {var _Hk_=caml_call2(Info[3],0,e);
                    caml_call1(report(-364068301,_xC_),_Hk_);
                    var
                     match=find_min_max(default_opt_pars(0),cs,e),
                     max=match[2],
                     min=match[1];
                    caml_call2(report(-364068301,_xD_),min,max);
                    return [254,min,max]}
                  return caml_call1(eval_interval_expr(cs[1]),e)},
               estimate_and_cache=
                function(cs,e)
                 {try
                   {var _Hi_=assoc_eq(eq,e,cache[1]);return _Hi_}
                  catch(_Hj_)
                   {_Hj_ = caml_wrap_exception(_Hj_);
                    if(_Hj_ === Not_found)
                     {var interval=estimate(cs,e);
                      cache[1] = [0,[0,e,interval],cache[1]];
                      return interval}
                    throw _Hj_}},
               add2=
                function(param,_Hh_)
                 {var e2=_Hh_[2],x2=_Hh_[1],e1=param[2],x1=param[1];
                  if(e1 <= e2)
                   var x1$0=x1,e1$0=e1,x2$0=x2,e2$0=e2;
                  else
                   var x1$0=x2,e1$0=e2,x2$0=x1,e2$0=e1;
                  if(0 === e1$0)return 0 === e2$0?_xE_:[0,x2$0,e2$0];
                  if(0 === e2$0)return [0,x1$0,e1$0];
                  if(e1$0 === e2$0)return [0,symbol$1(x1$0,x2$0),e1$0];
                  var eps=get_eps(e1$0 - e2$0 | 0);
                  return [0,symbol$1(symbol$3(x1$0,eps),x2$0),e2$0]},
               sum_high=function(s){return itlist(add2,s,_xF_)},
               sum2_high=
                function(s1,s2)
                 {return itlist
                          (function(param,s)
                            {var
                              x_exp=param[2],
                              x=param[1],
                              s0=
                               sum_high
                                (map$0
                                  (function(param)
                                    {var y_exp=param[2],y=param[1];
                                     return [0,symbol$3(x,y),x_exp + y_exp | 0]},
                                   s2));
                             return add2(s,s0)},
                           s1,
                           _xG_)},
               abs_eval=
                function(cs,ex)
                 {var v=estimate_and_cache(cs,ex);return _gp_(v)[2]},
               abs_eval_v1=
                function(cs)
                 {function _He_(param)
                   {var err=param[2],ex=param[1],_Hg_=err[3];
                    return [0,abs_eval(cs,ex),_Hg_]}
                  return function(_Hf_){return map$0(_He_,_Hf_)}},
               simplify_form=
                function(cs,f)
                 {function add_adjacent(arg_index,s)
                   {var arg_index$0=arg_index,s$0=s;
                    for(;;)
                     {if(s$0)
                       {var _Hc_=s$0[2];
                        if(_Hc_)
                         {var
                           t=_Hc_[2],
                           _Hd_=_Hc_[1],
                           err2=_Hd_[2],
                           ex2=_Hd_[1],
                           match=s$0[1],
                           err1=match[2],
                           ex1=match[1];
                          if(-1 === err1[2] && -1 === err2[2])
                           {var
                             exp1=err1[3],
                             f1=abs_eval(cs,ex1),
                             exp2=err2[3],
                             f2=abs_eval(cs,ex2),
                             match$0=add2([0,f1,exp1],[0,f2,exp2]),
                             exp=match$0[2],
                             f=match$0[1],
                             f$0=make_stronger(f),
                             i=next(0),
                             err=mk(-1,exp),
                             op$0=[6,err1[1],err2[1]],
                             args$0=[0,[0,arg_index$0,0],[0,err[1],0],[0,f$0,[0,exp,0]]];
                            add_proof_step(i,op$0,args$0);
                            var
                             s$1=[0,[0,mk_float_const(f$0),err],t],
                             arg_index$0=i,
                             s$0=s$1;
                            continue}
                          if(err1[2] === err2[2])
                           {if(err1[3] === err2[3])
                             {var
                               i$0=next(0),
                               op=[5,err1[1],err2[1]],
                               args=[0,[0,arg_index$0,0],0,0];
                              add_proof_step(i$0,op,args);
                              var
                               s$2=[0,[0,mk_add(ex1,ex2),err1],t],
                               arg_index$0=i$0,
                               s$0=s$2;
                              continue}
                            throw [0,Assert_failure,_xH_]}
                          var
                           match$1=add_adjacent(arg_index$0,[0,[0,ex2,err2],t]),
                           s$3=match$1[2],
                           index=match$1[1];
                          return [0,index,[0,[0,ex1,err1],s$3]]}}
                      return [0,arg_index$0,s$0]}}
                  var
                   _Ha_=f[3],
                   v1=
                    stable_sort
                     (function(param,_Hb_)
                       {var err2=_Hb_[2],err1=param[2];
                        return caml_int_compare(err1[2],err2[2])},
                      _Ha_),
                   match=add_adjacent(f[1],v1),
                   v1_new=match[2],
                   i=match[1];
                  return [0,i,f[2],v1_new]},
               counter$0=[0,0],
               exprs=[0,0],
               find_index=
                function(expr)
                 {var unique_flag=get_bool_option(_xI_),param=exprs[1],d=-1;
                  for(;;)
                   {if(param)
                     {var t=param[2],match=param[1],v=match[2],k=match[1];
                      if(! eq(k,expr)){var param=t;continue}
                      var i=v}
                    else
                     var i=d;
                    if(0 < i && ! unique_flag)return i;
                    counter$0[1] = counter$0[1] + 1 | 0;
                    exprs[1] = [0,[0,expr,counter$0[1]],exprs[1]];
                    return counter$0[1]}},
               const_form=
                function(e)
                 {report(-364068301,_xJ_);
                  if(0 === e[0])
                   {var c=e[1],i=next(0);
                    try
                     {var _G__=to_num(c),n=_G__}
                    catch(_G$_)
                     {_G$_ = caml_wrap_exception(_G$_);
                      if(_G$_[1] !== Failure)throw _G$_;
                      warning(_xK_);
                      var n=_xL_}
                    add_const_step(i,n);
                    return [0,i,e,0]}
                  return failwith(symbol(_xM_,caml_call2(Info[3],0,e)))},
               get_var_uncertainty=
                function(cs,eps_exp,var_name)
                 {var
                   v=caml_call1(cs[3],var_name),
                   _G8_=num_of_float(get_eps(eps_exp)),
                   u=div_num(to_num(v),_G8_);
                  if(eq_num(u,_xY_))return 0;
                  var _G9_=mk(find_index([1,symbol(var_name,_xZ_)]),eps_exp);
                  return [0,[0,mk_num_const(u),_G9_],0]},
               neg_form=
                function(f)
                 {report(-364068301,_x__);
                  var i=next(0),args=[0,[0,f[1],0],0,0];
                  add_proof_step(i,0,args);
                  var
                   _G6_=f[3],
                   _G7_=
                    map$0
                     (function(param)
                       {var err=param[2],e=param[1];return [0,mk_neg(e),err]},
                      _G6_);
                  return [0,i,mk_neg(f[2]),_G7_]},
               add_form=
                function(f1,f2)
                 {report(-364068301,_x$_);
                  var i=next(0),args=[0,[0,f1[1],[0,f2[1],0]],0,0];
                  add_proof_step(i,1,args);
                  var _G5_=append(f1[3],f2[3]);
                  return [0,i,mk_add(f1[2],f2[2]),_G5_]},
               rounded_sub_form=
                function(cs,original_expr,rnd,f1,f2)
                 {report(-364068301,_yb_);
                  var
                   i=find_index(original_expr),
                   _GY_=f1[3],
                   match=sum_high(caml_call1(abs_eval_v1(cs),_GY_)),
                   exp1=match[2],
                   s1=match[1],
                   _GZ_=f2[3],
                   match$0=sum_high(caml_call1(abs_eval_v1(cs),_GZ_)),
                   exp2=match$0[2],
                   s2=match$0[1],
                   s1$0=make_stronger(symbol$3(get_eps(exp1),s1)),
                   s2$0=make_stronger(symbol$3(get_eps(exp2),s2)),
                   _G0_=mk_sym_interval_const(s2$0),
                   b=mk_add(f2[2],_G0_),
                   _G1_=mk_sym_interval_const(s1$0),
                   a=mk_add(f1[2],_G1_),
                   r=mk_floor_power2([4,7,a,b]),
                   r$0=rnd[4] == 1.?r:mk_mul(mk_float_const(rnd[4]),r),
                   form_index=next(0),
                   r_err=mk(i,rnd[2]),
                   _G2_=f2[3],
                   _G3_=
                    map$0
                     (function(param)
                       {var err=param[2],e=param[1];return [0,mk_neg(e),err]},
                      _G2_),
                   _G4_=[0,[0,r$0,r_err],append(f1[3],_G3_)];
                  return [0,form_index,mk_sub(f1[2],f2[2]),_G4_]},
               mul1=
                function(x)
                 {function _GW_(param)
                   {var err=param[2],e=param[1];return [0,mk_mul(x,e),err]}
                  return function(_GX_){return map$0(_GW_,_GX_)}},
               mul_form=
                function(cs,f1,f2)
                 {report(-364068301,_yd_);
                  var
                   _GP_=f1[3],
                   x1=caml_call1(abs_eval_v1(cs),_GP_),
                   _GQ_=f2[3],
                   y1=caml_call1(abs_eval_v1(cs),_GQ_),
                   match=sum2_high(x1,y1),
                   m2_exp=match[2],
                   m2=match[1],
                   m2_bound=make_stronger(m2),
                   i=next(0),
                   m2_err=mk(-1,m2_exp),
                   args=
                    [0,
                     [0,f1[1],[0,f2[1],0]],
                     [0,m2_err[1],0],
                     [0,m2_bound,[0,m2_exp,0]]];
                  add_proof_step(i,3,args);
                  var
                   _GR_=[0,[0,mk_float_const(m2_bound),m2_err],0],
                   _GS_=f1[3],
                   _GT_=append(caml_call1(mul1(f2[2]),_GS_),_GR_),
                   _GU_=f2[3],
                   _GV_=append(caml_call1(mul1(f1[2]),_GU_),_GT_);
                  return [0,i,mk_mul(f1[2],f2[2]),_GV_]},
               inv_form=
                function(cs,f)
                 {report(-364068301,_ye_);
                  var
                   x0_int=estimate_and_cache(cs,f[2]),
                   _GL_=f[3],
                   x1=caml_call1(abs_eval_v1(cs),_GL_),
                   s1=
                    itlist
                     (function(param,s)
                       {var
                         x_exp=param[2],
                         x=param[1],
                         eps=get_eps(x_exp),
                         xi=[254,- eps,eps];
                        return _gs_(_gv_(xi,x),s)},
                      x1,
                      _gl_),
                   m1=make_stronger(_gp_(s1)[2]),
                   d=
                    proof_flag(0)
                     ?_gC_(_gs_(x0_int,[254,- m1,m1]),3)
                     :_gC_(_gs_(x0_int,s1),3);
                  if(_gp_(d)[1] <= 0.)
                   if(fail_on_exception(0))
                    failwith(msg$0);
                   else
                    warning_str(msg$0);
                  var
                   b_high=_gp_(_gA_(d))[2],
                   b=make_stronger(b_high),
                   match=sum2_high(x1,x1),
                   m2_exp=match[2],
                   m2=match[1],
                   m2$0=make_stronger(m2),
                   m3=symbol$3(b,m2$0),
                   m3$0=make_stronger(m3),
                   i=next(0),
                   m3_err=mk(-1,m2_exp),
                   args=
                    [0,
                     [0,f[1],0],
                     [0,m3_err[1],0],
                     [0,m1,[0,m2$0,[0,m2_exp,[0,b,[0,m3$0,0]]]]]];
                  add_proof_step(i,4,args);
                  var
                   _GM_=[0,[0,mk_float_const(m3$0),m3_err],0],
                   _GN_=f[3],
                   _GO_=
                    append
                     (map$0
                       (function(param)
                         {var err=param[2],e=param[1];
                          return [0,mk_neg(mk_div(e,mk_mul(f[2],f[2]))),err]},
                        _GN_),
                      _GM_);
                  return [0,i,mk_div(const_1,f[2]),_GO_]},
               build_form=
                function(cs)
                 {function build(e$4)
                   {switch(e$4[0])
                     {case 0:return const_form(e$4);
                      case 1:
                       report(-364068301,_x0_);
                       if(1 === e$4[0])
                        {var v=e$4[1],i$0=next(0),op=[0,v],args=[0,0,0,0];
                         add_proof_step(i$0,op,args);
                         var
                          _E5_=
                           get_bool_option(_x2_)?get_var_uncertainty(cs,-53,v):0;
                         return [0,i$0,e$4,_E5_]}
                       return failwith(symbol(_x1_,caml_call2(Info[3],0,e$4)));
                      case 2:
                       var _GF_=e$4[2],_GG_=e$4[1];
                       switch(_GF_[0])
                        {case 0:
                          var c$2=_GF_[1];
                          if(is_rat(c$2))
                           {var e$5=[0,c$2];
                            report(-364068301,_xT_);
                            if(get_bool_option(_xU_))
                             {report(-364068301,_xN_);
                              if(0 === e$5[0])
                               {var c=e$5[1];
                                if(is_rat(c))
                                 {var
                                   cn=to_num(c),
                                   x=bin_float_of_num(- _GG_[2] | 0,_GG_[6],cn),
                                   rc=num_of_bin_float(x),
                                   d=sub_num(cn,rc);
                                  if(eq_num(d,_xO_))return const_form(e$5);
                                  var
                                   form_index=next(0),
                                   err_expr=
                                    mk_num_const(div_num(d,power_num(_xP_,[0,_GG_[2]]))),
                                   _EX_=_GG_[2],
                                   err=mk(find_index([2,_GG_,const_0]),_EX_),
                                   _EY_=caml_call2(Info[3],0,err_expr),
                                   _EZ_=caml_call2(Info[3],0,e$5);
                                  caml_call2(report(-364068301,_xQ_),_EZ_,_EY_);
                                  return [0,form_index,e$5,[0,[0,err_expr,err],0]]}
                                throw [0,Assert_failure,_xR_]}
                              return failwith(symbol(_xS_,caml_call2(Info[3],0,e$5)))}
                            if(0 === e$5[0])
                             {var c$0=e$5[1];
                              if(is_rat(c$0))
                               {if(is_exact_fp_const(_GG_,to_num(c$0)))
                                 return const_form(e$5);
                                var
                                 i=next(0),
                                 bound=_gp_(to_interval(c$0))[2],
                                 p2=floor_power2(bound),
                                 match=caml_frexp_float(p2),
                                 p2_exp=match[2];
                                if(proof_flag(0))
                                 var
                                  _E0_=get_eps(_GG_[2]),
                                  m2=symbol$1(p2,get_eps(_GG_[3]) / _E0_);
                                else
                                 var m2=p2;
                                var
                                 bound$0=symbol$3(_GG_[4],m2),
                                 err_expr$0=mk_float_const(bound$0),
                                 _E1_=_GG_[2],
                                 err$0=mk(find_index([2,_GG_,e$5]),_E1_),
                                 _E2_=caml_call2(Info[3],0,err_expr$0),
                                 _E3_=caml_call2(Info[3],0,e$5);
                                caml_call2(report(-364068301,_xV_),_E3_,_E2_);
                                var
                                 _E4_=err$0[1],
                                 rnd=mk_proof_rnd_info(_GG_),
                                 c$1=to_num(c$0),
                                 op$1=[3,rnd,c$1],
                                 args$1=[0,0,[0,_E4_,0],[0,p2_exp,[0,bound$0,0]]];
                                add_proof_step(i,op$1,args$1);
                                return [0,i,e$5,[0,[0,err_expr$0,err$0],0]]}
                              throw [0,Assert_failure,_xW_]}
                            return failwith(symbol(_xX_,caml_call2(Info[3],0,e$5)))}
                          break;
                         case 1:
                          var v$1=_GF_[1],e$6=[1,v$1];
                          report(-364068301,_x3_);
                          if(1 === e$6[0])
                           {var v$0=e$6[1];
                            if(proof_flag(0))
                             {var
                               i$1=next(0),
                               bound$1=_gp_(caml_call1(cs[1],v$0))[2],
                               p2$0=floor_power2(bound$1),
                               match$0=caml_frexp_float(p2$0),
                               p2_exp$0=match$0[2],
                               _E6_=get_eps(_GG_[2]),
                               m2$0=symbol$1(p2$0,get_eps(_GG_[3]) / _E6_),
                               bound$2=symbol$3(_GG_[4],m2$0),
                               err_expr$1=mk_float_const(bound$2),
                               _E7_=_GG_[2],
                               err$1=mk(find_index([2,_GG_,e$6]),_E7_),
                               _E8_=err$1[1],
                               rnd$0=mk_proof_rnd_info(_GG_),
                               op$0=[2,rnd$0,v$0],
                               args$0=[0,0,[0,_E8_,0],[0,p2_exp$0,[0,bound$2,0]]];
                              add_proof_step(i$1,op$0,args$0);
                              return [0,i$1,e$6,[0,[0,err_expr$1,err$1],0]]}
                            var
                             v1_uncertainty=
                              get_bool_option(_x5_)?get_var_uncertainty(cs,_GG_[2],v$0):0;
                            if(get_bool_option(_x6_))
                             var
                              bound$3=_gp_(caml_call1(cs[1],v$0))[2],
                              err$2=floor_power2(bound$3),
                              err_expr0=mk_float_const(err$2);
                            else
                             var
                              err_expr0=
                               get_bool_option(_x7_)?mk_floor_power2(e$6):e$6;
                            var
                             err_expr$2=
                              _GG_[4] != 1.
                               ?mk_mul(mk_float_const(_GG_[4]),err_expr0)
                               :err_expr0,
                             _E9_=_GG_[2],
                             v1_rnd=
                              [0,[0,err_expr$2,mk(find_index([2,_GG_,e$6]),_E9_)],0],
                             _E__=append(v1_uncertainty,v1_rnd);
                            return [0,next(0),e$6,_E__]}
                          return failwith(symbol(_x4_,caml_call2(Info[3],0,e$6)));
                         case 4:
                          var _GH_=_GF_[1];
                          if(2 === _GH_)
                           {var arg2=_GF_[3],arg1=_GF_[2];
                            if
                             (_GG_[7] && get_bool_option(_yy_) && get_bool_option(_yz_))
                             {var f2=build(arg2),f1=build(arg1);
                              report(-364068301,_yc_);
                              return rounded_sub_form(cs,e$4,_GG_,f1,neg_form(f2))}}
                          else
                           if(3 === _GH_)
                            {var arg2$0=_GF_[3],arg1$0=_GF_[2];
                             if
                              (_GG_[7] && get_bool_option(_yA_) && get_bool_option(_yB_))
                              {var _GI_=build(arg2$0);
                               return rounded_sub_form(cs,e$4,_GG_,build(arg1$0),_GI_)}}
                          break
                         }
                       var f=build(_GF_);
                       report(-364068301,_x8_);
                       if(0 === _GG_[2])
                        {var
                          _E$_=mk(-1,_GG_[3]),
                          _Fa_=[0,[0,mk_float_const(_GG_[4]),_E$_],0],
                          _Fb_=append(f[3],_Fa_),
                          _Fc_=f[2];
                         return [0,next(0),_Fc_,_Fb_]}
                       var
                        i$2=find_index(e$4),
                        _Fd_=f[3],
                        match$1=sum_high(caml_call1(abs_eval_v1(cs),_Fd_)),
                        exp1=match$1[2],
                        s1=match$1[1],
                        s1_bound=make_stronger(symbol$3(get_eps(exp1),s1));
                       if(get_bool_option(_x9_))
                        var
                         _Fe_=get_eps(_GG_[2]),
                         m2$1=get_eps(_GG_[3]) / _Fe_,
                         _Ff_=mk_sym_interval_const(s1_bound),
                         r=mk_floor_power2(mk_add(f[2],_Ff_)),
                         m2$2=m2$1;
                       else
                        var
                         _Fl_=get_eps(_GG_[2]),
                         m2$5=symbol$1(s1_bound,get_eps(_GG_[3]) / _Fl_),
                         r=f[2],
                         m2$2=m2$5;
                       if(_GG_[4] == 1.)
                        var r$0=r,m2$3=m2$2;
                       else
                        var
                         m2$4=symbol$3(_GG_[4],m2$2),
                         r$1=mk_mul(mk_float_const(_GG_[4]),r),
                         r$0=r$1,
                         m2$3=m2$4;
                       var
                        i$3=next(0),
                        m2_bound=make_stronger(m2$3),
                        r_err=mk(i$2,_GG_[2]),
                        m2_err=mk(-1,_GG_[2]),
                        _Fg_=m2_err[1],
                        _Fh_=r_err[1],
                        _Fi_=f[1],
                        rnd$1=mk_proof_rnd_info(_GG_),
                        op$2=[4,rnd$1],
                        args$2=
                         [0,
                          [0,_Fi_,0],
                          [0,_Fh_,[0,_Fg_,0]],
                          [0,s1_bound,[0,m2_bound,0]]];
                       add_proof_step(i$3,op$2,args$2);
                       var
                        _Fj_=[0,[0,mk_float_const(m2_bound),m2_err],0],
                        _Fk_=append([0,[0,r$0,r_err],f[3]],_Fj_);
                       return [0,i$3,f[2],_Fk_];
                      case 3:
                       var arg=e$4[2],op$3=e$4[1],f$0=build(arg);
                       switch(op$3)
                        {case 0:return neg_form(f$0);
                         case 1:
                          report(-364068301,_yv_);
                          var
                           i$11=next(0),
                           _Gl_=f$0[3],
                           match$17=sum_high(caml_call1(abs_eval_v1(cs),_Gl_)),
                           e=match$17[2],
                           s=match$17[1],
                           t$1=make_stronger(symbol$3(get_eps(e),s)),
                           _Gm_=f$0[2],
                           abs_err=mk_abs_err(mk_sym_interval_const(t$1),_Gm_),
                           _Gn_=f$0[3],
                           _Go_=
                            map$0
                             (function(param)
                               {var err=param[2],e=param[1];
                                return [0,mk_mul(abs_err,e),err]},
                              _Gn_);
                          return [0,i$11,mk_abs(f$0[2]),_Go_];
                         case 2:return inv_form(cs,f$0);
                         case 3:
                          report(-364068301,_yg_);
                          var
                           x0_int=estimate_and_cache(cs,f$0[2]),
                           _Fp_=f$0[3],
                           x1=caml_call1(abs_eval_v1(cs),_Fp_),
                           s1$0=
                            itlist
                             (function(param,s)
                               {var
                                 x_exp=param[2],
                                 x=param[1],
                                 eps=get_eps(x_exp),
                                 xi=[254,- eps,eps];
                                return _gs_(_gv_(xi,x),s)},
                              x1,
                              _gl_),
                           m1=make_stronger(_gp_(s1$0)[2]);
                          if(proof_flag(0))
                           var t=_gs_(x0_int,[254,- m1,m1]),d$0=_gu_(_gB_(t),t);
                          else
                           var t$0=_gs_(x0_int,s1$0),d$0=_gu_(_gB_(t$0),t$0);
                          var
                           b_high=symbol$3(0.125,_gp_(_gA_(d$0))[2]),
                           b=make_stronger(b_high),
                           match$2=sum2_high(x1,x1),
                           m2_exp=match$2[2],
                           m2$6=match$2[1],
                           m2$7=make_stronger(m2$6),
                           m3=symbol$3(b,m2$7),
                           i$5=next(0),
                           m3_err=mk(-1,m2_exp),
                           args$4=
                            [0,
                             [0,f$0[1],0],
                             [0,m3_err[1],0],
                             [0,m1,[0,m2$7,[0,m2_exp,[0,b,[0,m3,0]]]]]];
                          add_proof_step(i$5,5,args$4);
                          var
                           sqrt_v0=mk_sqrt(f$0[2]),
                           _Fq_=[0,[0,mk_float_const(m3),m3_err],0],
                           _Fr_=f$0[3];
                          return [0,
                                  i$5,
                                  sqrt_v0,
                                  append
                                   (map$0
                                     (function(param)
                                       {var err=param[2],e=param[1];
                                        return [0,mk_div(e,mk_mul(const_2,sqrt_v0)),err]},
                                      _Fr_),
                                    _Fq_)];
                         case 4:
                          report(-364068301,_yh_);
                          var
                           x0_int$0=estimate_and_cache(cs,f$0[2]),
                           _Fs_=f$0[3],
                           x1$0=caml_call1(abs_eval_v1(cs),_Fs_),
                           s1$1=
                            itlist
                             (function(param,s)
                               {var
                                 x_exp=param[2],
                                 x=param[1],
                                 eps=get_eps(x_exp),
                                 xi=[254,- eps,eps];
                                return _gs_(_gv_(xi,x),s)},
                              x1$0,
                              _gl_),
                           m1$0=make_stronger(_gp_(s1$1)[2]),
                           d$1=
                            proof_flag(0)
                             ?_gF_(_gs_(x0_int$0,[254,- m1$0,m1$0]))
                             :_gF_(_gs_(x0_int$0,s1$1)),
                           b_high$0=symbol$3(0.5,_gp_(d$1)[2]),
                           b$0=make_stronger(b_high$0),
                           match$3=sum2_high(x1$0,x1$0),
                           m2_exp$0=match$3[2],
                           m2$8=match$3[1],
                           m2$9=make_stronger(m2$8),
                           m3$0=symbol$3(b$0,m2$9),
                           i$6=next(0),
                           m3_err$0=mk(-1,m2_exp$0),
                           args$5=
                            [0,
                             [0,f$0[1],0],
                             [0,m3_err$0[1],0],
                             [0,m1$0,[0,m2$9,[0,m2_exp$0,[0,b$0,[0,m3$0,0]]]]]];
                          add_proof_step(i$6,6,args$5);
                          var
                           sin_v0=mk_sin(f$0[2]),
                           cos_v0=mk_cos(f$0[2]),
                           _Ft_=[0,[0,mk_float_const(m3$0),m3_err$0],0],
                           _Fu_=f$0[3];
                          return [0,
                                  i$6,
                                  sin_v0,
                                  append
                                   (map$0
                                     (function(param)
                                       {var err=param[2],e=param[1];
                                        return [0,mk_mul(cos_v0,e),err]},
                                      _Fu_),
                                    _Ft_)];
                         case 5:
                          report(-364068301,_yi_);
                          var
                           x0_int$1=estimate_and_cache(cs,f$0[2]),
                           _Fv_=f$0[3],
                           x1$1=caml_call1(abs_eval_v1(cs),_Fv_),
                           s1$2=
                            itlist
                             (function(param,s)
                               {var
                                 x_exp=param[2],
                                 x=param[1],
                                 eps=get_eps(x_exp),
                                 xi=[254,- eps,eps];
                                return _gs_(_gv_(xi,x),s)},
                              x1$1,
                              _gl_),
                           m1$1=make_stronger(_gp_(s1$2)[2]),
                           d$2=
                            proof_flag(0)
                             ?_gH_(_gs_(x0_int$1,[254,- m1$1,m1$1]))
                             :_gH_(_gs_(x0_int$1,s1$2)),
                           b_high$1=symbol$3(0.5,_gp_(d$2)[2]),
                           b$1=make_stronger(b_high$1),
                           match$4=sum2_high(x1$1,x1$1),
                           m2_exp$1=match$4[2],
                           m2$10=match$4[1],
                           m2$11=make_stronger(m2$10),
                           m3$1=symbol$3(b$1,m2$11),
                           i$7=next(0),
                           m3_err$1=mk(-1,m2_exp$1),
                           args$6=
                            [0,
                             [0,f$0[1],0],
                             [0,m3_err$1[1],0],
                             [0,m1$1,[0,m2$11,[0,m2_exp$1,[0,b$1,[0,m3$1,0]]]]]];
                          add_proof_step(i$7,7,args$6);
                          var
                           sin_v0$0=mk_sin(f$0[2]),
                           cos_v0$0=mk_cos(f$0[2]),
                           _Fw_=[0,[0,mk_float_const(m3$1),m3_err$1],0],
                           _Fx_=f$0[3];
                          return [0,
                                  i$7,
                                  cos_v0$0,
                                  append
                                   (map$0
                                     (function(param)
                                       {var err=param[2],e=param[1];
                                        return [0,mk_neg(mk_mul(sin_v0$0,e)),err]},
                                      _Fx_),
                                    _Fw_)];
                         case 6:
                          report(-364068301,_yj_);
                          var
                           x0_int$2=estimate_and_cache(cs,f$0[2]),
                           _Fy_=f$0[3],
                           x1$2=caml_call1(abs_eval_v1(cs),_Fy_),
                           s1$3=
                            itlist
                             (function(param,s)
                               {var
                                 x_exp=param[2],
                                 x=param[1],
                                 eps=get_eps(x_exp),
                                 xi=[254,- eps,eps];
                                return _gs_(_gv_(xi,x),s)},
                              x1$2,
                              _gl_),
                           xi=_gs_(x0_int$2,s1$3),
                           _Fz_=_gC_(_gH_(xi),2),
                           d$3=_gy_(_gO_(xi),_Fz_),
                           r_high=_gp_(d$3)[2],
                           match$5=sum2_high(x1$2,x1$2),
                           m2_exp$2=match$5[2],
                           m2$12=match$5[1],
                           m2$13=symbol$3(r_high,m2$12),
                           _FA_=mk_cos(f$0[2]),
                           v1_0=mk_mul(mk_cos(f$0[2]),_FA_),
                           _FB_=mk(-1,m2_exp$2),
                           _FC_=[0,[0,mk_float_const(m2$13),_FB_],0],
                           _FD_=f$0[3],
                           _FE_=
                            append
                             (map$0
                               (function(param)
                                 {var err=param[2],e=param[1];return [0,mk_div(e,v1_0),err]},
                                _FD_),
                              _FC_),
                           _EW_=[3,6,f$0[2]];
                          return [0,next(0),_EW_,_FE_];
                         case 7:
                          report(-364068301,_yk_);
                          var
                           x0_int$3=estimate_and_cache(cs,f$0[2]),
                           _FF_=f$0[3],
                           x1$3=caml_call1(abs_eval_v1(cs),_FF_),
                           s1$4=
                            itlist
                             (function(param,s)
                               {var
                                 x_exp=param[2],
                                 x=param[1],
                                 eps=get_eps(x_exp),
                                 xi=[254,- eps,eps];
                                return _gs_(_gv_(xi,x),s)},
                              x1$3,
                              _gl_),
                           m1$2=make_stronger(_gp_(s1$4)[2]),
                           xi$0=
                            proof_flag(0)
                             ?_gs_(x0_int$3,[254,- m1$2,m1$2])
                             :_gs_(x0_int$3,s1$4),
                           d$4=_gy_(xi$0,_gB_(_gC_(_gt_(_gm_,_gC_(xi$0,2)),3))),
                           b_high$2=symbol$3(0.5,_gp_(d$4)[2]),
                           b_high$3=make_stronger(b_high$2),
                           match$6=sum2_high(x1$3,x1$3),
                           m2_exp$3=match$6[2],
                           m2$14=match$6[1],
                           m2$15=make_stronger(m2$14),
                           m3$2=symbol$3(b_high$3,m2$15),
                           form_index$0=next(0),
                           m3_err$2=mk(-1,m2_exp$3),
                           v1_0$0=mk_sqrt(mk_sub(const_1,mk_mul(f$0[2],f$0[2]))),
                           _FG_=[0,[0,mk_float_const(m3$2),m3_err$2],0],
                           _FH_=f$0[3],
                           _FI_=
                            append
                             (map$0
                               (function(param)
                                 {var err=param[2],e=param[1];
                                  return [0,mk_div(e,v1_0$0),err]},
                                _FH_),
                              _FG_);
                          return [0,form_index$0,[3,7,f$0[2]],_FI_];
                         case 8:
                          report(-364068301,_yl_);
                          var
                           x0_int$4=estimate_and_cache(cs,f$0[2]),
                           _FJ_=f$0[3],
                           x1$4=caml_call1(abs_eval_v1(cs),_FJ_),
                           s1$5=
                            itlist
                             (function(param,s)
                               {var
                                 x_exp=param[2],
                                 x=param[1],
                                 eps=get_eps(x_exp),
                                 xi=[254,- eps,eps];
                                return _gs_(_gv_(xi,x),s)},
                              x1$4,
                              _gl_),
                           m1$3=make_stronger(_gp_(s1$5)[2]),
                           xi$1=
                            proof_flag(0)
                             ?_gs_(x0_int$4,[254,- m1$3,m1$3])
                             :_gs_(x0_int$4,s1$5),
                           d$5=_go_(_gy_(xi$1,_gB_(_gC_(_gt_(_gm_,_gC_(xi$1,2)),3)))),
                           b_high$4=symbol$3(0.5,_gp_(d$5)[2]),
                           b_high$5=make_stronger(b_high$4),
                           match$7=sum2_high(x1$4,x1$4),
                           m2_exp$4=match$7[2],
                           m2$16=match$7[1],
                           m2$17=make_stronger(m2$16),
                           m3$3=symbol$3(b_high$5,m2$17),
                           form_index$1=next(0),
                           m3_err$3=mk(-1,m2_exp$4),
                           v1_0$1=mk_sqrt(mk_sub(const_1,mk_mul(f$0[2],f$0[2]))),
                           _FK_=[0,[0,mk_float_const(m3$3),m3_err$3],0],
                           _FL_=f$0[3],
                           _FM_=
                            append
                             (map$0
                               (function(param)
                                 {var err=param[2],e=param[1];
                                  return [0,mk_neg(mk_div(e,v1_0$1)),err]},
                                _FL_),
                              _FK_);
                          return [0,form_index$1,[3,8,f$0[2]],_FM_];
                         case 9:
                          report(-364068301,_ym_);
                          var
                           x0_int$5=estimate_and_cache(cs,f$0[2]),
                           _FN_=f$0[3],
                           x1$5=caml_call1(abs_eval_v1(cs),_FN_),
                           s1$6=
                            itlist
                             (function(param,s)
                               {var
                                 x_exp=param[2],
                                 x=param[1],
                                 eps=get_eps(x_exp),
                                 xi=[254,- eps,eps];
                                return _gs_(_gv_(xi,x),s)},
                              x1$5,
                              _gl_),
                           m1$4=make_stronger(_gp_(s1$6)[2]),
                           xi$2=
                            proof_flag(0)
                             ?_gs_(x0_int$5,[254,- m1$4,m1$4])
                             :_gs_(x0_int$5,s1$6),
                           d$6=_go_(_gy_(xi$2,_gC_(_gs_(_gC_(xi$2,2),_gm_),2))),
                           b_high$6=_gp_(d$6)[2],
                           b$2=make_stronger(b_high$6),
                           match$8=sum2_high(x1$5,x1$5),
                           m2_exp$5=match$8[2],
                           m2$18=match$8[1],
                           m2$19=make_stronger(m2$18),
                           m3$4=symbol$3(b$2,m2$19),
                           i$8=next(0),
                           m3_err$4=mk(-1,m2_exp$5),
                           args$7=
                            [0,
                             [0,f$0[1],0],
                             [0,m3_err$4[1],0],
                             [0,m1$4,[0,m2$19,[0,m2_exp$5,[0,b$2,[0,m3$4,0]]]]]];
                          add_proof_step(i$8,8,args$7);
                          var
                           v1_0$2=mk_add(mk_mul(f$0[2],f$0[2]),const_1),
                           _FO_=[0,[0,mk_float_const(m3$4),m3_err$4],0],
                           _FP_=f$0[3],
                           _FQ_=
                            append
                             (map$0
                               (function(param)
                                 {var err=param[2],e=param[1];
                                  return [0,mk_div(e,v1_0$2),err]},
                                _FP_),
                              _FO_);
                          return [0,i$8,[3,9,f$0[2]],_FQ_];
                         case 10:
                          report(-364068301,_yn_);
                          var
                           x0_int$6=estimate_and_cache(cs,f$0[2]),
                           _FR_=f$0[3],
                           x1$6=caml_call1(abs_eval_v1(cs),_FR_),
                           s1$7=
                            itlist
                             (function(param,s)
                               {var
                                 x_exp=param[2],
                                 x=param[1],
                                 eps=get_eps(x_exp),
                                 xi=[254,- eps,eps];
                                return _gs_(_gv_(xi,x),s)},
                              x1$6,
                              _gl_),
                           m1$5=make_stronger(_gp_(s1$7)[2]),
                           d$7=
                            proof_flag(0)
                             ?_gD_(_gs_(x0_int$6,[254,- m1$5,m1$5]))
                             :_gD_(_gs_(x0_int$6,s1$7)),
                           b_high$7=symbol$3(0.5,_gp_(d$7)[2]),
                           b$3=make_stronger(b_high$7),
                           match$9=sum2_high(x1$6,x1$6),
                           m2_exp$6=match$9[2],
                           m2$20=match$9[1],
                           m2$21=make_stronger(m2$20),
                           m3$5=symbol$3(b$3,m2$21),
                           i$9=next(0),
                           m3_err$5=mk(-1,m2_exp$6),
                           args$8=
                            [0,
                             [0,f$0[1],0],
                             [0,m3_err$5[1],0],
                             [0,m1$5,[0,m2$21,[0,m2_exp$6,[0,b$3,[0,m3$5,0]]]]]];
                          add_proof_step(i$9,9,args$8);
                          var
                           exp_v0=[3,10,f$0[2]],
                           _FS_=[0,[0,mk_float_const(m3$5),m3_err$5],0],
                           _FT_=f$0[3];
                          return [0,
                                  i$9,
                                  exp_v0,
                                  append
                                   (map$0
                                     (function(param)
                                       {var err=param[2],e=param[1];
                                        return [0,mk_mul(exp_v0,e),err]},
                                      _FT_),
                                    _FS_)];
                         case 11:
                          report(-364068301,_yo_);
                          var
                           x0_int$7=estimate_and_cache(cs,f$0[2]),
                           _FU_=f$0[3],
                           x1$7=caml_call1(abs_eval_v1(cs),_FU_),
                           s1$8=
                            itlist
                             (function(param,s)
                               {var
                                 x_exp=param[2],
                                 x=param[1],
                                 eps=get_eps(x_exp),
                                 xi=[254,- eps,eps];
                                return _gs_(_gv_(xi,x),s)},
                              x1$7,
                              _gl_),
                           m1$6=make_stronger(_gp_(s1$8)[2]),
                           d$8=
                            proof_flag(0)
                             ?_gA_(_gC_(_gs_(x0_int$7,[254,- m1$6,m1$6]),2))
                             :_gA_(_gC_(_gs_(x0_int$7,s1$8),2)),
                           b_high$8=symbol$3(0.5,_gp_(d$8)[2]),
                           b$4=make_stronger(b_high$8),
                           match$10=sum2_high(x1$7,x1$7),
                           m2_exp$7=match$10[2],
                           m2$22=match$10[1],
                           m2$23=make_stronger(m2$22),
                           m3$6=symbol$3(b$4,m2$23),
                           i$10=next(0),
                           m3_err$6=mk(-1,m2_exp$7),
                           args$9=
                            [0,
                             [0,f$0[1],0],
                             [0,m3_err$6[1],0],
                             [0,m1$6,[0,m2$23,[0,m2_exp$7,[0,b$4,[0,m3$6,0]]]]]];
                          add_proof_step(i$10,10,args$9);
                          var
                           log_v0=[3,11,f$0[2]],
                           _FV_=[0,[0,mk_float_const(m3$6),m3_err$6],0],
                           _FW_=f$0[3];
                          return [0,
                                  i$10,
                                  log_v0,
                                  append
                                   (map$0
                                     (function(param)
                                       {var err=param[2],e=param[1];
                                        return [0,mk_div(e,f$0[2]),err]},
                                      _FW_),
                                    _FV_)];
                         case 12:
                          report(-364068301,_yp_);
                          var
                           x0_int$8=estimate_and_cache(cs,f$0[2]),
                           _FX_=f$0[3],
                           x1$8=caml_call1(abs_eval_v1(cs),_FX_),
                           s1$9=
                            itlist
                             (function(param,s)
                               {var
                                 x_exp=param[2],
                                 x=param[1],
                                 eps=get_eps(x_exp),
                                 xi=[254,- eps,eps];
                                return _gs_(_gv_(xi,x),s)},
                              x1$8,
                              _gl_),
                           m1$7=make_stronger(_gp_(s1$9)[2]),
                           xi$3=
                            proof_flag(0)
                             ?_gs_(x0_int$8,[254,- m1$7,m1$7])
                             :_gs_(x0_int$8,s1$9),
                           d$9=_gW_(xi$3),
                           b_high$9=symbol$3(0.5,_gp_(d$9)[2]),
                           b_high$10=make_stronger(b_high$9),
                           match$11=sum2_high(x1$8,x1$8),
                           m2_exp$8=match$11[2],
                           m2$24=match$11[1],
                           m2$25=make_stronger(m2$24),
                           m3$7=symbol$3(b_high$10,m2$25),
                           form_index$2=next(0),
                           m3_err$7=mk(-1,m2_exp$8),
                           v1_0$3=mk_cosh(f$0[2]),
                           _FY_=[0,[0,mk_float_const(m3$7),m3_err$7],0],
                           _FZ_=f$0[3],
                           _F0_=
                            append
                             (map$0
                               (function(param)
                                 {var err=param[2],e=param[1];
                                  return [0,mk_mul(v1_0$3,e),err]},
                                _FZ_),
                              _FY_);
                          return [0,form_index$2,mk_sinh(f$0[2]),_F0_];
                         case 13:
                          report(-364068301,_yq_);
                          var
                           x0_int$9=estimate_and_cache(cs,f$0[2]),
                           _F1_=f$0[3],
                           x1$9=caml_call1(abs_eval_v1(cs),_F1_),
                           s1$10=
                            itlist
                             (function(param,s)
                               {var
                                 x_exp=param[2],
                                 x=param[1],
                                 eps=get_eps(x_exp),
                                 xi=[254,- eps,eps];
                                return _gs_(_gv_(xi,x),s)},
                              x1$9,
                              _gl_),
                           m1$8=make_stronger(_gp_(s1$10)[2]),
                           xi$4=
                            proof_flag(0)
                             ?_gs_(x0_int$9,[254,- m1$8,m1$8])
                             :_gs_(x0_int$9,s1$10),
                           d$10=_gY_(xi$4),
                           b_high$11=symbol$3(0.5,_gp_(d$10)[2]),
                           b_high$12=make_stronger(b_high$11),
                           match$12=sum2_high(x1$9,x1$9),
                           m2_exp$9=match$12[2],
                           m2$26=match$12[1],
                           m2$27=make_stronger(m2$26),
                           m3$8=symbol$3(b_high$12,m2$27),
                           form_index$3=next(0),
                           m3_err$8=mk(-1,m2_exp$9),
                           v1_0$4=mk_sinh(f$0[2]),
                           _F2_=[0,[0,mk_float_const(m3$8),m3_err$8],0],
                           _F3_=f$0[3],
                           _F4_=
                            append
                             (map$0
                               (function(param)
                                 {var err=param[2],e=param[1];
                                  return [0,mk_mul(v1_0$4,e),err]},
                                _F3_),
                              _F2_);
                          return [0,form_index$3,mk_cosh(f$0[2]),_F4_];
                         case 14:
                          report(-364068301,_yr_);
                          var
                           x0_int$10=estimate_and_cache(cs,f$0[2]),
                           _F5_=f$0[3],
                           x1$10=caml_call1(abs_eval_v1(cs),_F5_),
                           s1$11=
                            itlist
                             (function(param,s)
                               {var
                                 x_exp=param[2],
                                 x=param[1],
                                 eps=get_eps(x_exp),
                                 xi=[254,- eps,eps];
                                return _gs_(_gv_(xi,x),s)},
                              x1$10,
                              _gl_),
                           m1$9=make_stronger(_gp_(s1$11)[2]),
                           xi$5=
                            proof_flag(0)
                             ?_gs_(x0_int$10,[254,- m1$9,m1$9])
                             :_gs_(x0_int$10,s1$11),
                           _F6_=_gC_(_gY_(xi$5),2),
                           d$11=_go_(_gy_(_g0_(xi$5),_F6_)),
                           b_high$13=_gp_(d$11)[2],
                           b_high$14=make_stronger(b_high$13),
                           match$13=sum2_high(x1$10,x1$10),
                           m2_exp$10=match$13[2],
                           m2$28=match$13[1],
                           m2$29=make_stronger(m2$28),
                           m3$9=symbol$3(b_high$14,m2$29),
                           form_index$4=next(0),
                           m3_err$9=mk(-1,m2_exp$10),
                           _F7_=mk_cosh(f$0[2]),
                           v1_0$5=mk_mul(mk_cosh(f$0[2]),_F7_),
                           _F8_=[0,[0,mk_float_const(m3$9),m3_err$9],0],
                           _F9_=f$0[3],
                           _F__=
                            append
                             (map$0
                               (function(param)
                                 {var err=param[2],e=param[1];
                                  return [0,mk_div(e,v1_0$5),err]},
                                _F9_),
                              _F8_);
                          return [0,form_index$4,[3,14,f$0[2]],_F__];
                         case 15:
                          report(-364068301,_ys_);
                          var
                           x0_int$11=estimate_and_cache(cs,f$0[2]),
                           _F$_=f$0[3],
                           x1$11=caml_call1(abs_eval_v1(cs),_F$_),
                           s1$12=
                            itlist
                             (function(param,s)
                               {var
                                 x_exp=param[2],
                                 x=param[1],
                                 eps=get_eps(x_exp),
                                 xi=[254,- eps,eps];
                                return _gs_(_gv_(xi,x),s)},
                              x1$11,
                              _gl_),
                           m1$10=make_stronger(_gp_(s1$12)[2]),
                           xi$6=
                            proof_flag(0)
                             ?_gs_(x0_int$11,[254,- m1$10,m1$10])
                             :_gs_(x0_int$11,s1$12),
                           d$12=_go_(_gy_(xi$6,_gB_(_gC_(_gs_(_gm_,_gC_(xi$6,2)),3)))),
                           b_high$15=symbol$3(0.5,_gp_(d$12)[2]),
                           b_high$16=make_stronger(b_high$15),
                           match$14=sum2_high(x1$11,x1$11),
                           m2_exp$11=match$14[2],
                           m2$30=match$14[1],
                           m2$31=make_stronger(m2$30),
                           m3$10=symbol$3(b_high$16,m2$31),
                           form_index$5=next(0),
                           m3_err$10=mk(-1,m2_exp$11),
                           v1_0$6=mk_sqrt(mk_add(const_1,mk_mul(f$0[2],f$0[2]))),
                           _Ga_=[0,[0,mk_float_const(m3$10),m3_err$10],0],
                           _Gb_=f$0[3],
                           _Gc_=
                            append
                             (map$0
                               (function(param)
                                 {var err=param[2],e=param[1];
                                  return [0,mk_div(e,v1_0$6),err]},
                                _Gb_),
                              _Ga_);
                          return [0,form_index$5,[3,15,f$0[2]],_Gc_];
                         case 16:
                          report(-364068301,_yt_);
                          var
                           x0_int$12=estimate_and_cache(cs,f$0[2]),
                           _Gd_=f$0[3],
                           x1$12=caml_call1(abs_eval_v1(cs),_Gd_),
                           s1$13=
                            itlist
                             (function(param,s)
                               {var
                                 x_exp=param[2],
                                 x=param[1],
                                 eps=get_eps(x_exp),
                                 xi=[254,- eps,eps];
                                return _gs_(_gv_(xi,x),s)},
                              x1$12,
                              _gl_),
                           m1$11=make_stronger(_gp_(s1$13)[2]),
                           xi$7=
                            proof_flag(0)
                             ?_gs_(x0_int$12,[254,- m1$11,m1$11])
                             :_gs_(x0_int$12,s1$13),
                           d$13=_go_(_gy_(xi$7,_gB_(_gC_(_gt_(_gC_(xi$7,2),_gm_),3)))),
                           b_high$17=symbol$3(0.5,_gp_(d$13)[2]),
                           b_high$18=make_stronger(b_high$17),
                           match$15=sum2_high(x1$12,x1$12),
                           m2_exp$12=match$15[2],
                           m2$32=match$15[1],
                           m2$33=make_stronger(m2$32),
                           m3$11=symbol$3(b_high$18,m2$33),
                           form_index$6=next(0),
                           m3_err$11=mk(-1,m2_exp$12),
                           v1_0$7=mk_sqrt(mk_sub(mk_mul(f$0[2],f$0[2]),const_1)),
                           _Ge_=[0,[0,mk_float_const(m3$11),m3_err$11],0],
                           _Gf_=f$0[3],
                           _Gg_=
                            append
                             (map$0
                               (function(param)
                                 {var err=param[2],e=param[1];
                                  return [0,mk_div(e,v1_0$7),err]},
                                _Gf_),
                              _Ge_);
                          return [0,form_index$6,[3,16,f$0[2]],_Gg_];
                         case 17:
                          report(-364068301,_yu_);
                          var
                           x0_int$13=estimate_and_cache(cs,f$0[2]),
                           _Gh_=f$0[3],
                           x1$13=caml_call1(abs_eval_v1(cs),_Gh_),
                           s1$14=
                            itlist
                             (function(param,s)
                               {var
                                 x_exp=param[2],
                                 x=param[1],
                                 eps=get_eps(x_exp),
                                 xi=[254,- eps,eps];
                                return _gs_(_gv_(xi,x),s)},
                              x1$13,
                              _gl_),
                           m1$12=make_stronger(_gp_(s1$14)[2]),
                           xi$8=
                            proof_flag(0)
                             ?_gs_(x0_int$13,[254,- m1$12,m1$12])
                             :_gs_(x0_int$13,s1$14),
                           d$14=_gy_(xi$8,_gC_(_gt_(_gm_,_gC_(xi$8,2)),2)),
                           b_high$19=_gp_(d$14)[2],
                           b_high$20=make_stronger(b_high$19),
                           match$16=sum2_high(x1$13,x1$13),
                           m2_exp$13=match$16[2],
                           m2$34=match$16[1],
                           m2$35=make_stronger(m2$34),
                           m3$12=symbol$3(b_high$20,m2$35),
                           form_index$7=next(0),
                           m3_err$12=mk(-1,m2_exp$13),
                           v1_0$8=mk_sub(const_1,mk_mul(f$0[2],f$0[2])),
                           _Gi_=[0,[0,mk_float_const(m3$12),m3_err$12],0],
                           _Gj_=f$0[3],
                           _Gk_=
                            append
                             (map$0
                               (function(param)
                                 {var err=param[2],e=param[1];
                                  return [0,mk_div(e,v1_0$8),err]},
                                _Gj_),
                              _Gi_);
                          return [0,form_index$7,[3,17,f$0[2]],_Gk_];
                         default:return failwith(symbol(_yC_,u_op_name(op$3)))}
                      case 4:
                       var
                        arg2$1=e$4[3],
                        arg1$1=e$4[2],
                        op$4=e$4[1],
                        f1$0=build(arg1$1),
                        f2$0=build(arg2$1);
                       switch(op$4)
                        {case 0:
                          report(-364068301,_yw_);
                          var
                           i$12=next(0),
                           _Gp_=f1$0[3],
                           match$18=sum_high(caml_call1(abs_eval_v1(cs),_Gp_)),
                           e$0=match$18[2],
                           s$0=match$18[1],
                           t1=make_stronger(symbol$3(get_eps(e$0),s$0)),
                           _Gq_=f2$0[3],
                           match$19=sum_high(caml_call1(abs_eval_v1(cs),_Gq_)),
                           e$1=match$19[2],
                           s$1=match$19[1],
                           t2=make_stronger(symbol$3(get_eps(e$1),s$1)),
                           x_sub_y=mk_sub(f1$0[2],f2$0[2]),
                           t$2=mk_sym_interval_const(symbol$1(t1,t2)),
                           _Gr_=mk_add(const_1,mk_abs_err(t$2,x_sub_y)),
                           err1=mk_mul(mk_float_const(0.5),_Gr_),
                           _Gs_=mk_sub(const_1,mk_abs_err(t$2,x_sub_y)),
                           err2=mk_mul(mk_float_const(0.5),_Gs_),
                           _Gt_=f2$0[3],
                           _Gu_=
                            map$0
                             (function(param)
                               {var err=param[2],e=param[1];return [0,mk_mul(err2,e),err]},
                              _Gt_),
                           _Gv_=f1$0[3],
                           _Gw_=
                            append
                             (map$0
                               (function(param)
                                 {var err=param[2],e=param[1];return [0,mk_mul(err1,e),err]},
                                _Gv_),
                              _Gu_);
                          return [0,i$12,[4,0,f1$0[2],f2$0[2]],_Gw_];
                         case 1:
                          report(-364068301,_yx_);
                          var
                           i$13=next(0),
                           _Gx_=f1$0[3],
                           match$20=sum_high(caml_call1(abs_eval_v1(cs),_Gx_)),
                           e$2=match$20[2],
                           s$2=match$20[1],
                           t1$0=make_stronger(symbol$3(get_eps(e$2),s$2)),
                           _Gy_=f2$0[3],
                           match$21=sum_high(caml_call1(abs_eval_v1(cs),_Gy_)),
                           e$3=match$21[2],
                           s$3=match$21[1],
                           t2$0=make_stronger(symbol$3(get_eps(e$3),s$3)),
                           x_sub_y$0=mk_sub(f1$0[2],f2$0[2]),
                           t$3=mk_sym_interval_const(symbol$1(t1$0,t2$0)),
                           _Gz_=mk_sub(const_1,mk_abs_err(t$3,x_sub_y$0)),
                           err1$0=mk_mul(mk_float_const(0.5),_Gz_),
                           _GA_=mk_add(const_1,mk_abs_err(t$3,x_sub_y$0)),
                           err2$0=mk_mul(mk_float_const(0.5),_GA_),
                           _GB_=f2$0[3],
                           _GC_=
                            map$0
                             (function(param)
                               {var err=param[2],e=param[1];
                                return [0,mk_mul(err2$0,e),err]},
                              _GB_),
                           _GD_=f1$0[3],
                           _GE_=
                            append
                             (map$0
                               (function(param)
                                 {var err=param[2],e=param[1];
                                  return [0,mk_mul(err1$0,e),err]},
                                _GD_),
                              _GC_);
                          return [0,i$13,[4,1,f1$0[2],f2$0[2]],_GE_];
                         case 2:return add_form(f1$0,f2$0);
                         case 3:
                          report(-364068301,_ya_);
                          var i$4=next(0),args$3=[0,[0,f1$0[1],[0,f2$0[1],0]],0,0];
                          add_proof_step(i$4,2,args$3);
                          var
                           _Fm_=f2$0[3],
                           _Fn_=
                            map$0
                             (function(param)
                               {var err=param[2],e=param[1];return [0,mk_neg(e),err]},
                              _Fm_),
                           _Fo_=append(f1$0[3],_Fn_);
                          return [0,i$4,mk_sub(f1$0[2],f2$0[2]),_Fo_];
                         case 4:return mul_form(cs,f1$0,f2$0);
                         case 5:
                          report(-364068301,_yf_);
                          return mul_form(cs,f1$0,inv_form(cs,f2$0));
                         default:return failwith(symbol(_yD_,bin_op_name(op$4)))}
                      default:
                       var
                        args$10=e$4[2],
                        op$5=e$4[1],
                        match$22=map$0(build,args$10);
                       if(0 === op$5 && match$22)
                        {var _GJ_=match$22[2];
                         if(_GJ_)
                          {var _GK_=_GJ_[2];
                           if(_GK_ && ! _GK_[2])
                            {var c$3=_GK_[1],b$5=_GJ_[1],a=match$22[1];
                             return add_form(mul_form(cs,a,b$5),c$3)}}}
                       return failwith(symbol(_yE_,gen_op_name(op$5)))}}
                  return function(e)
                   {cache[1] = 0;
                    err_index[1] = 0;
                    index$0[1] = 0;
                    exprs[1] = 0;
                    counter$0[1] = 0;
                    return build(e)}},
               files=create$0(0,5),
               _yF_=0.,
               _yG_=0,
               _yH_=0,
               _yI_=0,
               _yJ_=0,
               _yK_=0,
               _yL_=0,
               _yM_=[254,upper_bound,f_max],
               open_file=
                function(id,fname)
                 {if(mem$0(files,id))return failwith(symbol(_yO_,id));
                  var oc=open_out(fname);
                  function _ES_(param){return caml_ml_flush(oc)}
                  var
                   fmt=
                    make_formatter
                     (function(_ET_,_EU_,_EV_)
                       {return output_substring(oc,_ET_,_EU_,_EV_)},
                      _ES_);
                  return add(files,id,[0,oc,fmt])},
               close_file=
                function(id)
                 {try
                   {var match=find(files,id),fmt=match[2],oc=match[1];
                    pp_print_flush(fmt,0);
                    close_out(oc);
                    var _EQ_=remove(files,id);
                    return _EQ_}
                  catch(_ER_)
                   {_ER_ = caml_wrap_exception(_ER_);
                    if(_ER_ === Not_found)return 0;
                    throw _ER_}},
               get_fmt=function(id){return find(files,id)[2]},
               get_problem_absolute_error=
                function(result)
                 {var
                   entire=[254,upper_bound,f_max],
                   e1=option_default(entire,result[3]),
                   e2=option_default(entire,result[4]);
                  return min(e1[2],e2[2])},
               print_form=
                function(level,f)
                 {var _EH_=caml_call2(Info[3],0,f[2]);
                  caml_call1(report(level,_y8_),_EH_);
                  var _EI_=f[3];
                  iter$0
                   (function(param)
                     {var
                       err=param[2],
                       e=param[1],
                       _EM_=caml_call2(Info[3],0,e),
                       _EN_=err[3],
                       _EO_=err[1],
                       _EP_=err[2];
                      return caml_call4(report(level,_y9_),_EP_,_EO_,_EN_,_EM_)},
                    _EI_);
                  report(level,_y__);
                  var _EJ_=f[3];
                  return iter$0
                          (function(param)
                            {var err=param[2],i=err[2],_EK_=0 < i?1:0;
                             if(_EK_)
                              {var
                                expr=rev_assoc(i,exprs[1]),
                                _EL_=caml_call2(Info[3],0,expr);
                               return caml_call2(report(level,_y$_),i,_EL_)}
                             return _EK_},
                           _EJ_)},
               bound_info=
                function(bound)
                 {if(upper_bound < bound[1])
                   {var
                     subopt=(bound[2] - bound[1]) / bound[2] * 100.,
                     _ED_=bound[1],
                     _EE_=bound[2];
                    return caml_call3(sprintf$0(_za_),_EE_,_ED_,subopt)}
                  var _EF_=bound[1],_EG_=bound[2];
                  return caml_call2(sprintf$0(_zb_),_EG_,_EF_)},
               add2_symbolic=
                function(param,_EC_)
                 {var exp2=_EC_[2],e2=_EC_[1],exp1=param[2],e1=param[1];
                  if(exp1 <= exp2)
                   var e1$0=e1,exp1$0=exp1,e2$0=e2,exp2$0=exp2;
                  else
                   var e1$0=e2,exp1$0=exp2,e2$0=e1,exp2$0=exp1;
                  if(0 === exp1$0)
                   return 0 === exp2$0?[0,const_0,0]:[0,e2$0,exp2$0];
                  if(0 === exp2$0)return [0,e1$0,exp1$0];
                  if(exp1$0 === exp2$0)return [0,mk_add(e1$0,e2$0),exp1$0];
                  var eps=get_eps(exp1$0 - exp2$0 | 0);
                  return [0,
                          mk_add(mk_mul(mk_float_const(eps),e1$0),e2$0),
                          exp2$0]},
               sum_symbolic=
                function(s){return itlist(add2_symbolic,s,[0,const_0,0])},
               compute_bound=
                function(cs,param)
                 {var
                   err=param[2],
                   expr=param[1],
                   pars=default_opt_pars(0),
                   match=optimize_expr(pars,0,cs,expr),
                   rmax=match[2],
                   rmin=match[1],
                   _Eu_=rmax[2],
                   _Ev_=rmax[1],
                   _Ew_=rmin[2],
                   _Ex_=rmin[1];
                  caml_call4(report(-364068301,_ui_),_Ex_,_Ew_,_Ev_,_Eu_);
                  var
                   r=Math.abs(rmin[1]) <= Math.abs(rmax[1])?rmax:rmin,
                   _Ey_=
                    3 === caml_classify_float(r[2])
                     ?upper_bound
                     :0. <= r[1]?max(0.,r[2]):max(0.,- r[2]),
                   bound=[254,_Ey_,Math.abs(r[1])],
                   _Ez_=bound_info(bound),
                   _EA_=err[3],
                   _EB_=err[2];
                  caml_call3(report(815031438,_zc_),_EB_,_EA_,_Ez_);
                  return [0,bound,err[3]]},
               split_error_terms=
                function(err_terms)
                 {if(err_terms)
                   {var
                     rest=err_terms[2],
                     match=err_terms[1],
                     err=match[2],
                     e=match[1],
                     match$0=split_error_terms(rest),
                     es2=match$0[2],
                     es1=match$0[1];
                    return 0 <= err[2]
                            ?[0,[0,[0,e,err],es1],es2]
                            :[0,es1,[0,[0,e,err],es2]]}
                  return _zd_},
               sum_err_bounds=
                function(bounds)
                 {var
                   high=
                    map$0
                     (function(param)
                       {var exp=param[2],v=param[1];return [0,v[2],exp]},
                      bounds),
                   low=
                    map$0
                     (function(param)
                       {var exp=param[2],v=param[1];return [0,- v[1],exp]},
                      bounds),
                   match=sum_high(high),
                   exp=match[2],
                   s_high=match[1],
                   match$0=sum_high(low),
                   e=match$0[2],
                   s=match$0[1],
                   s_low=- s;
                  if(exp === e)
                   {var eps=get_eps(exp);return _gx_(eps,[254,s_low,s_high])}
                  throw [0,Assert_failure,_ze_]},
               error2_warning=
                function(opt,err1,err2)
                 {if(opt)var sth=opt[1],eps=sth;else var eps=0.01;
                  var
                   _Es_=0. < Math.abs(err1)?1:0,
                   _Et_=_Es_?eps * Math.abs(err1) <= Math.abs(err2)?1:0:_Es_;
                  return _Et_
                          ?(caml_call2(warning(_zf_),err2,err1),warning(_zg_))
                          :_Et_},
               absolute_errors=
                function(task,tf)
                 {report(83322498,_zh_);
                  var
                   cs=constraints_of_task(task),
                   match=split_error_terms(tf[3]),
                   v2=match[2],
                   v1=match[1],
                   bounds2=
                    map$0(function(_Er_){return compute_bound(cs,_Er_)},v2),
                   bounds2$0=
                    map$0
                     (function(param)
                       {var exp=param[2],e=param[1];
                        return [0,make_stronger_i(e),exp]},
                      bounds2),
                   total2_i=sum_err_bounds(bounds2$0);
                  if(get_bool_option(_zi_))
                   {report(83322498,_zj_);
                    report(83322498,_zk_);
                    var
                     bounds1=
                      map$0(function(_Eq_){return compute_bound(cs,_Eq_)},v1),
                     bounds1$0=
                      map$0
                       (function(param)
                         {var exp=param[2],e=param[1];
                          return [0,make_stronger_i(e),exp]},
                        bounds1),
                     total1_i=sum_err_bounds(bounds1$0),
                     total_i=make_stronger_i(_gs_(total1_i,total2_i)),
                     _Eb_=
                      map$0(function(param){var v=param[1];return v[2]},bounds2$0),
                     all_bounds=
                      append
                       (map$0
                         (function(param){var v=param[1];return v[2]},bounds1$0),
                        _Eb_),
                     _Ec_=
                      map$0(function(param){var err=param[2];return err[1]},v2),
                     all_indices=
                      append
                       (map$0(function(param){var err=param[2];return err[1]},v1),
                        _Ec_);
                    add_opt_approx(all_indices,all_bounds,total_i[2]);
                    var _Ed_=bound_info(total1_i);
                    caml_call1(report(83322498,_zl_),_Ed_);
                    var _Ee_=bound_info(total2_i);
                    caml_call1(report(83322498,_zm_),_Ee_);
                    var _Ef_=bound_info(total_i);
                    caml_call1(report(83322498,_zn_),_Ef_);
                    error2_warning(0,total1_i[2],total2_i[2]);
                    var err_approx=[0,total_i]}
                  else
                   var err_approx=0;
                  if(get_bool_option(_zo_))
                   {report(83322498,_zp_);
                    var
                     abs_exprs=
                      map$0
                       (function(param)
                         {var err=param[2],e=param[1],_Ep_=err[3];
                          return [0,mk_abs(e),_Ep_]},
                        v1),
                     match$0=sum_symbolic(abs_exprs),
                     exp=match$0[2],
                     full_expr=match$0[1],
                     full_expr$0=
                      get_bool_option(_zq_)?simplify(task,full_expr):full_expr,
                     r=find_max(default_opt_pars(0),cs,full_expr$0),
                     bound=[254,r[2],r[1]],
                     total1_i$0=_gx_(get_eps(exp),bound);
                    if(proof_flag(0))
                     {var
                       e=get_eps(exp),
                       e$0=e == 0.?1.:e,
                       bound$0=make_stronger_i(_gs_(bound,_gz_(total2_i,e$0))),
                       total_i$0=_gx_(e$0,bound$0);
                      add_opt_exact(bound$0[2],exp,total_i$0[2]);
                      var total_i$1=total_i$0}
                    else
                     var total_i$1=_gs_(total1_i$0,total2_i);
                    try
                     {var
                       _Ej_=mk_float_const(total2_i[2]),
                       out_expr=
                        mk_add
                         (mk_mul(mk_float_const(get_eps(exp)),full_expr$0),_Ej_),
                       name=task[1],
                       _Ek_=mk_float_const(total_i$1[2]),
                       _El_=[0,[0,symbol(name,_zu_),_Ek_],0],
                       _Em_=mk_float_const(total2_i[2]),
                       _En_=
                        [0,[0,name,out_expr],[0,[0,symbol(name,_zv_),_Em_],_El_]];
                      generate_data_functions(get_fmt(_zw_),task,_En_)}
                    catch(_Eo_)
                     {_Eo_ = caml_wrap_exception(_Eo_);
                      if(_Eo_ !== Not_found)throw _Eo_}
                    var _Eg_=bound_info(bound);
                    caml_call2(report(83322498,_zr_),exp,_Eg_);
                    var _Eh_=bound_info(total2_i);
                    caml_call1(report(83322498,_zs_),_Eh_);
                    var _Ei_=bound_info(total_i$1);
                    caml_call1(report(83322498,_zt_),_Ei_);
                    error2_warning(0,total1_i$0[2],total2_i[2]);
                    var err_exact=[0,total_i$1]}
                  else
                   var err_exact=0;
                  return [0,err_approx,err_exact]},
               relative_errors=
                function(task,tf,param)
                 {var f_max=param[2],f_min=param[1];
                  report(83322498,_zx_);
                  var
                   cs=constraints_of_task(task),
                   f_int=[254,f_min,f_max],
                   rel_tol=get_float_option(_zy_);
                  if(_gp_(f_int)[1] < rel_tol){warning(_zz_);return _zA_}
                  var
                   match=split_error_terms(tf[3]),
                   v2=match[2],
                   v1=match[1],
                   bounds2=
                    map$0(function(_Ea_){return compute_bound(cs,_Ea_)},v2),
                   total2_i=sum_err_bounds(bounds2),
                   b2_i=_gy_(total2_i,_gp_(f_int));
                  if(get_bool_option(_zB_))
                   {var
                     v1_rel=
                      map$0
                       (function(param)
                         {var err=param[2],e=param[1];return [0,mk_div(e,tf[2]),err]},
                        v1),
                     v1_rel$0=
                      get_bool_option(_zC_)
                       ?map$0
                         (function(param)
                           {var err=param[2],e=param[1];
                            return [0,simplify(task,e),err]},
                          v1_rel)
                       :v1_rel;
                    report(83322498,_zD_);
                    report(83322498,_zE_);
                    var
                     bounds1=
                      map$0
                       (function(_D$_){return compute_bound(cs,_D$_)},v1_rel$0),
                     total1_i=sum_err_bounds(bounds1),
                     total_i=_gs_(total1_i,b2_i),
                     _DY_=bound_info(total1_i);
                    caml_call1(report(83322498,_zF_),_DY_);
                    var _DZ_=bound_info(b2_i);
                    caml_call1(report(83322498,_zG_),_DZ_);
                    var _D0_=bound_info(total_i);
                    caml_call1(report(83322498,_zH_),_D0_);
                    error2_warning(0,total1_i[2],b2_i[2]);
                    var err_approx=[0,total_i]}
                  else
                   var err_approx=0;
                  if(get_bool_option(_zI_))
                   {report(83322498,_zJ_);
                    var
                     abs_exprs=
                      map$0
                       (function(param)
                         {var err=param[2],e=param[1],_D__=err[3];
                          return [0,mk_abs(e),_D__]},
                        v1),
                     match$0=sum_symbolic(abs_exprs),
                     exp=match$0[2],
                     sum_expr=match$0[1],
                     full_expr=mk_div(sum_expr,mk_abs(tf[2])),
                     full_expr$0=
                      get_bool_option(_zK_)?simplify(task,full_expr):full_expr,
                     r=find_max(default_opt_pars(0),cs,full_expr$0),
                     bound=[254,r[2],r[1]],
                     total1_i$0=_gx_(get_eps(exp),bound),
                     total_i$0=_gs_(total1_i$0,b2_i);
                    try
                     {var
                       _D4_=mk_float_const(b2_i[2]),
                       out_expr=
                        mk_add
                         (mk_mul(mk_float_const(get_eps(exp)),full_expr$0),_D4_),
                       name=task[1],
                       _D5_=mk_float_const(total_i$0[2]),
                       _D6_=[0,[0,symbol(name,_zO_),_D5_],0],
                       _D7_=mk_float_const(b2_i[2]),
                       _D8_=
                        [0,[0,name,out_expr],[0,[0,symbol(name,_zP_),_D7_],_D6_]];
                      generate_data_functions(get_fmt(_zQ_),task,_D8_)}
                    catch(_D9_)
                     {_D9_ = caml_wrap_exception(_D9_);
                      if(_D9_ !== Not_found)throw _D9_}
                    var _D1_=bound_info(bound);
                    caml_call2(report(83322498,_zL_),exp,_D1_);
                    var _D2_=bound_info(b2_i);
                    caml_call1(report(83322498,_zM_),_D2_);
                    var _D3_=bound_info(total_i$0);
                    caml_call1(report(83322498,_zN_),_D3_);
                    error2_warning(0,total1_i$0[2],b2_i[2]);
                    var err_exact=[0,total_i$0]}
                  else
                   var err_exact=0;
                  return [0,err_approx,err_exact]},
               ulp_errors=
                function(task,tf,param)
                 {var f_max=param[2],f_min=param[1];
                  report(83322498,_zR_);
                  var
                   cs=constraints_of_task(task),
                   _DH_=task[2],
                   t=
                    get_type
                     (function(_DX_){return variable_type(task,_DX_)},_DH_),
                   prec=type_precision(t);
                  if(prec <= 0)failwith(caml_call1(sprintf$0(_zS_),prec));
                  var min_exp=type_min_exp(t);
                  caml_call2(report(83322498,_zT_),prec,min_exp);
                  var
                   f_int=
                    goldberg_ulp_I([0,prec,min_exp],[254,f_min,f_max]);
                  if(_gp_(f_int)[1] <= 0.){warning(_zU_);return _zV_}
                  var
                   match=split_error_terms(tf[3]),
                   v2=match[2],
                   v1=match[1],
                   bounds2=
                    map$0(function(_DW_){return compute_bound(cs,_DW_)},v2),
                   total2_i=sum_err_bounds(bounds2),
                   b2_i=_gy_(total2_i,_gp_(f_int));
                  if(get_bool_option(_zW_))
                   {var
                     v1_rel=
                      map$0
                       (function(param)
                         {var err=param[2],e=param[1];
                          return [0,mk_div(e,mk_ulp([0,prec,min_exp],tf[2])),err]},
                        v1);
                    report(83322498,_zX_);
                    report(83322498,_zY_);
                    var
                     bounds1=
                      map$0(function(_DV_){return compute_bound(cs,_DV_)},v1_rel),
                     total1_i=sum_err_bounds(bounds1),
                     total_i=_gs_(total1_i,b2_i),
                     _DI_=bound_info(total1_i);
                    caml_call1(report(83322498,_zZ_),_DI_);
                    var _DJ_=bound_info(b2_i);
                    caml_call1(report(83322498,_z0_),_DJ_);
                    var _DK_=bound_info(total_i);
                    caml_call1(report(83322498,_z1_),_DK_);
                    error2_warning(0,total1_i[2],b2_i[2]);
                    var err_approx=[0,total_i]}
                  else
                   var err_approx=0;
                  if(get_bool_option(_z2_))
                   {report(83322498,_z3_);
                    var
                     abs_exprs=
                      map$0
                       (function(param)
                         {var err=param[2],e=param[1],_DU_=err[3];
                          return [0,mk_abs(e),_DU_]},
                        v1),
                     match$0=sum_symbolic(abs_exprs),
                     exp=match$0[2],
                     sum_expr=match$0[1],
                     full_expr=
                      mk_div(sum_expr,mk_abs(mk_ulp([0,prec,min_exp],tf[2]))),
                     r=find_max(default_opt_pars(0),cs,full_expr),
                     bound=[254,r[2],r[1]],
                     total1_i$0=_gx_(get_eps(exp),bound),
                     total_i$0=_gs_(total1_i$0,b2_i);
                    try
                     {var
                       _DO_=mk_float_const(b2_i[2]),
                       out_expr=
                        mk_add(mk_mul(mk_float_const(get_eps(exp)),full_expr),_DO_),
                       name=task[1],
                       _DP_=mk_float_const(total_i$0[2]),
                       _DQ_=[0,[0,symbol(name,_z7_),_DP_],0],
                       _DR_=mk_float_const(b2_i[2]),
                       _DS_=
                        [0,[0,name,out_expr],[0,[0,symbol(name,_z8_),_DR_],_DQ_]];
                      generate_data_functions(get_fmt(_z9_),task,_DS_)}
                    catch(_DT_)
                     {_DT_ = caml_wrap_exception(_DT_);
                      if(_DT_ !== Not_found)throw _DT_}
                    var _DL_=bound_info(bound);
                    caml_call2(report(83322498,_z4_),exp,_DL_);
                    var _DM_=bound_info(b2_i);
                    caml_call1(report(83322498,_z5_),_DM_);
                    var _DN_=bound_info(total_i$0);
                    caml_call1(report(83322498,_z6_),_DN_);
                    error2_warning(0,total1_i$0[2],b2_i[2]);
                    var err_exact=[0,total_i$0]}
                  else
                   var err_exact=0;
                  return [0,err_approx,err_exact]},
               errors=
                function(task,tform)
                 {var cs=constraints_of_task(task),switch$0=0;
                  if
                   (!
                    get_bool_option(_z__)
                    &&
                    !
                    get_bool_option(_Ag_)
                    &&
                    !
                    get_bool_option(_Ah_))
                   {var f_min=upper_bound,f_max$0=f_max;switch$0 = 1}
                  if(! switch$0)
                   var
                    _DC_=tform[2],
                    _DD_=find_min_max(default_opt_pars(0),cs,_DC_),
                    f_min=_DD_[1],
                    f_max$0=_DD_[2];
                  caml_call2(report(83322498,_z$_),f_min,f_max$0);
                  var
                   result=
                    [0,
                     _yN_,
                     [254,f_min,f_max$0],
                     _yL_,
                     _yK_,
                     _yJ_,
                     _yI_,
                     _yH_,
                     _yG_,
                     _yF_],
                   switch$1=0;
                  if(! get_bool_option(_Aa_) && ! get_bool_option(_Af_))
                   {var result$0=result;switch$1 = 1}
                  if(! switch$1)
                   {if(get_bool_option(_Ab_))
                     var
                      _DE_=absolute_errors(task,tform),
                      abs_approx=_DE_[1],
                      abs_exact=_DE_[2];
                    else
                     var abs_approx=0,abs_exact=0;
                    if(get_bool_option(_Ac_))
                     var
                      _DF_=relative_errors(task,tform,[0,f_min,f_max$0]),
                      rel_approx=_DF_[1],
                      rel_exact=_DF_[2];
                    else
                     var rel_approx=0,rel_exact=0;
                    if(get_bool_option(_Ad_))
                     var
                      _DG_=ulp_errors(task,tform,[0,f_min,f_max$0]),
                      ulp_approx=_DG_[1],
                      ulp_exact=_DG_[2];
                    else
                     var ulp_approx=0,ulp_exact=0;
                    var
                     result$0=
                      [0,
                       result[1],
                       result[2],
                       abs_approx,
                       abs_exact,
                       rel_approx,
                       rel_exact,
                       ulp_approx,
                       ulp_exact,
                       result[9]]}
                  report(83322498,_Ae_);
                  return result$0},
               compute_form=
                function(task)
                 {report(815031438,_Aj_);
                  var _Dq_=caml_call2(Info[3],0,task[2]);
                  caml_call1(report(815031438,_Ak_),_Dq_);
                  if(proof_flag(0))new_proof(task);
                  var start=unix_gettimeofday(0);
                  try
                   {try
                     {var
                       _Do_=task[2],
                       _Dp_=
                        caml_call1
                         (check_expr
                           (function(_DB_){return variable_interval(task,_DB_)}),
                          _Do_),
                       bound0=_Dp_}
                    catch(exn)
                     {exn = caml_wrap_exception(exn);
                      if(exn[1] !== Exceptional_operation)throw exn;
                      var
                       str=exn[3],
                       e0=exn[2],
                       _Dn_=caml_call2(Info[3],0,e0),
                       msg=caml_call2(sprintf$0(_Ai_),str,_Dn_),
                       bound0=
                        fail_on_exception(0)?failwith(msg):(warning_str(msg),_gl_)}
                    var _Ds_=_gJ_(_Ap_,bound0);
                    caml_call1(report(815031438,_Aq_),_Ds_);
                    var
                     _Dt_=task[2],
                     e=
                      caml_call1
                       (simplify_rounding
                         (function(_DA_){return variable_type(task,_DA_)}),
                        _Dt_),
                     _Du_=caml_call2(Info[3],0,e);
                    caml_call1(report(815031438,_Ar_),_Du_);
                    var cs=constraints_of_task(task);
                    report(83322498,_As_);
                    var form=caml_call1(build_form(cs),e);
                    report(83322498,_At_);
                    var form$0=simplify_form(cs,form);
                    report(83322498,_Au_);
                    if(get_bool_option(_Av_))
                     var
                      _Dv_=form$0[3],
                      _Dw_=
                       map$0
                        (function(param)
                          {var
                            err=param[2],
                            e=param[1],
                            _Dz_=0 <= err[2]?simplify(task,e):e;
                           return [0,_Dz_,err]},
                         _Dv_),
                      _Dx_=simplify(task,form$0[2]),
                      form$1=[0,form$0[1],_Dx_,_Dw_];
                    else
                     var form$1=form$0;
                    print_form(815031438,form$1);
                    report(815031438,_Aw_);
                    var
                     result$0=errors(task,form$1),
                     _Dy_=
                      [0,
                       task[1],
                       result$0[2],
                       result$0[3],
                       result$0[4],
                       result$0[5],
                       result$0[6],
                       result$0[7],
                       result$0[8],
                       result$0[9]],
                     result=_Dy_,
                     tform=form$1}
                  catch(exn)
                   {exn = caml_wrap_exception(exn);
                    if(exn[1] !== Failure)throw exn;
                    var msg$0=exn[2];
                    error_str(msg$0);
                    var
                     result=[0,task[1],_yM_,_yL_,_yK_,_yJ_,_yI_,_yH_,_yG_,_yF_],
                     tform=dummy_tform}
                  var stop=unix_gettimeofday(0);
                  caml_call1(report(815031438,_Al_),stop - start);
                  if(proof_flag(0))
                   {var proof_dir=get_string_option(_Am_),_Dr_=result[1];
                    caml_call2(report(83322498,_An_),_Dr_,proof_dir);
                    save_proof(proof_dir,symbol(result[1],_Ao_))}
                  return [0,
                          [0,
                           result[1],
                           result[2],
                           result[3],
                           result[4],
                           result[5],
                           result[6],
                           result[7],
                           result[8],
                           stop - start],
                          tform]},
               process_task=
                function(task)
                 {var _Da_=task[1];
                  caml_call1(report(858743897,_AA_),_Da_);
                  if(0 === task[4])
                   var approx_constraints=0;
                  else
                   {report(83322498,_AP_);
                    var
                     _Dd_=task[4],
                     approx_constraints=
                      map$0
                       (function(param)
                         {var c=param[2],name=param[1];
                          switch(c[0])
                           {case 0:var b=c[2],a=c[1],e=mk_sub(a,b);break;
                            case 1:var b$0=c[2],a$0=c[1],e=mk_sub(a$0,b$0);break;
                            default:var e=failwith(_Az_)}
                          var c_task=[0,name,e,task[3],0];
                          report(83322498,_Ax_);
                          var
                           match=compute_form(c_task),
                           tform=match[2],
                           r=match[1],
                           err=get_problem_absolute_error(r),
                           _Dl_=r[1];
                          caml_call2(report(83322498,_Ay_),_Dl_,err);
                          var _Dm_=mk_float_const(err);
                          return [0,name,[0,tform[2],_Dm_]]},
                        _Dd_)}
                  var data_export=get_string_option(_AB_);
                  if(caml_string_notequal(data_export,_AC_))
                   {var
                     _Db_=task[1],
                     fname=global_replace(regexp(_AD_),_Db_,data_export);
                    caml_call1(report(83322498,_AE_),fname);
                    open_file(_AF_,fname)}
                  var error_bounds=get_string_option(_AG_);
                  if(caml_string_notequal(error_bounds,_AH_))
                   {var
                     _Dc_=task[1],
                     fname$0=global_replace(regexp(_AI_),_Dc_,error_bounds);
                    caml_call1(report(83322498,_AJ_),fname$0);
                    open_file(_AK_,fname$0);
                    var
                     fmt=get_fmt(_AL_),
                     vars=all_active_variables(task),
                     bounds=
                      map$0
                       (function(_Dk_){return variable_interval(task,_Dk_)},vars);
                    if(vars)
                     var task_vars$0=vars,var_bounds=bounds;
                    else
                     var
                      names=all_variables(task),
                      _C$_=
                       0 === names?_xg_:[0,variable_interval(task,hd(names)),0],
                      task_vars$0=task_vars,
                      var_bounds=_C$_;
                    var
                     var_names=
                      map$0
                       (function(s){return symbol(_wZ_,fix_name(s))},task_vars$0),
                     env=mk_env(zip(task_vars$0,var_names)),
                     expr=remove_rnd(task[2]);
                    caml_call1(fprintf$0(fmt),_w0_);
                    caml_call1(fprintf$0(fmt),_w1_);
                    pp_print_newline(fmt,0);
                    print_init_f_and_mps(env,fmt,_w4_,_w3_,_w2_,[0,expr,0]);
                    caml_call1(fprintf$0(fmt),_w5_);
                    caml_call1(fprintf$0(fmt),_w6_);
                    pp_print_newline(fmt,0);
                    print_init_f_and_mps(env,fmt,_w9_,_w8_,_w7_,[0,expr,0]);
                    caml_call1(fprintf$0(fmt),_w__);
                    pp_print_newline(fmt,0);
                    var
                     low_str=
                      map$0
                       (function(b)
                         {var _Dj_=b[1];return caml_call1(sprintf$0(_w$_),_Dj_)},
                        var_bounds),
                     high_str=
                      map$0
                       (function(b)
                         {var _Di_=b[2];return caml_call1(sprintf$0(_xa_),_Di_)},
                        var_bounds),
                     _C8_=function(_Dh_){return print_list$0(_xb_,_Dh_)};
                    caml_call3(fprintf$0(fmt),_xc_,_C8_,low_str);
                    var _C9_=function(_Dg_){return print_list$0(_xd_,_Dg_)};
                    caml_call3(fprintf$0(fmt),_xe_,_C9_,high_str);
                    var _C__=task[1];
                    caml_call2(fprintf$0(fmt),_xf_,_C__);
                    pp_print_newline(fmt,0);
                    clear_exprs(env);
                    var
                     _C4_=env[1],
                     args=
                      map$0
                       (function(param){var name=param[2];return symbol(_wQ_,name)},
                        _C4_),
                     translate=
                      function(fmt,expr)
                       {var
                         match=get_expr_name(env,_vD_,expr),
                         found_flag=match[2],
                         name=match[1];
                        if(found_flag)return name;
                        switch(expr[0])
                         {case 3:
                           var arg=expr[2],op=expr[1],arg_name=translate(fmt,arg);
                           switch(op)
                            {case 0:caml_call3(fprintf$0(fmt),_vF_,name,arg_name);break;
                             case 1:caml_call3(fprintf$0(fmt),_vG_,name,arg_name);break;
                             case 2:caml_call3(fprintf$0(fmt),_vH_,name,arg_name);break;
                             case 3:caml_call3(fprintf$0(fmt),_vI_,name,arg_name);break;
                             case 4:caml_call3(fprintf$0(fmt),_vJ_,name,arg_name);break;
                             case 5:caml_call3(fprintf$0(fmt),_vK_,name,arg_name);break;
                             case 10:caml_call3(fprintf$0(fmt),_vM_,name,arg_name);break;
                             case 11:caml_call3(fprintf$0(fmt),_vN_,name,arg_name);break;
                             default:failwith(symbol(_vL_,u_op_name(op)))}
                           break;
                          case 4:
                           var
                            arg2=expr[3],
                            arg1=expr[2],
                            op$0=expr[1],
                            a1=translate(fmt,arg1),
                            a2=translate(fmt,arg2);
                           switch(op$0)
                            {case 0:caml_call4(fprintf$0(fmt),_vO_,name,a1,a2);break;
                             case 1:caml_call4(fprintf$0(fmt),_vP_,name,a1,a2);break;
                             case 2:caml_call4(fprintf$0(fmt),_vQ_,name,a1,a2);break;
                             case 3:caml_call4(fprintf$0(fmt),_vR_,name,a1,a2);break;
                             case 4:caml_call4(fprintf$0(fmt),_vS_,name,a1,a2);break;
                             case 5:caml_call4(fprintf$0(fmt),_vT_,name,a1,a2);break;
                             default:failwith(symbol(_vU_,bin_op_name(op$0)))}
                           break;
                          default:failwith(_vE_)}
                        return name},
                     match=write_to_string_result(translate,expr),
                     result_name=match[2],
                     body=match[1],
                     _C5_=function(_Df_){return print_list$0(_wR_,_Df_)};
                    caml_call3(fprintf$0(fmt),_wS_,_C5_,args);
                    caml_call3(fprintf$0(fmt),_wT_,body,result_name);
                    pp_print_newline(fmt,0);
                    clear_exprs(env);
                    var
                     _C6_=env[1],
                     args$0=
                      map$0
                       (function(param){var name=param[2];return symbol(_wU_,name)},
                        _C6_),
                     translate$0=
                      function(fmt,expr)
                       {var
                         match=get_expr_name(env,_vV_,expr),
                         found_flag=match[2],
                         name=match[1];
                        if(found_flag)return name;
                        switch(expr[0])
                         {case 3:
                           var arg=expr[2],op=expr[1],arg_name=translate$0(fmt,arg);
                           switch(op)
                            {case 0:caml_call3(fprintf$0(fmt),_vX_,name,arg_name);break;
                             case 1:caml_call3(fprintf$0(fmt),_vY_,name,arg_name);break;
                             case 2:caml_call3(fprintf$0(fmt),_vZ_,name,arg_name);break;
                             case 3:caml_call3(fprintf$0(fmt),_v0_,name,arg_name);break;
                             case 4:caml_call3(fprintf$0(fmt),_v1_,name,arg_name);break;
                             case 5:caml_call3(fprintf$0(fmt),_v2_,name,arg_name);break;
                             case 10:caml_call3(fprintf$0(fmt),_v4_,name,arg_name);break;
                             case 11:caml_call3(fprintf$0(fmt),_v5_,name,arg_name);break;
                             default:failwith(symbol(_v3_,u_op_name(op)))}
                           break;
                          case 4:
                           var
                            arg2=expr[3],
                            arg1=expr[2],
                            op$0=expr[1],
                            a1=translate$0(fmt,arg1),
                            a2=translate$0(fmt,arg2);
                           switch(op$0)
                            {case 0:caml_call4(fprintf$0(fmt),_v6_,name,a1,a2);break;
                             case 1:caml_call4(fprintf$0(fmt),_v7_,name,a1,a2);break;
                             case 2:caml_call4(fprintf$0(fmt),_v8_,name,a1,a2);break;
                             case 3:caml_call4(fprintf$0(fmt),_v9_,name,a1,a2);break;
                             case 4:caml_call4(fprintf$0(fmt),_v__,name,a1,a2);break;
                             case 5:caml_call4(fprintf$0(fmt),_v$_,name,a1,a2);break;
                             default:failwith(symbol(_wa_,bin_op_name(op$0)))}
                           break;
                          default:failwith(_vW_)}
                        return name},
                     match$0=write_to_string_result(translate$0,expr),
                     result_name$0=match$0[2],
                     body$0=match$0[1],
                     _C7_=function(_De_){return print_list$0(_wV_,_De_)};
                    caml_call3(fprintf$0(fmt),_wW_,_C7_,args$0);
                    caml_call3(fprintf$0(fmt),_wX_,body$0,result_name$0);
                    close_file(_AM_)}
                  var
                   result=
                    compute_form([0,task[1],task[2],task[3],approx_constraints]);
                  close_file(_AN_);
                  close_file(_AO_);
                  return result},
               fptaylor=
                function(input_files)
                 {if(is_option_defined(_A7_))
                   open_file(_A9_,get_string_option(_A8_));
                  if(is_option_defined(_A__))
                   {var out_name=get_string_option(_A$_);
                    if(caml_string_notequal(out_name,_Ba_))
                     {caml_call1(report(83322498,_Bb_),out_name);
                      open_file(_Bc_,out_name);
                      var
                       fmt=get_fmt(_Bd_),
                       print=
                        function(param)
                         {var
                           value=param[2],
                           name=param[1],
                           _C3_=caml_string_notequal(name,_hL_);
                          return _C3_?caml_call3(fprintf$0(fmt),_hM_,name,value):_C3_},
                       _Cn_=0;
                      iter$0
                       (print,
                        stable_sort
                         (caml_compare,
                          fold
                           (function(name,value,lst){return [0,[0,name,value],lst]},
                            param_table,
                            _Cn_)));
                      close_file(_Be_)}}
                  report(858743897,_Bf_);
                  var
                   _Co_=0,
                   _Cp_=
                    fold_left
                     (function(rs,fname$0)
                       {caml_call1(report(858743897,_AQ_),fname$0);
                        var
                         time=unix_localtime(unix_time(0)),
                         _Cv_=time[1],
                         _Cw_=time[2],
                         _Cx_=time[3],
                         _Cy_=time[4],
                         _Cz_=time[5] + 1 | 0,
                         _CA_=time[6] + 1900 | 0,
                         date_str=
                          caml_call6(sprintf$0(_AR_),_CA_,_Cz_,_Cy_,_Cx_,_Cw_,_Cv_),
                         log_dir=get_string_option(_AS_),
                         base_name=basename$2(fname$0),
                         match=get_string_option(_AT_),
                         name=
                          caml_string_notequal(match,_AU_)
                           ?caml_string_notequal(match,_AV_)
                             ?base_name
                             :symbol(date_str,symbol(_A5_,base_name))
                           :symbol(base_name,symbol(_A6_,date_str)),
                         log_name=symbol(name,_AW_);
                        open_log([0,log_dir],log_name);
                        var
                         tmp_base_dir=get_string_option(_AX_),
                         tmp_dir$0=
                          get_bool_option(_AY_)?cc(tmp_base_dir,date_str):tmp_base_dir;
                        tmp_dir[1] = get_dir(tmp_dir$0);
                        var level=-364068301;
                        function print(name,value)
                         {return caml_call2(report(level,_hN_),name,value)}
                        var _Cs_=base_dir_ref[1];
                        caml_call1(report(level,_hO_),_Cs_);
                        var _Ct_=loaded_cfg_files[1];
                        iter$0(report(level,_hP_),_Ct_);
                        iter$1(print,param_table);
                        var
                         lines=load_file(fname$0),
                         str=concat(_q2_,lines),
                         opt=[0,fname$0],
                         fname=opt?fname$0:_q1_;
                        reset$0(0);
                        var lexbuf=from_string(str),_Cu_=lexbuf[12];
                        lexbuf[12] = [0,fname,_Cu_[2],_Cu_[3],_Cu_[4]];
                        var
                         tasks$0=parse_with_errors(lexbuf,tasks),
                         _CB_=length(tasks$0);
                        caml_call1(report(-364068301,_AZ_),_CB_);
                        if(is_option_defined(_A0_))
                         {report(858743897,_A1_);
                          var fmt=get_fmt(_A2_);
                          iter$0
                           (function(task)
                             {var
                               var_names=all_variables(task),
                               _CD_=task[2],
                               table=create$0(0,10);
                              function incr(bits)
                               {try
                                 {var _CO_=find(table,bits),v=_CO_}
                                catch(_CP_)
                                 {_CP_ = caml_wrap_exception(_CP_);
                                  if(_CP_ !== Not_found)throw _CP_;
                                  var v=0}
                                return replace(table,bits,v + 1 | 0)}
                              function count(param)
                               {var param$0=param;
                                for(;;)
                                 switch(param$0[0])
                                  {case 0:return 0;
                                   case 1:return 0;
                                   case 2:
                                    var param$1=param$0[2],rnd=param$0[1];
                                    incr(rnd[5][1]);
                                    var param$0=param$1;
                                    continue;
                                   case 3:var param$2=param$0[2],param$0=param$2;continue;
                                   case 4:
                                    var param$3=param$0[3],arg1=param$0[2];
                                    count(arg1);
                                    var param$0=param$3;
                                    continue;
                                   default:var args=param$0[2];return iter$0(count,args)}}
                              count(_CD_);
                              var
                               _CC_=[0,max_int,0],
                               match$0=
                                fold
                                 (function(bits,v,r)
                                   {var v_max=r[2];return v_max <= v?[0,bits,v]:r},
                                  table,
                                  _CC_),
                               bits=match$0[1],
                               rnd=create_rounding(bits,_uM_,1.),
                               match=rounding_to_string(rnd),
                               prec=
                                caml_string_notequal(match,_uD_)
                                 ?caml_string_notequal(match,_uE_)
                                   ?caml_string_notequal(match,_uF_)
                                     ?caml_string_notequal(match,_uG_)?_uH_:_uI_
                                     :_uJ_
                                   :_uK_
                                 :_uL_,
                               prec_rnd=
                                caml_string_equal(prec,_uQ_)
                                 ?create_rounding(max_int,_uR_,1.)
                                 :rnd;
                              function _CE_(fmt)
                               {function _CL_(_CN_){return sep(fmt,_uS_,_CN_)}
                                return print_list
                                        (function(_CM_){return pp_print_string(fmt,_CM_)},_CL_)}
                              caml_call3(fprintf$0(fmt),_uT_,_CE_,var_names);
                              var _CF_=escaped(task[1]);
                              caml_call2(fprintf$0(fmt),_uU_,_CF_);
                              caml_call1(fprintf$0(fmt),_uV_);
                              caml_call2(fprintf$0(fmt),_uW_,prec);
                              if(0 === task[4])
                               {if(0 !== all_variables(task))
                                 caml_call3(fprintf$0(fmt),_uY_,var_bounds_to_pre,task)}
                              else
                               caml_call5
                                (fprintf$0(fmt),
                                 _uZ_,
                                 var_bounds_to_pre,
                                 task,
                                 constraints_to_pre,
                                 task);
                              var _CG_=task[2];
                              function remove(expr)
                               {var expr$0=expr;
                                for(;;)
                                 switch(expr$0[0])
                                  {case 0:return expr$0;
                                   case 1:return expr$0;
                                   case 2:
                                    var
                                     arg=expr$0[2],
                                     rnd=expr$0[1],
                                     _CI_=caml_equal(prec_rnd[5],rnd[5]),
                                     _CJ_=_CI_?prec_rnd[6] === rnd[6]?1:0:_CI_;
                                    if(_CJ_){var expr$0=arg;continue}
                                    return [2,rnd,remove(arg)];
                                   case 3:
                                    var arg$0=expr$0[2],op=expr$0[1];
                                    return [3,op,remove(arg$0)];
                                   case 4:
                                    var
                                     arg2=expr$0[3],
                                     arg1=expr$0[2],
                                     op$0=expr$0[1],
                                     _CK_=remove(arg2);
                                    return [4,op$0,remove(arg1),_CK_];
                                   default:
                                    var args=expr$0[2],op$1=expr$0[1];
                                    return [5,op$1,map$0(remove,args)]}}
                              var expr=remove(_CG_),_CH_=caml_call1(Out$3[1],[0,max_int]);
                              return caml_call3(fprintf$0(fmt),_uX_,_CH_,expr)},
                            tasks$0);
                          var results=0}
                        else
                         {var results$0=map$0(process_task,tasks$0);
                          report(815031438,_A4_);
                          iter$0
                           (function(param)
                             {var
                               r=param[1],
                               hex=get_bool_option(_yP_),
                               prec=get_int_option(_yQ_);
                              function print_upper_bound(width,str,param)
                               {if(param)
                                 {var v=param[1],bound=string_of_float_hi(prec,v[2]);
                                  if(hex)
                                   {var _C2_=v[2];
                                    return caml_call4
                                            (report(858743897,_yR_),width,str,bound,_C2_)}
                                  return caml_call3(report(858743897,_yS_),width,str,bound)}
                                return 0}
                              function print_lower_bound(width,str,param)
                               {if(param)
                                 {var v=param[1],bound=string_of_float_lo(prec,v[1]);
                                  if(upper_bound < v[1])
                                   {var subopt=v[2] - v[1];
                                    if(hex)
                                     {var _CY_=subopt / v[2] * 100.,_CZ_=v[1];
                                      return caml_call5
                                              (report(858743897,_yT_),width,str,bound,_CZ_,_CY_)}
                                    var _C0_=subopt / v[2] * 100.;
                                    return caml_call4
                                            (report(858743897,_yU_),width,str,bound,_C0_)}
                                  if(hex)
                                   {var _C1_=v[1];
                                    return caml_call4
                                            (report(858743897,_yV_),width,str,bound,_C1_)}
                                  return caml_call3(report(858743897,_yW_),width,str,bound)}
                                return 0}
                              function string_of_interval(r)
                               {var
                                 lo=string_of_float_lo(prec,r[1]),
                                 hi=string_of_float_hi(prec,r[2]);
                                return caml_call2(sprintf(_yX_),lo,hi)}
                              function max_length(strs_and_opts)
                               {var strs_and_opts$0=strs_and_opts;
                                for(;;)
                                 {if(strs_and_opts$0)
                                   {var _CW_=strs_and_opts$0[1],_CX_=_CW_[1];
                                    if(_CW_[2])
                                     {var rest=strs_and_opts$0[2];
                                      return max(caml_ml_string_length(_CX_),max_length(rest))}
                                    var
                                     strs_and_opts$1=strs_and_opts$0[2],
                                     strs_and_opts$0=strs_and_opts$1;
                                    continue}
                                  return 0}}
                              report(858743897,_y0_);
                              var _CT_=r[1];
                              caml_call1(report(858743897,_y1_),_CT_);
                              if(get_bool_option(_y2_))
                               {var
                                 w=
                                  max_length
                                   ([0,
                                     [0,abs_approx_str,r[3]],
                                     [0,
                                      [0,abs_exact_str,r[4]],
                                      [0,
                                       [0,rel_approx_str,r[5]],
                                       [0,
                                        [0,rel_exact_str,r[6]],
                                        [0,[0,ulp_approx_str,r[7]],[0,[0,ulp_exact_str,r[8]],0]]]]]]);
                                if(0 < w)report(858743897,_y3_);
                                print_lower_bound(w,abs_approx_str,r[3]);
                                print_lower_bound(w,abs_exact_str,r[4]);
                                print_lower_bound(w,rel_approx_str,r[5]);
                                print_lower_bound(w,rel_exact_str,r[6]);
                                print_lower_bound(w,ulp_approx_str,r[7]);
                                print_lower_bound(w,ulp_exact_str,r[8]);
                                report(858743897,_y4_)}
                              var _CU_=string_of_interval(r[2]);
                              caml_call1(report(858743897,_y5_),_CU_);
                              var
                               _CQ_=upper_bound < r[2][1]?1:0,
                               _CR_=_CQ_ || (r[2][2] < f_max?1:0),
                               switch$0=0;
                              if(_CR_)
                               {var err=get_problem_absolute_error(r);
                                if(! (0. <= err))throw [0,Assert_failure,_yZ_];
                                if(err < f_max)
                                 {var
                                   bounds=_gs_(r[2],[254,- err,err]),
                                   _CS_=string_of_interval(bounds);
                                  caml_call1(report(858743897,_yY_),_CS_);
                                  switch$0 = 1}}
                              report(858743897,_y6_);
                              var
                               w$0=
                                max_length
                                 ([0,
                                   [0,abs_approx_str$0,r[3]],
                                   [0,
                                    [0,abs_exact_str$0,r[4]],
                                    [0,
                                     [0,rel_approx_str$0,r[5]],
                                     [0,
                                      [0,rel_exact_str$0,r[6]],
                                      [0,[0,ulp_approx_str$0,r[7]],[0,[0,ulp_exact_str$0,r[8]],0]]]]]]);
                              print_upper_bound(w$0,abs_approx_str$0,r[3]);
                              print_upper_bound(w$0,abs_exact_str$0,r[4]);
                              print_upper_bound(w$0,rel_approx_str$0,r[5]);
                              print_upper_bound(w$0,rel_exact_str$0,r[6]);
                              print_upper_bound(w$0,ulp_approx_str$0,r[7]);
                              print_upper_bound(w$0,ulp_exact_str$0,r[8]);
                              var _CV_=r[9];
                              return caml_call1(report(858743897,_y7_),_CV_)},
                            results$0);
                          var results=results$0}
                        close(0);
                        report(858743897,_A3_);
                        return append(rs,results)},
                      _Co_,
                      input_files),
                   results=map$0(function(_Cr_){return _Cr_[1]},_Cp_);
                  iter$1
                   (function(param,_Cq_)
                     {var fmt=_Cq_[2],oc=_Cq_[1];
                      pp_print_flush(fmt,0);
                      return close_out(oc)},
                    files);
                  clear(files);
                  return results},
               _Bg_=
                function(_Cm_,out_channel)
                 {var
                   f=
                    caml_js_wrap_callback
                     (function(s)
                       {return post_message
                                ({"ty":_Cm_,
                                  "str":caml_jsstring_of_string(caml_string_of_jsbytes(s))})});
                  return caml_ml_set_channel_output(out_channel,f)},
               _Bh_=
                function(_Cl_)
                 {caml_create_file(_Bi_,default_cfg);
                  caml_create_file(_Bk_,_Bj_);
                  caml_create_file(_Bm_,_Bl_);
                  return 0},
               _Bn_=
                function(_Cf_)
                 {try
                   {caml_call1(report(858743897,_Bq_),version);
                    clear_all(0);
                    try
                     {var base=caml_sys_getenv(_hZ_);
                      caml_call1(report(858743897,_h0_),base);
                      var _Ca_=base}
                    catch(_Ck_)
                     {_Ck_ = caml_wrap_exception(_Ck_);
                      if(_Ck_ !== Not_found)throw _Ck_;
                      var _Ca_=dirname$2(executable_name)}
                    base_dir_ref[1] = _Ca_;
                    var
                     files=[0,0],
                     f=function(name){files[1] = [0,name,files[1]];return 0},
                     parse_config_arg=
                      function(name){parse_config_file(_h2_,name);return 0},
                     main_cfg=cc(base_dir_ref[1],_h3_);
                    try
                     {var
                       c_arg=[0,_h8_,[4,parse_config_arg],_h7_],
                       _Cd_=0,
                       fpcore_arg=
                        [0,
                         _ia_,
                         [4,function(_Cj_){return set_option(_h$_,_Cd_,_h__,_Cj_)}],
                         _h9_],
                       args=
                        [0,c_arg,[0,fpcore_arg,parse_config_file(_ib_,main_cfg)]],
                       l=align(0,args);
                      try
                       {parse_argv(0,argv,l,f,msg)}
                      catch(exn)
                       {exn = caml_wrap_exception(exn);
                        if(exn[1] === Bad)
                         {var msg$0=exn[2];caml_call1(eprintf(_cF_),msg$0);exit(2)}
                        else
                         {if(exn[1] !== Help)throw exn;
                          var msg$1=exn[2];
                          caml_call1(printf(_cG_),msg$1);
                          exit(0)}}
                      iter$0(parse_config_arg,config_files);
                      var _Ce_=rev(files[1]),_Cc_=_Ce_}
                    catch(_Ci_)
                     {_Ci_ = caml_wrap_exception(_Ci_);
                      var switch$0=0;
                      if(_Ci_[1] === Failure || _Ci_[1] === Sys_error)
                       var msg$2=_Ci_[2];
                      else
                       {caml_call1(error$0(_h6_),main_cfg);
                        var _Cb_=exit(2);
                        switch$0 = 1}
                      if(! switch$0){error_str(msg$2);var _Cb_=exit(2)}
                      var _Cc_=_Cb_}
                    input_files_ref[1] = _Cc_;
                    var verbosity=get_int_option(_h4_);
                    if(verbosity < 0)caml_call1(warning(_h5_),verbosity);
                    set_log_level(level_of_int(verbosity));
                    var _Cg_=fptaylor(_Br_);
                    return _Cg_}
                  catch(_Ch_)
                   {_Ch_ = caml_wrap_exception(_Ch_);
                    return _Ch_[1] === Failure
                            ?(error_str(_Ch_[2]),0)
                            :_Ch_ === Parse_error
                              ?(error_str(_Bo_),0)
                              :(error_str(_Bp_),0)}},
               _Bs_=
                function(_B$_)
                 {return caml_js_from_array([254,_B$_[1],_B$_[2]])},
               _Bt_=function(_B__){return _B__?_Bs_(_B__[1]):null$0},
               _Bu_=
                function(_B9_,_B8_)
                 {return _B8_
                          ?caml_jsstring_of_string
                            (string_of_float_hi(_B9_,_B8_[1][2]))
                          :null$0},
               _Bv_=
                function(_BP_)
                 {var
                   _BQ_=caml_string_of_jsstring(_BP_.input),
                   _BR_=caml_string_of_jsstring(_BP_.config);
                  update_file(_Bw_,_BQ_);
                  update_file(_Bx_,_BR_);
                  var _BS_=_Bn_(0),_BT_=get_int_option(_By_);
                  return post_message
                          (caml_js_from_array
                            (of_list
                              (map$0
                                (function(_BU_)
                                  {var
                                    _BV_=_Bu_(_BT_,_BU_[8]),
                                    _BW_=_Bt_(_BU_[8]),
                                    _BX_=_Bu_(_BT_,_BU_[7]),
                                    _BY_=_Bt_(_BU_[7]),
                                    _BZ_=_Bu_(_BT_,_BU_[6]),
                                    _B0_=_Bt_(_BU_[6]),
                                    _B1_=_Bu_(_BT_,_BU_[5]),
                                    _B2_=_Bt_(_BU_[5]),
                                    _B3_=_Bu_(_BT_,_BU_[4]),
                                    _B4_=_Bt_(_BU_[4]),
                                    _B5_=_Bu_(_BT_,_BU_[3]),
                                    _B6_=_Bt_(_BU_[3]),
                                    _B7_=_Bs_(_BU_[2]);
                                   return {"name":caml_jsstring_of_string(_BU_[1]),
                                           "elapsedTime":_BU_[9],
                                           "realBounds":_B7_,
                                           "absErrorApprox":_B6_,
                                           "absErrorApproxStr":_B5_,
                                           "absErrorExact":_B4_,
                                           "absErrorExactStr":_B3_,
                                           "relErrorApprox":_B2_,
                                           "relErrorApproxStr":_B1_,
                                           "relErrorExact":_B0_,
                                           "relErrorExactStr":_BZ_,
                                           "ulpErrorApprox":_BY_,
                                           "ulpErrorApproxStr":_BX_,
                                           "ulpErrorExact":_BW_,
                                           "ulpErrorExactStr":_BV_}},
                                 _BS_))))};
              _Bg_(1,stdout);
              _Bg_(2,stderr);
              _Bh_(0);
              set_onmessage(_Bv_);
              do_at_exit(0);
              return}
            throw [0,Assert_failure,_Bz_]}
          throw [0,Assert_failure,_BA_]}
        throw [0,Assert_failure,_BB_]}
      throw [0,Assert_failure,_BC_]}}
  (function(){return this}()));
